[{"content":" 由于 GoLand 在 M1 的笔记本外接显示器上会屏幕闪烁, 所以重拾 Emacs. 记录这次配置 Emacs 的一些坑.\n中文字体 如果没有配置等宽等高的中文字体, 会在同时显示中英文的时候出现屏幕跳动, 补全的 childframe 显示错位之类的问题, 个人由于 GoLand 字体看习惯了, 所以依然使用 JetBrainsMono 作为应为字体, 中文字体选用 更莎黑体.\n显示效果如图:\n(defun +my/better-font() (interactive) ;; english font (if (display-graphic-p) (progn (set-face-attribute \u0026#39;default nil :font (format \u0026#34;%s:pixelsize=%d\u0026#34; \u0026#34;JetBrainsMono NF\u0026#34; 15)) ;; chinese font (dolist (charset \u0026#39;(kana han symbol cjk-misc bopomofo)) (set-fontset-font (frame-parameter nil \u0026#39;font) charset (font-spec :family \u0026#34;Sarasa Mono SC\u0026#34;)))) )) (defun +my|init-font(frame) (with-selected-frame frame (if (display-graphic-p) (+my/better-font)))) (add-hook \u0026#39;after-make-frame-functions #\u0026#39;+my|init-font) (+my/better-font) Environment 个人使用了 Emacs Plus 进行编译的, 会读取 login shell 中的 PATH 环境变量, 如 .zprofile .profile 文件中配置的环境变量, 但是其它的环境变量实测没有主动获取, 所以不得已还是选择使用 exec-path-from-shell 获取需要用到的环境变量.\n(if is-darwin (use-package exec-path-from-shell :defer 1 :straight t :config (setq exec-path-from-shell-variables \u0026#39;(\u0026#34;PATH\u0026#34; \u0026#34;PYTHONPATH\u0026#34; \u0026#34;GOPATH\u0026#34; \u0026#34;GTAGSOBJDIRPREFIX\u0026#34; \u0026#34;GTAGSCONF\u0026#34; \u0026#34;GTAGSLABEL\u0026#34;)) (setq exec-path-from-shell-check-startup-files nil) (setq exec-path-from-shell-arguments \u0026#39;(\u0026#34;-l\u0026#34;)) (exec-path-from-shell-initialize)) (setq dired-use-ls-dired nil) ;; 不设置该行的话会在使用dired的时候报错. ) Project 自带的 project.el 包使用了系统默认的 grep 和 find 分别作为全局查找和文件查找的工具, 这两个工具不如 ripgrep 和 fd 好用. ripgrep 和 fd 会从 .gitignore 中读取不需要搜索的文件, 所以以下配置可以修改默认 project.el 的行为.\n(use-package project :straight t :bind ((\u0026#34;C-c p p\u0026#34; . project-switch-project) (\u0026#34;C-c p f\u0026#34; . project-find-file) (\u0026#34;C-c p g\u0026#34; . project-find-regexp) (\u0026#34;C-c p b\u0026#34; . consult-project-buffer) (\u0026#34;C-c p s\u0026#34; . magit-project-status)) :init (setq project-list-file (expand-file-name \u0026#34;projects\u0026#34; prelude-local-dir)) :config (defcustom project-root-markers \u0026#39;(\u0026#34;Cargo.toml\u0026#34; \u0026#34;go.mod\u0026#34; \u0026#34;package.json\u0026#34; \u0026#34;.git\u0026#34;) \u0026#34;Files or directories that indicate the root of a project.\u0026#34; :type \u0026#39;(repeat string) :group \u0026#39;project) (defun project-root-p (path) \u0026#34;Check if the current PATH has any of the project root markers.\u0026#34; (catch \u0026#39;found (dolist (marker project-root-markers) (when (file-exists-p (concat path marker)) (throw \u0026#39;found marker))))) (defun project-find-root (path) \u0026#34;Search up the PATH for `project-root-markers\u0026#39;.\u0026#34; (let ((path (expand-file-name path))) (catch \u0026#39;found (while (not (equal \u0026#34;/\u0026#34; path)) (if (not (project-root-p path)) (setq path (file-name-directory (directory-file-name path))) (throw \u0026#39;found (cons \u0026#39;transient path))))))) (add-to-list \u0026#39;project-find-functions #\u0026#39;project-find-root) (defun my/project-files-in-directory (dir) \u0026#34;Use `fd\u0026#39; to list files in DIR.\u0026#34; (let* ((default-directory dir) (localdir (file-local-name (expand-file-name dir))) (command (format \u0026#34;fd -H -t f -0 -E .git . %s\u0026#34; localdir))) (project--remote-file-names (sort (split-string (shell-command-to-string command) \u0026#34;\\0\u0026#34; t) #\u0026#39;string\u0026lt;)))) (cl-defmethod project-files ((project (head transient)) \u0026amp;optional dirs) \u0026#34;Override `project-files\u0026#39; to use `fd\u0026#39; in local projects.\u0026#34; (mapcan #\u0026#39;my/project-files-in-directory (or dirs (list (project-root project))))) (setq magit-bind-magit-project-status nil) (define-key project-prefix-map \u0026#34;v\u0026#34; #\u0026#39;vterm) (define-key project-prefix-map \u0026#34;m\u0026#34; #\u0026#39;magit-project-status) (setq project-switch-commands \u0026#39;((project-find-file \u0026#34;Find file\u0026#34;) (project-find-regexp \u0026#34;Find ripgrep\u0026#34;) (project-find-dir \u0026#34;Find directory\u0026#34;) (vterm \u0026#34;VTerm\u0026#34;) (magit-project-status \u0026#34;Magit\u0026#34;))) ) (setq xref-search-program \u0026#39;ripgrep) Buffer switch-to-next-buffer 和 switch-to-prev-buffer 可以通过 switch-to-prev-buffer-skip 设置的函数进行过滤跳转, 大部分时候切换 buffer 是希望在项目中的文件进行切换, 并不想切换到 emacs 的一些包的 log buffer, 所以可以通过设置 boring-buffer-p 来决定哪些 buffer 是不想通过快捷键切出来的.\n(defun project-buffer-p (buf) (member (buffer-name buf) (let ((buffers ())) (dolist (pr (project-buffers (project-current))) (push (buffer-name pr) buffers)) buffers))) (defun vmacs-boring-buffer-p(\u0026amp;optional buf) (string-match-p (rx (or \u0026#34;\\*Async-native-compile-log\\*\u0026#34; \u0026#34;magit\u0026#34; \u0026#34;\\*company-documentation\\*\u0026#34; \u0026#34;\\*eaf\u0026#34; \u0026#34;\\*eldoc\u0026#34; \u0026#34;\\*Launch \u0026#34; \u0026#34;*dap-\u0026#34; \u0026#34;*EGLOT \u0026#34; \u0026#34;\\*Flymake log\\*\u0026#34; \u0026#34;\\*gopls::stderr\\*\u0026#34; \u0026#34;\\*gopls\\*\u0026#34; \u0026#34;\\*Compile-Log\\*\u0026#34; \u0026#34;*Backtrace*\u0026#34; \u0026#34;*Package-Lint*\u0026#34; \u0026#34;\\*sdcv\\*\u0026#34; \u0026#34;\\*tramp\u0026#34; \u0026#34;\\*lsp-log\\*\u0026#34; \u0026#34;\\*tramp\u0026#34; \u0026#34;\\*Ibuffer\\*\u0026#34; \u0026#34;\\*Help\\*\u0026#34; \u0026#34;\\*ccls\u0026#34; \u0026#34;\\*vc\u0026#34; \u0026#34;\\*xref\u0026#34; \u0026#34;\\*Warnings*\u0026#34; \u0026#34;\\*Http\u0026#34; \u0026#34;\\*Async Shell Command\\*\u0026#34; \u0026#34;\\*Shell Command Output\\*\u0026#34; \u0026#34;\\*Calculator\\*\u0026#34; \u0026#34;\\*Calc \u0026#34; \u0026#34;\\*Flycheck error messages\\*\u0026#34; \u0026#34;\\*Gofmt Errors\\*\u0026#34; \u0026#34;\\*Ediff\u0026#34; \u0026#34;\\*sdcv\\*\u0026#34; \u0026#34;\\*Org PDF LaTex Output\\*\u0026#34; \u0026#34;\\*Org Export\u0026#34; \u0026#34;\\*osx-dictionary\\*\u0026#34; \u0026#34;\\*Messages\\*\u0026#34; \u0026#34;\\*straight-process\\*\u0026#34; )) (buffer-name buf))) (defun vmacs-tab-vterm-p(\u0026amp;optional buf) (eq (buffer-local-value \u0026#39;major-mode (or buf (current-buffer))) \u0026#39;vterm-mode)) ;; switch-to-prev-buffer 与 switch-to-next-buffer 时 skip 特定的buffers ;;而 tab-line-switch-to-prev/next-tab 恰好使用了上面两个函数 (defun vmacs-switch-to-prev-buffer-skip(win buf bury-or-kill) (when (member this-command \u0026#39;(next-buffer previous-buffer switch-to-prev-buffer switch-to-next-buffer)) (cond ;; ((vmacs-tab-vterm-p) ;当前buffer是vterm ;; (not (vmacs-tab-vterm-p buf))) ;若buf 不是vterm,则skip ((vmacs-boring-buffer-p (current-buffer)) (not (vmacs-boring-buffer-p buf))) (t ;当前buffer是正常buffer (or (vmacs-boring-buffer-p buf) ;若buf 是boring buf 或vterm，则跳过 (vmacs-tab-vterm-p buf) (not (project-buffer-p buf)) ))))) (setq switch-to-prev-buffer-skip #\u0026#39;vmacs-switch-to-prev-buffer-skip) ","date":"2022-12-13T20:22:00+08:00","permalink":"/post/emacs_rabbit_hole_1/","title":"Emacs Rabbit Hole - 1"},{"content":" Fedora 36 : Kubernetes\n配置网络 # dnf install langpacks-zh_CN glibc-all-langpacks -y cat \u0026lt;\u0026lt;EOF | sudo tee /etc/sysctl.d/99-k8s-cri.conf net.bridge.bridge-nf-call-iptables=1 net.ipv4.ip_forward=1 net.bridge.bridge-nf-call-ip6tables=1 EOF # 开启所需网络模块 overlay br_netfilter echo -e overlay\\\\nbr_netfilter \u0026gt; /etc/modules-load.d/k8s.conf # nftables切换到 iptables-legacy, 不切换发现也没问题 sudo dnf install iptables-legacy sudo alternatives --config iptables # 关闭 swap sudo touch /etc/systemd/zram-generator.conf # 原文有切换到 cgroup1 目前没发现不切换有什么问题. # 关闭防火墙 sudo systemctl disable --now firewalld # Set SELinux in permissive mode (effectively disabling it) sudo setenforce 0 sudo sed -i \u0026#39;s/^SELINUX=enforcing$/SELINUX=permissive/\u0026#39; /etc/selinux/config # 关闭 systemd-resolved 防止解析 dns 回环 # [docker - Kubernetes CoreDNS in CrashLoopBackOff - Stack Overflow](https://stackoverflow.com/questions/53559291/kubernetes-coredns-in-crashloopbackoff) sudo systemctl disable --now systemd-resolved sudo vi /etc/NetworkManager/NetworkManager.conf # conf # [main] # dns=default sudo unlink /etc/resolv.conf sudo touch /etc/resolv.conf sudo reboot 安装必要软件 使用 containerd\n# https://github.com/containerd/containerd/releases sudo tar Cxzvf /usr/local containerd-1.6.2-linux-amd64.tar.gz wget https://raw.githubusercontent.com/containerd/containerd/main/containerd.service sudo mkdir -p /usr/local/lib/systemd/system sudo mv containerd.service /usr/local/lib/systemd/system sudo systemctl daemon-reload sudo systemctl enable --now containerd # https://github.com/opencontainers/runc/releases install -m 755 runc.amd64 /usr/local/sbin/runc # https://github.com/containernetworking/plugins/releases sudo mkdir -p /opt/cni/bin sudo tar Cxzvf /opt/cni/bin cni-plugins-linux-amd64-v1.1.1.tgz sudo mkdir /etc/containerd containerd config default | cat | sudo tee /etc/containerd/config.toml \u0026amp;\u0026gt;/dev/null # 修改 config 文件 SystemdCgroup = true sudo systemctl restart containerd cat \u0026lt;\u0026lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\\$basearch enabled=1 gpgcheck=1 gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg exclude=kubelet kubeadm kubectl EOF 初始化及后续配置 sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes sudo systemctl enable --now kubelet sudo kubeadm init --pod-network-cidr=10.1.0.0/16 mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config # 如果忘了 join 命令可以使用如下命令获得. kubeadm token create --print-join-command # 配置网络容器 wget https://docs.projectcalico.org/manifests/calico.yaml # - name: IP # value: \u0026#34;autodetect\u0026#34; # - name: IP_AUTODETECTION_METHOD # value: \u0026#34;interface=eth.*\u0026#34; kubectl apply -f calico.yaml # 其它集群将 kubeadm init 替换成 join 命令就可以了. # 在需要操作容器的节点安装 nerdctl # https://github.com/containerd/nerdctl/releases sudo tar Cxzvf /usr/local/bin nerdctl-0.22.0-linux-amd64.tar.gz mkdir -p $HOME/.local/bin chmod 700 $HOME/.local/bin cp /usr/local/bin/nerdctl $HOME/.local/bin sudo chown root $HOME/.local/bin/nerdctl sudo chmod +s $HOME/.local/bin/nerdctl exec zsh # 配置补全 nerdctl completion zsh | cat | sudo tee /usr/share/zsh/site-functions/_nerdctl \u0026amp;\u0026gt;/dev/null exec zsh ","date":"2022-08-02T01:16:00+08:00","permalink":"/post/k8s/actions/deploy_k8s_in_fedora/","title":"Deploy kubernetes in Fedora 36"},{"content":" 逆变和协变看了忘忘了看, 这次学C#顺带查阅各处总结了下\u0026hellip;\n协变\n协变是指能够使用比原始指定的类型派生程度更大的类型.\n例如Dog与Cat继承自Animal, 那么从Dog-\u0026gt;Animal就称为协变, 那么协变有什么作用呢?\n// Animal.cs public abstract class Animal { } public class Dog : Animal { } // Main.cs public static void Main() { Dog dog = new Dog(); Animal animal = dog; List\u0026lt;Dog\u0026gt; dogs = new List\u0026lt;Dog\u0026gt;(); List\u0026lt;Animal\u0026gt; animals = dogs; // error } Dog继承自Animal, 所以Dog可以隐式的转化为Animal, 但是List与List之间没有继承关系, 所以无法隐式转换, 如果想要隐式转换需要如下代码:\nList\u0026lt;Animal\u0026gt; animals = dogs.Select(d =\u0026gt; (Animal)d).ToList(); 将小狗列表中的小狗挨个显式转换为Animal.\n所以C#提供了协变的语法糖, 也就是out, 意思是指该泛型可以作为输出返回. 也就是说可以用如下代码:\n// Main.cs public static void Main() { Dog dog = new Dog(); Animal animal = dog; IEnumerable\u0026lt;Dog\u0026gt; dogs = new List\u0026lt;Dog\u0026gt;(); IEnumerable\u0026lt;Animal\u0026gt; animals = dogs; } // IEnumerable public interface IEnumerable\u0026lt;out T\u0026gt;: IEnumerable 因为T只能作为结果返回, 所以T不会被修改, 编译器可以帮我们进行强制转换. 但实际上out只是上面强制转换的一个语法糖而已, 实际上反编译的代码依然进行的是强制类型转换.\nIEnumerable\u0026lt;Animal\u0026gt; animals = (IEnumerable\u0026lt;Animal\u0026gt;) dogs; 至于为什么只能作为结果返回而不能作为输入呢? 我们假设:\nA ≼ B 意味着 A 是 B 的子类型. A → B 指的是以 A 为参数类型, 以 B 为返回值类型的函数类型. x : A 意味着 x 的类型为 A. 假设我有如下三种类型: Greyhound ≼ Dog ≼ Animal 问题: 以下哪种类型是 Dog → Dog 的子类型呢？\nGreyhound → Greyhound Greyhound → Animal Animal → Animal Animal → Greyhound 我们假设 f 是一个以 Dog → Dog 为参数的函数, 那么可以这样假设: f : (Dog → Dog) → String\n那么容易回答上述问题:\n不是, 因为传入的类型可能是狗的其它自类型但不是灰狗, 这样也是符合函数签名的, 但是答案1就不符合了. 同上 不是, 因为有可能 f 在调用完参数之后让它的返回值(Animal)狗叫, 但是并非所有的动物都会狗叫, 所以同样存在符合函数签名但不是答案4的结果. 是的, 所有的Dog都是Animal, 所以传进去的任何Dog都是符合的, 而所有的Greyhoud都是狗, 也都可以狗叫. 这样就可以得到我们最初的答案了\u0026mdash;为什么只能作为结果返回而不能作为参数输入, 因为所有的Dog都是Animal, 但是如果作为参数的话, 那么不是所有的Animal都是Dog, 就有可能往IEnumerable里传一个Cat, 但这又是符合IEnumerable签名的, 所以是不行的.\n而由上面的例子也可以得到, 与协变相反的就是逆变, 也就是超类可以作为泛型参数而不能作为输出结果, 简单的公式为: (Animal → Greyhound) ≼ (Dog → Dog)\n解释为: 我们允许一个函数类型中, 返回值类型是协变的, 而参数类型是逆变的. 返回值类型是协变的, 意思是 A ≼ B 就意味着 (T → A) ≼ (T → B) . 参数类型是逆变的, 意思是 A ≼ B 就意味着 (B → T) ≼ (A → T) A 和 B 的位置颠倒过来了, 通俗点协变就是返回值可以是超类, 而逆变则是参数可以是子类.\n","date":"2021-05-01T00:50:44+08:00","permalink":"/post/programming_language/covariance_and_contravariance/","title":"Covariance and Contravariance"},{"content":" 本译文译自 Peeking inside a Rust enum\n前言 在我最近 Rust Q\u0026amp;A twitch 频道里, 有些人提出了一个看起来简单的问题: 为什么 small string 类型, 像 SmartString or SmolStr 和 String 有着一样的大小, 但是 small vec 类型, 像 SmallVec 却要比 Vec 大?\n我知道我使用了简单作为形容词, 但是事实上要了解这个问题, 我们需要一些背景知识\n译者: 亿点点\u0026hellip;\n这个问题到底是什么? 我最近谈到 Rust small string crates.\n被这些 crates 导出的类型可以避免多次内存分配, 并且降低内存使用量. 让我们看一个 smartstring 的代码作为例子.\nuse smartstring::{Compact, SmartString}; use std::mem::size_of_val; fn main() { let smart = SmartString::\u0026lt;Compact\u0026gt;::from(\u0026#34;hello world\u0026#34;); dbg!(size_of_val(\u0026amp;smart)); let stand = String::from(\u0026#34;hello world\u0026#34;); dbg!(size_of_val(\u0026amp;stand)); } $ cargo run -q [src/main.rs:6] size_of_val(\u0026amp;smart) = 24 [src/main.rs:9] size_of_val(\u0026amp;stand) = 24 正如你看到的, 同样也是最初的问题描述的那样, 这两个类型的大小是相同的.\n毫无疑问的, `String` 存储实际数据是在别的地方? 因为所有 `String` 类型值的大小在64位平台上都是24个字节.\n是的, 这当然不是一个完整的故事, 在这个特别的例子中, smart 以 inline 的方式存储它的值(在栈上), 而标准库将值存储在堆上:\n如果我们想知道每个类型到底总共使用了多少内存, 我们可以这样做:\nlet smart = SmartString::\u0026lt;Compact\u0026gt;::from(\u0026#34;hello world\u0026#34;); dbg!(size_of_val(\u0026amp;smart)); let stand = String::from(\u0026#34;hello world\u0026#34;); dbg!(size_of_val(\u0026amp;stand) + stand.capacity()); $ cargo run -q [src/main.rs:6] size_of_val(\u0026amp;smart) = 24 [src/main.rs:9] size_of_val(\u0026amp;stand) + stand.capacity() = 35 好吧, 但是 - 你说 String 显而易见在堆中存放它的内容. 有什么方法可以正式这个说法么? 当然有!\n典型的, 在 Linux 64-bit 系统中栈和堆在虚拟地址中的空间相差很远, 这意味着我们如果打印字符串的元数据的地址和内容的地址, 我们就可以看到:\nSmartString 的元数据和内容在相邻的位置. String 的元数据和内容相距很远. use smartstring::{Compact, SmartString}; fn main() { let smart = SmartString::\u0026lt;Compact\u0026gt;::from(\u0026#34;hello world\u0026#34;); let smart_meta = \u0026amp;smart as *const _; let smart_data = \u0026amp;smart.as_bytes()[0] as *const _; dbg!((smart_meta, smart_data)); let stand = String::from(\u0026#34;hello world\u0026#34;); let stand_meta = \u0026amp;stand as *const _; let stand_data = \u0026amp;stand.as_bytes()[0] as *const _; dbg!((stand_meta, stand_data)); } $ cargo run -q [src/main.rs:7] (smart_meta, smart_data) = ( 0x00007ffce4cf4728, 0x00007ffce4cf4729, ) [src/main.rs:12] (stand_meta, stand_data) = ( 0x00007ffce4cf47f8, 0x0000555f87686a60, ) 好吧, 我信了. 那么 smart 总是把它的数据存储在栈中吗?\n不! 只有在小于24字节的时候是存储在栈上的, 就和 String 一样. 我们用稍微长一点的字符串来看看.\nuse smartstring::{Compact, SmartString}; fn main() { let input = \u0026#34;Turns out you can blame your tools *and* be a good craftsperson. Who knew?\u0026#34;; let smart = SmartString::\u0026lt;Compact\u0026gt;::from(input); let smart_meta = \u0026amp;smart as *const _; let smart_data = \u0026amp;smart.as_bytes()[0] as *const _; dbg!((smart_meta, smart_data)); let stand = String::from(input); let stand_meta = \u0026amp;stand as *const _; let stand_data = \u0026amp;stand.as_bytes()[0] as *const _; dbg!((stand_meta, stand_data)); } $ cargo run -q [src/main.rs:9] (smart_meta, smart_data) = ( 0x00007ffd460d0268, 0x0000555f4636ca30, ) [src/main.rs:14] (stand_meta, stand_data) = ( 0x00007ffd460d0338, 0x0000555f4636cac0, ) \u0026hellip;然后我们就可以看到这两个类型的内容现在都放在堆上了.\n这样, 那 SmartString 是否意味着买一送一的处理方式? 这和他的类型有关?\n它是怎么工作的?\n多么好的一个问题. 让我们谈谈枚举\n一个单词, 多种意义 如果你有着 C/C++/Java/C# 的语言背景, 一个 enum 仅仅意味着一个 Integer 类型, 只是它的值有着自己的意义.\n让我们看一个 C 的例子:\n#include \u0026lt;stdio.h\u0026gt; enum Drink { Water, Soda, Juice, }; int main() { enum Drink dri = Soda; printf(\u0026#34;dri = %d\\n\u0026#34;, dri); printf(\u0026#34;sizeof(dri) = %ld\\n\u0026#34;, sizeof(dri)); printf(\u0026#34;sizeof(int) = %ld\\n\u0026#34;, sizeof(int)); } 这里, 我们声明了一个枚举类型 enum Drink, 有三个变体, 不过仅仅是从0开始的数字, 所以我们有 Water = 0, Soda = 1, Juice = 2:\n$ clang -Wall main.c -o main \u0026amp;\u0026amp; ./main dri = 1 sizeof(dri) = 4 sizeof(int) = 4 然而我不是很喜欢这个代码, 我不想要额外的限定词, 并且想要我的变体有着自己的命名空间, 但在 C 里面我们需要自己做这些事:\n#include \u0026lt;stdio.h\u0026gt; // this could also be done in two separate declarations typedef enum Drink { Drink_Water, Drink_Soda, Drink_Juice, } Drink; int main() { Drink dri = Drink_Soda; printf(\u0026#34;dri = %d\\n\u0026#34;, dri); printf(\u0026#34;sizeof(dri) = %ld\\n\u0026#34;, sizeof(dri)); printf(\u0026#34;sizeof(int) = %ld\\n\u0026#34;, sizeof(int)); } Ahhh, 好多了. 但是这里仍然有其它的东西我不是特别喜欢, 像是 C 的 switch. 下面的代码是错误的:\n#include \u0026lt;stdio.h\u0026gt; typedef enum Drink { Drink_Water, Drink_Soda, Drink_Juice, } Drink; void print_drink(Drink dri) { switch (dri) { case Drink_Water: printf(\u0026#34;It\u0026#39;s water!\\n\u0026#34;); case Drink_Soda: printf(\u0026#34;It\u0026#39;s soda!\\n\u0026#34;); case Drink_Juice: printf(\u0026#34;It\u0026#39;s juice!\\n\u0026#34;); } } int main() { print_drink(Drink_Soda); } 正确的代码是在每个 case 语句的结尾都使用 break. 这是刚起步的开发人员很早就应该了解的事情之一.\nCool bear's hot tip 鹅妹子嘤, 在 `C#` 中是强制要求在每个非空的 case 中添加 break 否则不能编译通过, 这防止你硬编码错误而导致的隐式跌落(意思是没有 break 的情况就一个 case 一个 case 向下运行), 如果喜欢的话你仍然可以实现一个 明确的跌落. 即使我们修复了 switch 的问题, 还有件我不喜欢 C 枚举的事情, 那就是没什么可以阻止我传递一个无意义的值:\n#include \u0026lt;stdio.h\u0026gt; typedef enum Drink { Drink_Water, Drink_Soda, Drink_Juice, } Drink; void print_drink(Drink dri) { switch (dri) { case Drink_Water: printf(\u0026#34;It\u0026#39;s water!\\n\u0026#34;); break; case Drink_Soda: printf(\u0026#34;It\u0026#39;s soda!\\n\u0026#34;); break; case Drink_Juice: printf(\u0026#34;It\u0026#39;s juice!\\n\u0026#34;); break; } } int main() { print_drink(47); } $ clang -Wall main.c -o main \u0026amp;\u0026amp; ./main 现在, 如果我们看看 Rust 的枚举\u0026hellip; 这是个完全不同的事情.\n让我们尽量写一个相同的程序.\nuse std::mem::size_of_val; enum Drink { Water, Soda, Juice, } fn main() { let dri = Drink::Water; dbg!(size_of_val(\u0026amp;dri)); dbg!(dri as u32); } $ cargo run -q warning: variant is never constructed: `Soda` --\u0026gt; src/main.rs:5:5 | 5 | Soda, | ^^^^ | = note: `#[warn(dead_code)]` on by default warning: variant is never constructed: `Juice` --\u0026gt; src/main.rs:6:5 | 6 | Juice, | ^^^^^ warning: 2 warnings emitted [src/main.rs:11] size_of_val(\u0026amp;dri) = 1 [src/main.rs:12] dri as u32 = 0 那么我们明显地得到了什么好处呢?\n让我看看, 这看起来像是一个 Integer 类型 - 至少, 我能把它转型为一个 u32. 但是它默认就有命名空间?\n对的, 但那并不是全部! 编译器警告我们有没有使用的变体, 并且我们可以简单地给这个枚举派生一个 Debug trait 的实现:\n#[derive(Debug)] enum Drink { Water, Soda, Juice, } fn main() { print_drink(\u0026amp;Drink::Water); print_drink(\u0026amp;Drink::Juice); print_drink(\u0026amp;Drink::Soda); } fn print_drink(dri: \u0026amp;Drink) { println!(\u0026#34;{:?}\u0026#34;, dri); } $ cargo run -q Water Juice Soda \u0026hellip;并且假如我们不那么做, 我们也能使用 match 而不是 switch, match 会检查是否匹配了枚举的所有变体, 举个例子, 下面的代码不能通过编译:\nfn print_drink(dri: \u0026amp;Drink) { match dri { Drink::Water =\u0026gt; println!(\u0026#34;it\u0026#39;s water!\u0026#34;), Drink::Soda =\u0026gt; println!(\u0026#34;it\u0026#39;s soda!\u0026#34;), } } $ cargo run -q error[E0004]: non-exhaustive patterns: `\u0026amp;Juice` not covered --\u0026gt; src/main.rs:15:11 | 2 | / enum Drink { 3 | | Water, 4 | | Soda, 5 | | Juice, | | ----- not covered 6 | | } | |_- `Drink` defined here ... 15 | match dri { | ^^^ pattern `\u0026amp;Juice` not covered | = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms = note: the matched value is of type `\u0026amp;Drink` 编译器给出了两种可能的方法来修复这个问题, 或是添加一个通配符:\nfn print_drink(dri: \u0026amp;Drink) { match dri { Drink::Water =\u0026gt; println!(\u0026#34;it\u0026#39;s water!\u0026#34;), Drink::Soda =\u0026gt; println!(\u0026#34;it\u0026#39;s soda!\u0026#34;), _ =\u0026gt; println!(\u0026#34;it\u0026#39;s something we don\u0026#39;t know about!\u0026#34;), } } 或者是覆盖到所有的情况:\nfn print_drink(dri: \u0026amp;Drink) { match dri { Drink::Water =\u0026gt; println!(\u0026#34;it\u0026#39;s water!\u0026#34;), Drink::Soda =\u0026gt; println!(\u0026#34;it\u0026#39;s soda!\u0026#34;), Drink::Juice =\u0026gt; println!(\u0026#34;it\u0026#39;s juice!\u0026#34;), } } Cool bear's hot tip 这听起来是不是要敲很多代码? 幸运的是, rust-analyzer 可以帮忙补全 case, 这帮我们自动生成的很大一部分代码. 讲到 match, 它也是一个表达式, 所以我们也可以这么做:\nfn print_drink(dri: \u0026amp;Drink) { println!( \u0026#34;{}\u0026#34;, match dri { Drink::Water =\u0026gt; \u0026#34;it\u0026#39;s water!\u0026#34;, Drink::Soda =\u0026gt; \u0026#34;it\u0026#39;s soda!\u0026#34;, Drink::Juice =\u0026gt; \u0026#34;it\u0026#39;s juice!\u0026#34;, } ) } 尽管就我个人而言, 我可能更倾向于这样写:\nfn print_drink(dri: \u0026amp;Drink) { let name = match dri { Drink::Water =\u0026gt; \u0026#34;water\u0026#34;, Drink::Soda =\u0026gt; \u0026#34;soda\u0026#34;, Drink::Juice =\u0026gt; \u0026#34;juice\u0026#34;, }; println!(\u0026#34;it\u0026#39;s {}!\u0026#34;, name) } 让我们想想, 我们还抱怨了 C 枚举的什么地方?\n你可以传递无意义的值!\n对! 让我们试试:\nfn main() { print_drink(\u0026amp;Drink::Water); print_drink(\u0026amp;Drink::Juice); print_drink(\u0026amp;Drink::Soda); let val: Drink = 4 as Drink; print_drink(\u0026amp;val); } $ cargo run -q error[E0605]: non-primitive cast: `i32` as `Drink` --\u0026gt; src/main.rs:13:22 | 13 | let val: Drink = 4 as Drink; | ^^^^^^^^^^ | = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` traitt Ah, 这看起来并不能工作! 然而在某些情形中我们可能需要这么做, 我们可以解析一个二进制格式, 并且已经确保检查这个数字类型的值在这个枚举中是有意义的 - 那么我们可以使用 transmute:\n#[allow(dead_code)] enum Drink { Water, Soda, Juice, } fn main() { let juice_from_binary_format = 2; let val: Drink = unsafe { std::mem::transmute(juice_from_binary_format as u8) }; print_drink(\u0026amp;val); } fn print_drink(dri: \u0026amp;Drink) { let name = match dri { Drink::Water =\u0026gt; \u0026#34;water\u0026#34;, Drink::Soda =\u0026gt; \u0026#34;soda\u0026#34;, Drink::Juice =\u0026gt; \u0026#34;juice\u0026#34;, }; println!(\u0026#34;it\u0026#39;s {}!\u0026#34;, name) } $ cargo run -q it\\\u0026#39;s juice! 当前, 通常我们希望给这个不安全操作提供一个安全的接口:\nuse std::convert::{TryFrom, TryInto}; #[allow(dead_code)] enum Drink { Water, Soda, Juice, } impl TryFrom\u0026lt;i32\u0026gt; for Drink { type Error = \u0026amp;\u0026#39;static str; fn try_from(x: i32) -\u0026gt; Result\u0026lt;Self, Self::Error\u0026gt; { match x { 0..=2 =\u0026gt; Ok(unsafe { std::mem::transmute(x as u8) }), _ =\u0026gt; Err(\u0026#34;invalid Drink value\u0026#34;), } } } fn main() { let juice_from_binary_format: i32 = 2; let val: Drink = juice_from_binary_format.try_into().unwrap(); print_drink(\u0026amp;val); let invalid_value: i32 = 4; let val: Drink = invalid_value.try_into().unwrap(); print_drink(\u0026amp;val); } $ cargo run -q it\\\u0026#39;s juice! thread \u0026#39;main\u0026#39; panicked at \u0026#39;called `Result::unwrap()` on an `Err` value: \u0026#34;invalid Drink value\u0026#34;\u0026#39;, src/main.rs:27:22 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace 并且我们的快乐还并不止步于此.\n还记得我们之前打印我们的枚举大小么? 让我们来 refresh out memory:\nuse std::mem::size_of; #[allow(dead_code)] enum Drink { Water, Soda, Juice, } fn main() { dbg!(size_of::\u0026lt;Drink\u0026gt;()); } $ cargo run -q [src/main.rs:11] size_of::\u0026lt;Drink\u0026gt;() = 1 单位是字节, 所以这里显示我们的枚举只有一个字节.\n让我们与 C 的对比下:\n#include \u0026lt;stdio.h\u0026gt; typedef enum Drink { Drink_Water, Drink_Soda, Drink_Juice, } Drink; int main() { printf(\u0026#34;sizeof(Drink) = %ld\\n\u0026#34;, sizeof(Drink)); } $ clang -Wall main.c -o main \u0026amp;\u0026amp; ./main sizeof(Drink) = 4 这里枚举有足足4个字节, 所以我们可以近似地说 Rust 的枚举是 u8, C 枚举是 u32.\n如果 Rust 的枚举超过256个变体呢?\nuse std::mem::size_of; #[allow(dead_code)] enum Drink { Variant0, Variant1, Variant2, Variant3, Variant4, // (etc.) Variant252, Variant253, Variant254, Variant255, Variant256, } fn main() { dbg!(size_of::\u0026lt;Drink\u0026gt;()); } 等等, 这里只有256个变体?\nNice try cool bear, but no! 你只是在数栅栏中的格子, 你应该数标杆.\n译者: counting the fences, when you should be counting the posts.\n不管怎样, 我们先看看现在的枚举大小?\n$ cargo run -q [src/main.rs:265] size_of::\u0026lt;Drink\u0026gt;() = 2 2个字节! 看起来又像是 u16.\n当然看起来像并不是一个专业术语 - 专业术语应该是 \u0026ldquo;representation\u0026rdquo;. 一个 Rust 枚举是对特定整数类型的抽象.\n让我们看看我们原来的 Drink:\n概念上, Drink 只有三个有意义的值, 但是它的表现是一个 u8, 能持有256个不同的值. 这就是你为什么总是能把 Drink 转为 u8, 但是把 u8 转为 Drink 却是一个容易出错的操作.\n因此使用 TryFrom/TryInto 而不是 From/Into\n对的! 潜在的 Drink 作为一个 u8 应该总是为0, 1或者2, 这被称为不变体(invariant). 如果我们破坏了这个不变体, 我们的代码就不是那么健壮了.\n在 Rust, 破坏不变体需要使用 unsafe 代码:\nuse std::mem::transmute; #[allow(dead_code)] #[derive(Debug, PartialEq)] enum Drink { Water, Soda, Juice, } fn main() { // woops! that\u0026#39;s unsound. let d: Drink = unsafe { transmute(15_u8) }; dbg!(\u0026amp;d); dbg!(d == Drink::Juice); } $ cargo run -q [src/main.rs:14] \u0026amp;d = Juice [src/main.rs:15] d == Drink::Juice = false 这太糟了 - 但是你没法意外的通过安全代码来获取一个无效的枚举值不是吗?\n对的, unsafe关键字将一个区域标记为更少的约束, 所以在代码审查中要对有潜在危险的代码格外注意.\n听起来很糟. 是不是意味着有 unsafe 的代码就很糟糕呢?\n有时候是不可避免的. 但是仅仅是有时候! 库作者通常会发现他们并不是真的需要 unsafe 来做他们想做的事情, 他们可以把那些替换成安全的代码 - 这使得只有更少的区域需要去重点关注.\n不能使语言本身完全没有 unsafe 代码吗?\n完全不要 unsafe 代码是一个比较大的话题, 但是当然需要更少的不安全代码. 举个例子, 有一个为了 safe(r) transmute 的工作小组.\n问题的关键在于不是所有的事情都可以交由计算机去做(意味着需要你自己去做), 可以使用 Rust 的模型检查. 因为种种原因, 你仍然需要 unsafe 代码.\n这并不意味有着两种 Rust, 仅仅意味着不同的风险以及不同的可信任等级.\n如果你相信 Rust 核心团队可以根除标准库中的不健全之处, 那么你甚至就可以让团队中的初级人员在此基础上编写受 Rust 安全保证的 safe code.\nRust枚举不止于此 Cool bear早先说 SmartString 有着买一送一的处理字符串的方式. Cool bear是对的!\n让我们来自己做一个 two-for-one 的处理方式:\nenum UserID { Number(u64), Text(String), } UserID 是一个聚合类型, 一个 UserID 的值可以是一个 UserID::Number 变体, 或是一个 UserID::Text 变体.如果我们想对它的内容做些操作, 我们需要用模式匹配:\nfn print_user_id(id: \u0026amp;UserID) { match id { UserID::Number(n) =\u0026gt; { println!(\u0026#34;user id number {}\u0026#34;, n); } UserID::Text(s) =\u0026gt; println!(\u0026#34;user id {}\u0026#34;, s), } } 希望你对这个用法很熟悉, 我们在不久前刚提到过这个用法.\n让我们进行一次打印操作:\nfn main() { print_user_id(\u0026amp;UserID::Number(79)); print_user_id(\u0026amp;UserID::Text(\u0026#34;fh99a73gbh8\u0026#34;.into())); } $ cargo run -q user id number 79 user id fh99a73gbh8 我们在这文章之前看到过另一个聚合类型, 然后我们实现 TryInto, 我们会返回 Result\u0026lt;T, E\u0026gt;:\nimpl TryFrom\u0026lt;i32\u0026gt; for Drink { type Error = \u0026amp;\u0026#39;static str; fn try_from(x: i32) -\u0026gt; Result\u0026lt;Self, Self::Error\u0026gt; { // omitted } } Result 值是一个枚举, 它实际是这样定义的:\npub enum Result\u0026lt;T, E\u0026gt; { /// Contains the success value Ok(T), /// Contains the error value Err(E), } 让我们返回看我们的 UserID 枚举:\nenum UserID { Number(u64), Text(String), } 它的大小是多少呢? 如果我们尝试在 C 里模拟实现一个 Rust 的枚举, 它将会看起来如下:\n#include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; enum UserIDKind { UserIDKind_Number, UserIDKind_Text, }; struct UserID { enum UserIDKind kind; uint64_t number; char *text; }; 尽管我们只需要两个变体, 但我们需要三个属性, 以让我们知道我们现在处理的是哪一个变体.\n举个例子, 在 print_user_id, 我们应该使用 switch 来处理我们使用的是 Number 变体还是 Text 变体:\nvoid print_user_id(struct UserID* id) { switch (id-\u0026gt;kind) { case UserIDKind_Number: printf(\u0026#34;user id number %lu\\n\u0026#34;, id-\u0026gt;number); break; case UserIDKind_Text: printf(\u0026#34;user id %s\\n\u0026#34;, id-\u0026gt;text); break; } } 并且当我们初始化 UserID 结构体的时候, 我们仅需要初始化我们需要的属性, 并且设置它的 kind:\nint main() { struct UserID a = { .kind = UserIDKind_Number, .number = 79, }; print_user_id(\u0026amp;a); struct UserID b = { .kind = UserIDKind_Text, .text = \u0026#34;fh99a73gbh8\u0026#34;, }; print_user_id(\u0026amp;b); } 这是可以工作的:\n$ clang -Wall main.c -o main \u0026amp;\u0026amp; ./main user id number 79 user id fh99a73gbh8 但这并不理想, 这并没有像 Rust 那样的安全保证, 我们无法阻止你创建一个 Text 而 kind 是一个 Number:\nint main() { struct UserID woops = { .kind = UserIDKind_Number, .text = \u0026#34;woops\u0026#34;, }; print_user_id(\u0026amp;woops); } $ clang -Wall main.c -o main \u0026amp;\u0026amp; ./main user id number 0 我们实现了一个不完善的抽象 - 我们可以直接访问它的底层表示, 并且以不合理的方式操作它.\n举个例子, 如果我们的 UserID 是使用 malloc 在堆上分配的并且也没有清零, 那会发生什么?\n#include \u0026lt;stdlib.h\u0026gt; int main() { struct UserID *woops = malloc(sizeof(struct UserID)); woops-\u0026gt;kind = UserIDKind_Text; woops-\u0026gt;number = 79; print_user_id(woops); } 在debug模式编译下, 它不会很糟糕:\n$ clang -Wall main.c -o main \u0026amp;\u0026amp; ./main user id (null) 然而在release模式编译下, 随着优化的打开, 将会发生很有趣的现象:\n$ clang -O3 -Wall main.c -o main \u0026amp;\u0026amp; ./main user id } $ clang -O3 -Wall main.c -o main \u0026amp;\u0026amp; ./main user id $ clang -O3 -Wall main.c -o main \u0026amp;\u0026amp; ./main user id m 从哪里来的? 谁知道呢. 但是它没有导致段错误 - 这意味着它从程序的其他部分读取数据. 在一个大型程序中, 那可能是用户的隐私数据, 而这个漏洞就可能被用来窃取隐私数据.\n不过这并不是一篇讲 C 有多危险的文章,\n...你一直在讲\n\u0026hellip;emmm, 让我们看看还有什么不好的地方.\n首先让我们看看我们 struct UserID 的大小:\n$ clang -Wall main.c -o main \u0026amp;\u0026amp; ./main sizeof(struct UserID) = 24 24字节. 这只是一个结构体, 所以我们可以自己计算出来:\nint main() { printf(\u0026#34;sizeof(struct UserID) = %ld\\n\u0026#34;, sizeof(struct UserID)); printf(\u0026#34;%ld + %ld + %ld = %ld\\n\u0026#34;, sizeof(enum UserIDKind), sizeof(uint64_t), sizeof(char *), sizeof(enum UserIDKind) + sizeof(uint64_t) + sizeof(char *) ); } $ clang -Wall main.c -o main \u0026amp;\u0026amp; ./main sizeof(struct UserID) = 24 4 + 8 + 8 = 20 Oh, woops. 我们哪里做错了?\n淡定, 这是因为在 kind 和 number 之间有 padding, 以使我们的属性是64位对齐的(后面会详细说明).\n这就是为什么我们的 UserID 结构体是3*8=24个字节.\n当前, 我们可以命令编译器不要做对齐, 然后在计算一次:\nstruct __attribute__((packed)) UserID { enum UserIDKind kind; uint64_t number; char *text; }; $ clang -Wall main.c -o main \u0026amp;\u0026amp; ./main sizeof(struct UserID) = 20 4 + 8 + 8 = 20 现在让我们看看 Rust 中 UserID 枚举的大小:\nuse std::mem::size_of; #[allow(dead_code)] enum UserID { Number(u64), Text(String), } fn main() { dbg!(size_of::\u0026lt;UserID\u0026gt;()); } $ cargo run -q [src/main.rs:10] size_of::\u0026lt;UserID\u0026gt;() = 32 Oh, uh, 这太大了. 太大了. 我不认为 Rust 的 String 类型只是一个单纯的指向空字符结尾的指针(c-style). 我认为 it\u0026rsquo;s a little more involved.\nuse std::{mem::size_of, os::raw::c_char}; #[allow(dead_code)] enum UserID { Number(u64), Text(*const c_char), } fn main() { dbg!(size_of::\u0026lt;UserID\u0026gt;()); } $ cargo run -q [src/main.rs:10] size_of::\u0026lt;UserID\u0026gt;() = 16 Ok, 这看起来合理多了. 并且比 C 版本要小很多. 这里是为什么呢?\n首先, 这里必须有一个等同于上面写的 C 语言的 kind 一样作用的东西. 在 Rust 中, 它叫做 discriminant(判别符). 这是一个 \u0026ldquo;tagged unions\u0026rdquo; 中的 \u0026ldquo;tag\u0026rdquo;.\n欢迎来到计算机世界, 这里每个东西都有至少三个名字.\n\u0026hellip;\u0026hellip;我猜它应该是通过重叠 *const c_char 和 u64 来节省空间, 因为它们只能有一个是有效的, 不能同时存在: 这也是为什么称他们为 \u0026ldquo;disjoint union\u0026rdquo;.\n所以总共只有16个字节.\n我们能做相同的事情在 C 里面吗? 这当然可以! union 关键字就是起着类似作用的. 这就像是一个结构体, 只是所有内容的内存地址是重叠的, 它的大小是它内部最大的那一个 (或多或少依然是需要考虑对齐的).\nstruct UserID { enum UserIDKind kind; union { uint64_t number; char *text; }; }; int main() { printf(\u0026#34;sizeof(struct UserID) = %ld\\n\u0026#34;, sizeof(struct UserID)); } $ clang -Wall main.c -o main \u0026amp;\u0026amp; ./main sizeof(struct UserID) = 16 我们得到了与 Rust 相同的结果.\n进一步的, 我们可以把 UserIDKind 改成一个 uint8_t(在64位计算机, clang 10作为编译器的情况下它是4个字节):\nstruct UserID { uint8_t kind; union { uint64_t number; char *text; }; }; $ clang -Wall main.c -o main \u0026amp;\u0026amp; ./main sizeof(struct UserID) = 16; Mhhhh好像没发生什么变化\u0026hellip;\n像膨化食品包装一样 - 可能大部分都是填充物.\n对的, 让我们再次 packing 我们的结构体:\nstruct __attribute__((packed)) UserID { uint8_t kind; union { uint64_t number; char *text; }; }; $ clang -Wall main.c -o main \u0026amp;\u0026amp; ./main sizeof(struct UserID) = 9 只有9个字节了! 现在它压缩了.\n我们可以在 Rust 中做类似的事情吗? Rust 默认是以属性做适应性对齐的, 如果我们有一个 u8 and u64:\nstruct Foo { bar: u8, baz: u64, } fn main() { dbg!(size_of::\u0026lt;Foo\u0026gt;()); } \u0026hellip;它增长到了16个字节\n$ cargo run -q [src/main.rs:16] size_of::\u0026lt;Foo\u0026gt;() = 16 但是, 像 C 一样, 如果我们友好地要求, Rust 也可以 pack:\n#[repr(packed)] struct Foo { bar: u8, baz: u64, } $ cargo run -q [src/main.rs:17] size_of::\u0026lt;Foo\u0026gt;() = 9 但是如果在枚举上呢?\n#[repr(packed)] enum UserID { Number(u64), Text(*const c_char), } $ cargo run -q error[E0517]: attribute should be applied to struct or union --\u0026gt; src/main.rs:4:8 | 4 | #[repr(packed)] | ^^^^^^ 5 | / enum UserID { 6 | | Number(u64), 7 | | Text(*const c_char), 8 | | } | |_- not a struct or union 我们不能 pack. 这之前已经 讨论 过了, 也有 讨论其它奇异的枚举布局优化的方案, 但是现在, 还不能那么做.\n然而显然, smartstring 就是那么做的.\n当一个 SmartString 存在堆里的时候(这是一个 boxed 变体), 它是24字节, 就像 String 一样.\n但是如果我们尝试做一个我们自己的 smartstring, 使用 Rust 的枚举, 我们甚至无法接近它的大小:\nuse std::mem::size_of; #[allow(dead_code)] enum SmartString { Boxed(String), Inline([u8; 24]), } fn main() { dbg!(size_of::\u0026lt;String\u0026gt;()); dbg!(size_of::\u0026lt;[u8; 24]\u0026gt;()); dbg!(size_of::\u0026lt;SmartString\u0026gt;()); } $ cargo run -q [src/main.rs:10] size_of::\u0026lt;String\u0026gt;() = 24 [src/main.rs:11] size_of::\u0026lt;[u8; 24]\u0026gt;() = 24 [src/main.rs:12] size_of::\u0026lt;SmartString\u0026gt;() = 32 这里有件事是我们可以做的, 既然 Rust 不允许我们打包它的枚举, 那我们就做一个自己的枚举.\n写一个自己的枚举 首先, 我们不能使用 Rust unions, 因为它只支持 Copy 和非 Drop 类型.\nuse std::mem::size_of; #[allow(dead_code)] #[repr(packed)] struct SmartString { discriminant: u8, data: [u8; 24], } fn main() { dbg!(size_of::\u0026lt;SmartString\u0026gt;()); } $ cargo run -q [src/main.rs:11] size_of::\u0026lt;SmartString\u0026gt;() = 25 看! 25个字节. 这是我们目前最好的预想了.\n但是实际上还没做任何事 - 我们只是存了25个字节在结构体里.\n我们需要想出一个方法来保存我们的变体:\nboxed: a String inline: some utf-8 bytes, and I guess a length? 在 \u0026ldquo;inline\u0026rdquo; 变体时我们不能存大于24个字节的内容, 所以我们可以使用一个 u8 来表示长度, 实际像下面所示:\nstruct Inline { len: u8, data: [u8; 23], } 然后, 为了确保我们这几个类型实际上有着相同的大小, 我们使用 static_assertions crate:\nuse static_assertions::*; use std::mem::size_of; #[allow(dead_code)] #[repr(packed)] struct SmartString { discriminant: u8, data: [u8; 24], } #[allow(dead_code)] struct Inline { len: u8, data: [u8; 23], } assert_eq_size!(String, Inline); fn main() { dbg!(size_of::\u0026lt;SmartString\u0026gt;()); } $ cargo check Finished dev [unoptimized + debuginfo] target(s) in 0.00s Good, 要确保足够傻瓜, 因为我们将要写很多 unsafe 代码, 我们甚至能按照 String 的大小来定义我们的 Inline, 这个 \u0026ldquo;crate\u0026rdquo; 就可以帮忙检查我们的 Inline 和 String 大小相同.\nuse static_assertions::*; use std::mem::size_of; const VARIANT_SIZE: usize = std::mem::size_of::\u0026lt;String\u0026gt;(); #[allow(dead_code)] #[repr(packed)] struct SmartString { discriminant: u8, data: [u8; VARIANT_SIZE], } #[allow(dead_code)] struct Inline { len: u8, data: [u8; VARIANT_SIZE - 1], } assert_eq_size!(String, Inline); fn main() { dbg!(size_of::\u0026lt;SmartString\u0026gt;()); } Okay, 现在让我们实现我们的手动枚举. 首先让它能够被构建.\n我们仅使用了 [u8; VARIANT_SIZE] 来保留 VARIANT_SIZE 字节 - 如果我们真的想要往里面存一点东西, 我们将会用一个 *mut 指针指向它, 然后把它转型为我们所需要的:\nimpl SmartString { pub fn new_boxed(s: String) -\u0026gt; Self { Self::new(0, s) } pub fn new_inline() -\u0026gt; Self { Self::new( 1, Inline { len: 0, data: Default::default(), }, ) } fn new\u0026lt;T\u0026gt;(discriminant: u8, data: T) -\u0026gt; Self { let mut res = Self { discriminant, data: Default::default(), }; let ptr: *mut T = res.data.as_mut_ptr().cast(); unsafe { ptr.write_unaligned(data) }; res } } 我们现在可以在我们的 SmartString 构建这两种变体:\nfn main() { let boxed = SmartString::new_boxed(\u0026#34;This is a longer string, would not fit inline\u0026#34;.into()); let inline = SmartString::new_inline(); } 除此之外我们目前也不能对它做其它事情了.\n让我们把它变得有用点, 例如, 从它获取一个 \u0026amp;str 切片:\nimpl AsRef\u0026lt;str\u0026gt; for SmartString { fn as_ref(\u0026amp;self) -\u0026gt; \u0026amp;str { match self.discriminant { 0 =\u0026gt; { let s: *const ManuallyDrop\u0026lt;String\u0026gt; = self.data.as_ptr().cast(); let tmp = unsafe { s.read_unaligned() }; unsafe { \u0026amp;*(tmp.as_ref() as *const str) } } 1 =\u0026gt; { let s: *const Inline = self.data.as_ptr().cast(); unsafe { let slice = std::slice::from_raw_parts((*s).data.as_ptr(), (*s).len as _); std::str::from_utf8_unchecked(slice) } } _ =\u0026gt; unreachable!(), } } } 还记得我之前说过的我们应该如何努力审查不安全代码以确保不会违反不变体, 在这里就比较适用. 我们使用了更安全的变体, unreachable, 但是如果我想冒险的话, 我会考虑使用 unreachable_unchecked.\n译者: 审查指: 在这里我们把 discriminant 当作一个枚举或者说不变体 match 了, 因为它的值只有可能是0或者1以表示内容是 inline or boxed, 但是可能会有前文像 C 那样在开发过程中传递了非法的值而导致错误, 所以使用 unreachable! 宏来确保不会有这种情况出现, 在编译期就可以友好地提示开发者, 以使代码更加安全.\n现在我们有了一个 AsRef 实现, 我们可以打印出它的实际内容了 - 而不需要在意实际上它的变体是什么(Inline or Boxoed).\n方便起见, 我们实现 Display 和 Debug:\nuse std::fmt; impl fmt::Display for SmartString { fn fmt(\u0026amp;self, f: \u0026amp;mut fmt::Formatter\u0026lt;\u0026#39;_\u0026gt;) -\u0026gt; fmt::Result { let s: \u0026amp;str = self.as_ref(); fmt::Display::fmt(s, f) } } impl fmt::Debug for SmartString { fn fmt(\u0026amp;self, f: \u0026amp;mut fmt::Formatter\u0026lt;\u0026#39;_\u0026gt;) -\u0026gt; fmt::Result { let s: \u0026amp;str = self.as_ref(); fmt::Debug::fmt(s, f) } } fn main() { let boxed = SmartString::new_boxed(\u0026#34;This is a longer string, would not fit inline\u0026#34;.into()); let inline = SmartString::new_inline(); dbg!(boxed, inline); } $ cargo run -q [src/main.rs:84] boxed = \u0026#34;This is a longer string, would not fit inline\u0026#34; [src/main.rs:84] inline = \u0026#34;\u0026#34; 我们还有很多事情没做 - 我们不能改变我们的 SmartString, 但是 smartstring 是允许的. 我们也不能降级我们的 boxed 为 inline, 我们也不能把 inline 提升为 boxed 以防它存太多东西了.\n虽然, 但目前有更紧迫的事情要做.\n请允许我缓缓道来.\nfn main() { let s: String = \u0026#34;this is just some text\u0026#34;.into(); dbg!(s); } $ cargo build --quiet --release \u0026amp;\u0026amp; valgrind --tool=memcheck ./target/release/enumpeek ==173592== Memcheck, a memory error detector ==173592== Copyright (C) 2002-2017, and GNU GPL\\\u0026#39;d, by Julian Seward et al. ==173592== Using Valgrind-3.16.1 and LibVEX; rerun with -h for copyright info ==173592== Command: ./target/release/enumpeek ==173592== [src/main.rs:82] s = \u0026#34;this is just some text\u0026#34; ==173592== ==173592== HEAP SUMMARY: ==173592== in use at exit: 0 bytes in 0 blocks ==173592== total heap usage: 15 allocs, 15 frees, 2,335 bytes allocated ==173592== ==173592== All heap blocks were freed -- no leaks are possible ==173592== ==173592== For lists of detected and suppressed errors, rerun with: -s ==173592== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) fn main() { let s: SmartString = SmartString::new_boxed(\u0026#34;this is just some text\u0026#34;.into()); dbg!(s); } $ cargo build --quiet --release \u0026amp;\u0026amp; valgrind --tool=memcheck ./target/release/enumpeek ==173779== Memcheck, a memory error detector ==173779== Copyright (C) 2002-2017, and GNU GPL\\\u0026#39;d, by Julian Seward et al. ==173779== Using Valgrind-3.16.1 and LibVEX; rerun with -h for copyright info ==173779== Command: ./target/release/enumpeek ==173779== [src/main.rs:82] s = \u0026#34;this is just some text\u0026#34; ==173779== ==173779== HEAP SUMMARY: ==173779== in use at exit: 22 bytes in 1 blocks ==173779== total heap usage: 15 allocs, 14 frees, 2,335 bytes allocated ==173779== ==173779== LEAK SUMMARY: ==173779== definitely lost: 22 bytes in 1 blocks ==173779== indirectly lost: 0 bytes in 0 blocks ==173779== possibly lost: 0 bytes in 0 blocks ==173779== still reachable: 0 bytes in 0 blocks ==173779== suppressed: 0 bytes in 0 blocks ==173779== Rerun with --leak-check=full to see details of leaked memory ==173779== ==173779== For lists of detected and suppressed errors, rerun with: -s ==173779== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) 我们发生了内存泄漏!\nString 只是一个单纯的结构体, 但它在堆中有自己的内存分配. 在我们的 SmartString::new_boxed 中, 我们拿了 String 的所有权, 并且它有着在堆中相关联的内存我们不曾释放.\n编译器不知道释放我们保存在 SmartString 以 boxed 形式存放的 String, 因为它不知道我们拿的是什么类型 - 它只知道我们用了24个字节, 这24个字节可能放着任何东西.\n如果我们知道这个类型, 事实上确实, 只是个 String, 并且它们需要被 dropped, 我们需要告诉编译器.\n下面是我们做 Drop 的第一次痛苦经历:\nimpl Drop for SmartString { fn drop(\u0026amp;mut self) { match self.discriminant { 0 =\u0026gt; { let s: *mut String = self.data.as_mut_ptr().cast(); let b: String = unsafe { *s }; drop(b); } 1 =\u0026gt; { // etc. } _ =\u0026gt; unreachable!(), } } } $ cargo run -q error[E0507]: cannot move out of `*s` which is behind a raw pointer --\u0026gt; src/main.rs:46:42 | 46 | let b: String = unsafe { *s }; | ^^ | | | move occurs because `*s` has type `std::string::String`, which does not implement the `Copy` trait | help: consider borrowing here: `\u0026amp;*s` Woops, 这不能工作, 我们不能从一个 raw pointer move 因为 String 不是 Copy.\n我们能做些什么? 我们能把它 Box 起来么, Box 有一个 from_raw 方法, 这听起来不错:\nimpl Drop for SmartString { fn drop(\u0026amp;mut self) { match self.discriminant { 0 =\u0026gt; { let s: *mut String = self.data.as_mut_ptr().cast(); let b = unsafe { Box::from_raw(s) }; drop(b); } 1 =\u0026gt; { // etc. } _ =\u0026gt; unreachable!(), } } } $ cargo run -q [src/main.rs:117] s = \u0026#34;this is just some text\u0026#34; free(): invalid pointer [1] 179297 abort (core dumped) cargo run -q Uh, oh.\nWow, 你没有撒谎, 不安全代码确实很棘手.\n让我们用我们友好的 Valgrind 检查一下:\n$ cargo build --quiet --release \u0026amp;\u0026amp; valgrind --tool=memcheck ./target/release/enumpeek ==179648== Memcheck, a memory error detector ==179648== Copyright (C) 2002-2017, and GNU GPL\u0026#39;d, by Julian Seward et al. ==179648== Using Valgrind-3.16.1 and LibVEX; rerun with -h for copyright info ==179648== Command: ./target/release/enumpeek ==179648== [src/main.rs:117] s = \u0026#34;this is just some text\u0026#34; ==179648== Invalid free() / delete / delete[] / realloc() ==179648== at 0x483B9AB: free (vg_replace_malloc.c:538) ==179648== by 0x10D501: enumpeek::main (in /home/amos/ftl/enumpeek/target/release/enumpeek) ==179648== by 0x10D8E2: std::rt::lang_start::{{closure}} (in /home/amos/ftl/enumpeek/target/release/enumpeek) ==179648== by 0x1163F7: {{closure}} (rt.rs:52) ==179648== by 0x1163F7: do_call\u0026lt;closure-0,i32\u0026gt; (panicking.rs:297) ==179648== by 0x1163F7: try\u0026lt;i32,closure-0\u0026gt; (panicking.rs:274) ==179648== by 0x1163F7: catch_unwind\u0026lt;closure-0,i32\u0026gt; (panic.rs:394) ==179648== by 0x1163F7: std::rt::lang_start_internal (rt.rs:51) ==179648== by 0x10D561: main (in /home/amos/ftl/enumpeek/target/release/enumpeek) ==179648== Address 0x1ffefff561 is on thread 1\u0026#39;s stack ==179648== in frame #1, created by enumpeek::main (???:) ==179648== ==179648== ==179648== HEAP SUMMARY: ==179648== in use at exit: 0 bytes in 0 blocks ==179648== total heap usage: 15 allocs, 16 frees, 2,335 bytes allocated ==179648== ==179648== All heap blocks were freed -- no leaks are possible ==179648== ==179648== For lists of detected and suppressed errors, rerun with: -s ==179648== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) 问题看起来像是它在试图释放 String 就像它分配在堆上一样, 然而并没有! 实际上是 String 中的数据分配在堆上, 而不是 String 本身.\n这里有一个看起来生效的方法:\nimpl Drop for SmartString { fn drop(\u0026amp;mut self) { match self.discriminant { 0 =\u0026gt; { let s: *mut String = self.data.as_mut_ptr().cast(); let s: String = unsafe { std::ptr::read_unaligned(s) }; drop(s); } 1 =\u0026gt; { // etc. } _ =\u0026gt; unreachable!(), } } } 我们可以更进一步:\n使用泛型函数来减少重复代码. 省略掉 drop, 在 std::ptr::read_unaligned 离开作用域后自动调用. impl SmartString { fn drop_variant\u0026lt;T\u0026gt;(\u0026amp;self) { unsafe { std::ptr::read_unaligned(self.data.as_ptr().cast::\u0026lt;T\u0026gt;()) }; } } impl Drop for SmartString { fn drop(\u0026amp;mut self) { match self.discriminant { 0 =\u0026gt; unsafe { self.drop_variant::\u0026lt;String\u0026gt;() }, 1 =\u0026gt; unsafe { self.drop_variant::\u0026lt;Inline\u0026gt;() }, _ =\u0026gt; unreachable!(), } } } $ cargo build --quiet --release \u0026amp;\u0026amp; valgrind --tool=memcheck ./target/release/enumpeek ==181085== Memcheck, a memory error detector ==181085== Copyright (C) 2002-2017, and GNU GPL\\\u0026#39;d, by Julian Seward et al. ==181085== Using Valgrind-3.16.1 and LibVEX; rerun with -h for copyright info ==181085== Command: ./target/release/enumpeek ==181085== [src/main.rs:99] s = \u0026#34;this is just some text\u0026#34; ==181085== ==181085== HEAP SUMMARY: ==181085== in use at exit: 0 bytes in 0 blocks ==181085== total heap usage: 15 allocs, 15 frees, 2,335 bytes allocated ==181085== ==181085== All heap blocks were freed -- no leaks are possible ==181085== ==181085== For lists of detected and suppressed errors, rerun with: -s ==181085== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) 完美, 但是这完全正确了吗? 我不知道, 在让一堆人测试看看之前我是不会把代码用到生产环境中的. 但是至少在我们的 case 中, 它已经没有发生内存泄漏了.\n这总归是好的.\n我们可以在我们的结构体中花上整天时间都在这重新实现 smartstring 里面的功能, 但是有个点需要记住, 我们的版本比 smartstring 大了足足一个字节.\n就像 smallvec::SmallVec 类型比 Vec 大一样.\n$ cargo add smallvec Adding smallvec v1.4.2 to dependencies use std::mem::size_of; use smallvec::SmallVec; fn main() { dbg!(size_of::\u0026lt;Vec\u0026lt;u8\u0026gt;\u0026gt;(), size_of::\u0026lt;SmallVec\u0026lt;[u8; 1]\u0026gt;\u0026gt;()); } $ cargo run -q [src/main.rs:100] size_of::\u0026lt;Vec\u0026lt;u8\u0026gt;\u0026gt;() = 24 [src/main.rs:100] size_of::\u0026lt;SmallVec\u0026lt;[u8; 1]\u0026gt;\u0026gt;() = 32 因此, 希望到目前为止本文讲述的足足44分钟的时间里你已经 完全 明白了为什么这是一个有趣的问题(请回忆下开篇所提到的问题).\n它的神秘不在于 SmallVec\u0026lt;[u8; 1]\u0026gt; 比 Vec\u0026lt;u8\u0026gt; 大8个字节, 因为 SmallVec 只是一个枚举, 它的判定式只需要考虑两个变体, 但是因为 Rust 需要额外的空间来保证对齐, 所以多用了整整8个字节.\n它的神秘在于, SmartString 是怎么做到只有24个字节的.\n为了回答这个问题, 我们需要更深入的观察指针.\n仔细看看指针 So, 什么是指针? 只是一串数字? 它告诉了你有些东西在内存的哪个地方.\n举个例子, 如果我们声明了一个本地变量 x, i32, 它可能直立在栈上:\nfn main() { // this is a signed 32-bit integer let x = 30; // this is a reference to a signed 32-bit integer let x_ref = \u0026amp;x; // this is a pointer to a signed 32-bit integer let x_ptr = x_ref as *const _; dbg!(x_ptr); } $ cargo run -q [src/main.rs:105] x_ptr = 0x00007fff10be39ec 当然, 一个本地变量也可能在寄存器中. 但这在这里无关紧要. 一旦我们获取了某个对象的地址, 它就需要映射到虚拟内存地址空间的某个地方, 而在寄存器中的则不需要, 为了方便解释, 我们现在假装寄存器不存在.\n是啊, 让我们忽略掉现代电脑中最快的存储空间, 不错.\nLook cool bear, 你还想看完文章吗?\nyawn no no, 继续吧.\nSo, 数字是为了告诉你某些东西在内存中的位置. 这就像是地址, 就跟国家有实际位置的地址一样, 只是多了些间接性.\n一个对齐的指针是一个其值(地址)是数据大小的倍数的指针. 当数据是自然对齐的时候对 CPUs 来说很方便.\n让我们看一些例子.\n我们可以在内存中寻址的的最小单元是字节. 一个指向字节的指针总是对齐的, 因为指针用字节来计数, 换句话说, 一个 u8 的对齐单位就是1.\nfn main() { let arr = [1u8, 2u8, 3u8, 4u8]; dbg!( \u0026amp;arr[0] as *const _, \u0026amp;arr[1] as *const _, \u0026amp;arr[2] as *const _, \u0026amp;arr[3] as *const _, ); } $ cargo run -q [src/main.rs:106] \u0026amp;arr[0] as *const _ = 0x00007ffd6474abdc [src/main.rs:106] \u0026amp;arr[1] as *const _ = 0x00007ffd6474abdd [src/main.rs:106] \u0026amp;arr[2] as *const _ = 0x00007ffd6474abde [src/main.rs:106] \u0026amp;arr[3] as *const _ = 0x00007ffd6474abdf 如果讨论的是指向 u16 的指针, 那么它的对齐单位是2.\nfn main() { let arr = [1u16, 2u16, 3u16, 4u16]; fn inspect\u0026lt;T\u0026gt;(t: *const T) -\u0026gt; (*const T, bool) { (t, t as usize % 2 == 0) } dbg!( inspect(\u0026amp;arr[0] as *const _), inspect(\u0026amp;arr[1] as *const _), inspect(\u0026amp;arr[2] as *const _), inspect(\u0026amp;arr[3] as *const _), ); } $ cargo run -q [src/main.rs:110] inspect(\u0026amp;arr[0] as *const _) = ( 0x00007ffd81bf5918, true, ) [src/main.rs:110] inspect(\u0026amp;arr[1] as *const _) = ( 0x00007ffd81bf591a, true, ) [src/main.rs:110] inspect(\u0026amp;arr[2] as *const _) = ( 0x00007ffd81bf591c, true, ) [src/main.rs:110] inspect(\u0026amp;arr[3] as *const _) = ( 0x00007ffd81bf591e, true, ) 同理, 对于 u32 是4, u64 是8.\n下面有一个正确对齐的例子:\n底部的小方块表示如果我们想要存该类型, 可以把它放在那里.\n顶部部分表示实际的内存布局, 举个例子, 一个结构体:\n#include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stddef.h\u0026gt; struct S { uint8_t a; uint8_t b; uint16_t c; uint32_t d; }; int main() { printf(\u0026#34;sizeof(S) = %ld\\n\u0026#34;, sizeof(struct S)); printf(\u0026#34;offsetof(struct S, a) = %zu\\n\u0026#34;, offsetof(struct S, a)); printf(\u0026#34;offsetof(struct S, b) = %zu\\n\u0026#34;, offsetof(struct S, b)); printf(\u0026#34;offsetof(struct S, c) = %zu\\n\u0026#34;, offsetof(struct S, c)); printf(\u0026#34;offsetof(struct S, d) = %zu\\n\u0026#34;, offsetof(struct S, d)); } $ clang -Wall main.c -o main \u0026amp;\u0026amp; ./main sizeof(S) = 8 offsetof(struct S, a) = 0 offsetof(struct S, b) = 1 offsetof(struct S, c) = 2 offsetof(struct S, d) = 4 在这里, 一切顺利.\n我们用另一个布局代替看看:\nstruct S { uint8_t a; uint16_t b; uint8_t c; uint32_t d; }; $ clang -Wall main.c -o main \u0026amp;\u0026amp; ./main sizeof(S) = 12 offsetof(struct S, a) = 0 offsetof(struct S, b) = 2 offsetof(struct S, c) = 4 offsetof(struct S, d) = 8 为了维持对齐, 编译器插入了废料:\n\u0026ldquo;Padding\u0026rdquo; 不绝对是置零 - 它只是没有使用的空间. 即使它初始化置零了, 也不能保证它会在你分配成员的时候维持0.\n经常使用该结构体可能会混淆值和填充的 padding, 因此一个好的 old block memory comparison (memcmp) 不能够测试两个结构体是否完全相等.\n原文: Regular usage of the struct might mess with the values in the padding, and so a good old block memory comparison (memcmp) would not be enough to test two structs for equality.\n译者: 这里没懂作者想说什么, 有人清楚的话可以提个issue给我.\n我们在 Rust 中定义一个相同布局的结构体会发生什么?\nfn main() { struct S { a: u8, b: u16, c: u8, d: u32, } dbg!(std::mem::size_of::\u0026lt;S\u0026gt;()); } $ cargo run -q [src/main.rs:112] std::mem::size_of::\u0026lt;S\u0026gt;() = 8 为什么只有8个字节? 发生了什么? 让我们来借助工具看看它的布局:\n$ cargo add memoffset Adding memoffset v0.5.5 to dependencies fn main() { struct S { a: u8, b: u16, c: u8, d: u32, } use memoffset::offset_of; dbg!( std::mem::size_of::\u0026lt;S\u0026gt;(), offset_of!(S, a), offset_of!(S, b), offset_of!(S, c), offset_of!(S, d) ); } $ cargo run -q [src/main.rs:113] std::mem::size_of::\u0026lt;S\u0026gt;() = 8 [src/main.rs:113] offset_of!(S, a) = 6 [src/main.rs:113] offset_of!(S, b) = 4 [src/main.rs:113] offset_of!(S, c) = 7 [src/main.rs:113] offset_of!(S, d) = 0 我们的成员被重新排序了!\n我们可以让 Rust compiler 不要重排序就像 C 一样通过 repr(C):\nfn main() { #[repr(C)] struct S { a: u8, b: u16, c: u8, d: u32, } use memoffset::offset_of; dbg!( std::mem::size_of::\u0026lt;S\u0026gt;(), offset_of!(S, a), offset_of!(S, b), offset_of!(S, c), offset_of!(S, d) ); } cargo run -q [src/main.rs:11] std::mem::size_of::\u0026lt;S\u0026gt;() = 12 [src/main.rs:11] offset_of!(S, a) = 0 [src/main.rs:11] offset_of!(S, b) = 2 [src/main.rs:11] offset_of!(S, c) = 4 [src/main.rs:11] offset_of!(S, d) = 8 现在我们有了和 C 一样的布局了, 也有着相同的填充.\n或者也可以让编译器既不要重新排序也不要填充以完全忽略对齐:\nfn main() { #[repr(C, packed)] struct S { a: u8, b: u16, c: u8, d: u32, } use memoffset::offset_of; dbg!( std::mem::size_of::\u0026lt;S\u0026gt;(), offset_of!(S, a), offset_of!(S, b), offset_of!(S, c), offset_of!(S, d) ); } 现在, S.b 不再很好地对齐了.\n$ cargo run -q [src/main.rs:11] std::mem::size_of::\u0026lt;S\u0026gt;() = 8 [src/main.rs:11] offset_of!(S, a) = 0 [src/main.rs:11] offset_of!(S, b) = 1 [src/main.rs:11] offset_of!(S, c) = 3 [src/main.rs:11] offset_of!(S, d) = 4 假如我们尝试获取一个引用, Rust 会警告我们(当前只是 warn, 以后可能会变成一个 error):\nfn main() { #[repr(C, packed)] #[derive(Default)] struct S { a: u8, b: u16, c: u8, d: u32, } let s: S = Default::default(); dbg!(\u0026amp;s.b); } $ cargo run -q warning: borrow of packed field is unsafe and requires unsafe function or block (error E0133) --\u0026gt; src/main.rs:12:10 | 12 | dbg!(\u0026amp;s.b); | ^^^^ | = note: `#[warn(safe_packed_borrows)]` on by default = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release! = note: for more information, see issue #46043 \u0026lt;https://github.com/rust-lang/rust/issues/46043\u0026gt; = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior warning: 1 warning emitted [src/main.rs:12] \u0026amp;s.b = 0 迄今\u0026hellip; 所有的事情在我 2018 i7 处理器上工作得很好.\n我们可以改变它也没有任何问题:\nfn main() { #[repr(C, packed)] #[derive(Default)] struct S { a: u8, b: u16, c: u8, d: u32, } let mut s: S = Default::default(); unsafe { s.b = 0x123; println!(\u0026#34;{:#x}\u0026#34;, s.b); } } $ cargo run -q 0x123 这并不是获得未对齐指针的唯一方法, 使用指针类型转换我们也可以把两个 u8 当作一个单独的未对齐的 u16.\nfn main() { let mut arr = [1u8, 2u8, 3u8]; let ptr_u16 = (\u0026amp;mut arr[1]) as *mut _ as *mut u16; unsafe { *ptr_u16 = 0x123; println!(\u0026#34;{:#x}\u0026#34;, *ptr_u16); } } 注意, clippy 会捕获到这个, 并且认为这是一个错误.\n$ cargo clippy Checking enumpeek v0.1.0 (/home/amos/ftl/enumpeek) error: casting from `*mut u8` to a more-strictly-aligned pointer (`*mut u16`) (1 \u0026lt; 2 bytes) --\u0026gt; src/main.rs:3:19 | 3 | let ptr_u16 = (\u0026amp;mut arr[1]) as *mut _ as *mut u16; | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ | = note: `#[deny(clippy::cast_ptr_alignment)]` on by default = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#cast_ptr_alignment 不过这在我的电脑上依旧是可以运行的:\n$ cargo run -q 0x123 所以为什么我们要再次关注对齐呢?\n好吧, 这是一个很长的故事\u0026hellip;\n我们想要什么? 对齐! 我们为什么要它? Well\u0026hellip; 回到 C 发明的年代, 那个时候有些处理器不怎么支持没有对齐过的内存访问.\n对于这些处理器, 没有对齐的内存访问可能会导致抛出一个处理器错误: 异常处理器或许能够正常访问一个没有对齐的内存, 但是会浪费较多的性能, 或者是干脆没法访问未对齐的内存, 然后程序运行就被 abort 了.\n在另一些处理器架构里, 像是英特尔的 \u0026ldquo;Core 2\u0026rdquo; 系列, 通常会用一些性能损耗来支持未对齐的内存.\n我本来想在这里放上一些 microbenchmarks, 但是它们有时候会互相矛盾 - 基准测试有很多影响因素. 有些基准测试显示有 10% 的性能降低, 有些会降低 50%, 显然有很多会影响到关于访问未对齐内存的性能测试.\n但是请记住, 即使处理器开始对未对齐内存做了一级支持, 但是出于性能原因仍然要避免使用未对齐内存.\n我通常把最好的东西留到最后说 但是:\n一些架构可能不会抛出处理器异常, 而是静默地执行一些不同的读操作.\n等等, 它会执行不同的读操作?\n是的.\n听起来很恐怖, 真的会发生吗? 你可以证实它吗?\n我会的.\n很久很久, 在ARMv5以前\u0026hellip; 我们已经在这篇文章里读了一些关于未对齐内存的内容.\n所以展示上面所说的不同的读操作会相对比较容易.\n首先你需要一些数据 - 我们只用了 8 个不同的字节值, 这很容易理解后面将会发生什么.\nuint8_t arr[8] = { 0xef, 0xcd, 0xab, 0x89, 0x67, 0x45, 0x23, 0x01 }; 然后我们去读一个没有对齐的地址. 举个例子, 我们尝试从数组的第二个元素开始读取一个 uint32_t.\n#include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { uint8_t arr[8] = {0xef, 0xcd, 0xab, 0x89, 0x67, 0x45, 0x23, 0x01}; // arrays are zero-indexed, so `1` is the second item uint32_t *ptr = (uint32_t *)(\u0026amp;arr[1]); printf(\u0026#34;0x%08x\\n\u0026#34;, *ptr); return 0; } 猜猜会打印什么? 是 0xcdab8967? 错了!\n我2018年的i7处理器是一个小端处理器:\n$ lscpu | grep -E \u0026#39;(Byte Order|Model name)\u0026#39; Byte Order: Little Endian Model name: Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz 这意味着字节是从最低有效值存储到最高有效值.\n所以与其说是这样子的:\n其实是这样子的:\n$ gcc -Wall main.c -o main \u0026amp;\u0026amp; ./main 0x6789abcd 这就是为什么我为我的数组选了这些好辨识的值的原因.\n好吧, 我仍然无法相信你 - 因为这些没有对齐的数据看起来工作的很好.\nYes, yes. 但是如果你在GBA上跑这些数据?\nThe Game Boy Advance has a 16.8 MHz 32-bit ARM7TDMI processor - which implements the ARMv4T micro-architecture?\n行行行, 那这意味着什么呢?\n它意味着我们回到了2001.\n行, 我很好奇 - 我们怎么在2020年给GBA编译?\nIt's simple! Just install devKitPro on your OS of choice, and, uh, read a bit lot of documentation, and you're good to go!\n| devKitPro\n我以前是不是看你尝试过一个AS-1100虚拟机？ 然后是SH4?\nYeah well, hindsight is 20/20(大概是事后诸葛亮的意思). Do you want to see something cool or not?\n继续吧继续吧!\n我以前也没读过关于GBA开发的相关文档, 我只是找了个项目VisualBoyAdvance:\n这个项目的 C 代码看起来如下:\n// (cut) // clear screen iprintf(\u0026#34;\\x1b[2J\u0026#34;); // print at coordinates 10,10 iprintf(\u0026#34;\\x1b[10;10H\u0026#34;); iprintf(\u0026#34;Hello World!\u0026#34;); // (cut) So - 足够简单了!他有一些自己的 printf 实现 - 除此之外, 这就只是 C! 然后同样用 GCC 编译.\n所以让我们的代码跑起来并不是很难.\n以下是完整的代码 source/console.c:\n#include \u0026lt;gba_console.h\u0026gt; #include \u0026lt;gba_video.h\u0026gt; #include \u0026lt;gba_interrupt.h\u0026gt; #include \u0026lt;gba_systemcalls.h\u0026gt; int main(void) { irqInit(); irqEnable(IRQ_VBLANK); consoleDemoInit(); // clear screen iprintf(\u0026#34;\\x1b[2J\u0026#34;); // print at coordinates 10,10 iprintf(\u0026#34;\\x1b[10;10H\u0026#34;); uint8_t arr[8] = {0xef, 0xcd, 0xab, 0x89, 0x67, 0x45, 0x23, 0x01}; // arrays are zero-indexed, so `1` is the second item uint32_t *ptr = (uint32_t *)(\u0026amp;arr[1]); iprintf(\u0026#34;0x%08x\u0026#34;, *ptr); while (1) { VBlankIntrWait(); } } ","date":"2021-01-13T11:00:00+08:00","image":"/post/translation/rust/peeking_inside_a_rust_enum/cover_huf0a0302560a2de312014d03b723c5fe2_142416_120x120_fill_box_smart1_3.png","permalink":"/post/translation/rust/peeking_inside_a_rust_enum/","title":"深入Rust枚举"},{"content":" 本译文译自 Green Threads Explained in 200 Lines of Rust\n介绍 这本书目标是通过我们自己编写实现的一个简单可用的绿色线程代码, 来解释绿色线程.\n所有代码可以在该 Git仓库 找到, 它有两个分支, main 分支仅仅包括代码, commented 分支包含解释我们做了什么的注释.\n绿色线程, 用户态线程, 协程(goroutines), 纤程(fibers), 它们有多种称谓, 但是简单起见我将会在后续统一称之为绿色线程.\n在这篇文章中我将通过实现一个200行 Rust 绿色线程代码的简单例子来解释它是如何工作的.\n我们不会使用任何的外部库来确保我们真正的理解发生了什么.\n谁适合阅读这篇文章 我们深陷在一个兔子坑中, 如果它听起来很可怕, 那么这篇文章可能不适合你, 像曾经一样去做点轻松愉悦的事情吧~\n如果你还是很好奇事情是如何工作的, 那么继续读下去. 你可能听说过 Go 的 goroutines, 或者 Ruby 和 Julia 中等价的那些, 你可能知道它们怎么使用但是又想知道它们是如何工作的, 请继续读下去.\n另外, 如果你是以下这类人的话那也可能比较有趣:\n你是 Rust 初学者并且想学习更多的特性. 你已经在 Rust社区 中了解讨论过 async/await, Pin, 和为什么需要生成器. 我们将试着把那些都整合在这篇文章中. 或许你想了解 Rust 内联汇编的基础知识. 或许你只是单纯的感兴趣. Well, 现在加入我们并且试着了解我们需要了解的一切~\n你不需要是一个 Rust 程序员就可以理解本文, 但是我们强烈建议你首先能够知道一些简单的语法, 如果你想亲手尝试编写代码玩玩那么你可能需要获取 Rust 并且学习些基础知识.\n顺便 所有代码都在一个单文件中并且没有额外的依赖, 这意味着你可以简单的开始你的项目来自己亲自尝试, 你也可以在 Rust playground 中运行代码, 但是记住我们的代码是依赖于 nightly 的部分特性, 所以你需要先将编译器切换到 nightly 版本.\n绿色线程 绿色线程解决了编程中的一个通用问题. 你不希望你的代码阻塞 CPU 来阻止 CPU 去做一些有意义的工作. 我们通过多任务来解决这个问题, 这使得我们可以挂起运行中的一块代码去执行另一块代码, 并且在上下文之间切换.\n虽然很容易把它和并行混淆但是它们是两回事. 想象一下, 绿色线程让我们使用现有的资源更加聪明高效的工作, 而并行则是在问题上投入了更多的资源.\n通常有两种途径来做到这一点:\n抢占式多任务 非抢占式多任务 抢占式多任务 某些外部调度器会停止一个任务并在切换回来之前去执行另一个任务. 在这种情形下任务与之无关, 决策取决于其它的东西(通常是某些调度程序). 内核在操作系统中使用这种方式, 举例来说, 这允许你在单线程系统中使用 UI 的同时来让 CPU 去做一些计算. 我们现在不会在本文中讨论这种线程, 但是我想当你理解了一个范例, 你能够对这两个范例都有很好的掌握.\n非抢占式多任务 这是我们今天所要讲的. 一个任务自己去决定让 CPU 去做一些其他事情比起让它等待当前线程发生些什么. 通常通过 yielding/让出 控制权给调度器来完成的. 一般是在阻塞事情发生的时候让出执行权. 一个简单的例子是 IO操作. 当控制权让出后一个中心调度器指示 CPU 继续其它已经准备好的任务的工作而不是就在那里停滞着.\n背景知识 这部分是本书中最具有技术性的部分, 但是如果我们真的想要理解绿色线程的话就不得不去了解它们, 我保证我会尽可能快地说到点子上来让我们足以开始编写代码.\nHere we go! 首先, 我们将直接干预控制 CPU. 这并不是特别好移植的因为现实有很多种 CPU, 主要思路是一样的, 一些实现细节可能会有些许不同.\n我们在本文中会覆盖到的是使用地更加通用的架构: x86-64\n在这个架构中 CPU 的特点是有一组16个寄存器.\n如果你对图片的其余部分有兴趣的话你可以在 这里 找到它.\n我们感兴趣的是那些被标记为 callee saved 的寄存器.\n译者: callee-saved 又称作非易失性/被调用者保存寄存器, 当调用者进行过程调用时, 可以期望这些寄存器在被调用者返回后将保持相同的值, 这使被调用者有责任在返回调用者之前保存它们并恢复它们.\n这些寄存器用于记录我们的上下文: 下一个要运行的指令, 基指针, 栈指针\u0026hellip;\u0026hellip; 我们将会在后面了解更多的细节.\n如果我们想要直接指示 CPU 我们需要编写一小部分汇编代码, 幸运的是在我们的关卡中我们只需要了解一小部分汇编指令. 比如怎么S从寄存器中移动值:\nmov %rsp, %rax Windows 系有些不同的习惯. 在 Windows 系统上 XMM6:XMM15 也是 callee-saved 寄存器, 如果我们在函数中使用了它们也必须保存和恢复它们. 我们如果在例子中只用 psABI 的话, 那么代码在 Windows 上也能很好的运行.\n超级快的汇编介绍 首先并且也是最重要的, 汇编语言通常并不是很便携, 每个 CPU 都可能有自己特别的指令, 然而有些指令在当今的桌面电脑上是通用的.\nAT\u0026amp;T 方言是编写 Rust 内联汇编的标准语言, 但是如果我们想的话我们也可以在 Rust 中使用 Intel 方言. Rust 主要把内联汇编留给 LLVM 处理, LLVM 的内联汇编在语法上非常接近我们在 C 中编写的内联汇编. 这就可以让我们可以通过 C inline ASM 来学习(但并不完全相同).\n我们将会在我们的例子中使用 AT\u0026amp;T 方言.\n汇编有着非常强的向后兼容性保证. 这也是为什么你可能会看到用不同的方法来寻址相同的寄存器. 让我们看看 %rax 寄存器来解释我们之前所说的.\n%rax # 64 bit register (8 bytes) %eax # 32 low bits of the \u0026#34;rax\u0026#34; register %ax # 16 low bits of the \u0026#34;rax\u0026#34; register %ah # 8 high bits of the \u0026#34;ax\u0026#34; part of the \u0026#34;rax\u0026#34; register %al # 8 low bits of the \u0026#34;ax\u0026#34; part of the \u0026#34;rax\u0026#34; register 就像你看到的那样, 这就像是看到了 CPU 的发展历史~从8位到16位到32再到如今的64位. 因为现今大部分 CPU 都是64位的, 所以我们将在我们的代码中使用 64 位寄存器.\nword/字 的大小在汇编中有着历史原因, 它起源于 CPU 有16位数据总线的时候, 所以一个字是16位. 这与我们使用的 AT\u0026amp;T 方言是有关联性的, 因为我们后面将会使用一些以字作为后缀的命令, 比如: q/quad-word, l/long-word, 所以 movq 表示 4 * 16 = 64 bits.\nmov 使用的大小取决于你使用的寄存器, 这是标准 Intel 方言并且也是我们接下来在代码中使用的标准.\n我们将会在下一个章节中遨游更多的内联汇编的语法.\n一个小贴士: 栈对齐在 x86-64 架构上是16位. 请在之后记住这一点~\n一个建立于可编译基础上的例子 在这个例子中我们将创建自己的栈并且使我们的 CPU 从当前执行的上下文到我们刚刚创建的栈中. 我们将在接下来的文字中建立这些概念(但我们不会基于代码).\n设置我们的项目 首先我们需要创建一个项目在文件夹 \u0026ldquo;green_threads\u0026rdquo; 中, 运行:\ncargo init\n由于我们需要使用一些不稳定特性, 所以需要先切换到 Nightly 版编译器:\nrustup override set nightly\n在我们的 main.rs 中我们设置一个特性标签来让我们可以使用 llvm_asm! 宏:\n// main.rs: #![feature(llvm_asm)] 让我们在这里设置一个48字节的栈大小以让我们在切换上下文之前可以打印看看它:\n// main.rs: const SSIZE: isize = 48; 在 OSX 系统上使用这么小的栈可能会有些问题, 最小的可运行栈大小是624字节. 如果你想原模原样的照抄, 这些代码是可以在 Rust Playground 上运行的(但是由于我们后面编写的无限循环, 你可能需要等~30秒运行才能超时结束).\n接下来让我们写一个结构体来表示我们的 CPU 状态. 我们现在所需要关注的仅仅是保存栈指针的寄存器:\n// main.rs #[derive(Debug, Default)] #[repr(C)] struct ThreadContext { rsp: u64, } 在后面的例子中我将使用我上面链接文档中被标记为 callee saved 的所有寄存器. 那些是在 x86-64 ABI 中描述的寄存器, 我们需要使用它们来保存上下文, 但是现在我们只需要其中一个来让 CPU 跳转到我们的栈中.\n注意 #[repr(C)], 因为我们使用汇编的方式来访问我们的数据. Rust 没有一个稳定的 ABI 所以我们没有办法确保 rsp 在我们的内存中以前8个字节表示. C 有稳定的 ABI, 这个属性就是告诉编译器该结构体使用 C 的内存布局方式. 我们的结构体目前只有一个字段, 当然我们会在后面添加更多~\n// main.rs fn hello() -\u0026gt; ! { println!(\u0026#34;I LOVE WAKING UP ON A NEW STACK!\u0026#34;); loop{} } 在这个简单的示例中我们仅仅是定义了一个打印一段话的函数, 然后无限循环.\n下一步是我们用来切换到我们的栈的内联汇编.\nunsafe fn gt_switch(new: *const ThreadContext) { llvm_asm!(\u0026#34; mov 0x00($0), %rsp ret \u0026#34; : : \u0026#34;r\u0026#34;(new) : : \u0026#34;alignstack\u0026#34; // 不会在现在工作, 后面会用到. ); } 我们使用了一个小技巧. 我们在我们的新栈上写入我们想要运行的函数的地址, 然后我们把存储该地址第一个字节的地址传递给 rsp 寄存器(我们设置为 new.rsp 的地址将会指向我们栈的地址, 这个栈的地址指向上面的函数). 明白了吗?\nret 关键字将程序的控制权转给栈顶返回的地址. 因为我们把我们的地址 pushed 到 %rsp 寄存器中, CPU 将会认为这个地址是当前正在运行的函数返回的地址, 所以当我们使用 ret 指令时它将直接返回到我们自己的栈中(也就是new的地址).\n然后 CPU 做的第一件事就是读取我们函数的地址并运行它.\n译者: 关于汇编这里, 新版本的 Rust 使用的是 asm! 宏, 模板语法也有些变化, llvm_asm! 废弃了, 后续会更新为 asm! 宏的版本\u0026hellip;大概.\n快速介绍 Rust 的内联汇编宏 如果你以前没用过内联汇编你可能会觉得那些看上去像是火星文, 但是我们稍后会使用这个拓展版本来切换上下文, 所以现在我们将逐行解释我们做了什么.\nunsafe 是一个关键字, 它让 Rust 不能强制确保我们编写的函数的安全性. 因为我们直接操作 CPU, 这绝对是不安全的.\nfn gt_switch(new: *const ThreadContext) 在这里我们获取了一个指向 ThreadContext 实例的指针, 从中我们只读取了一个字段.\nllvm_asm!() 这是 Rust 标准库中的 llvm_asm! 宏. 它会检查我们的汇编语法, 如果遇到一些看起来不像是 AT\u0026amp;T 方言的语法, 它将提供一个错误信息.\n宏首先接收的参数是一个汇编模板:\nmov 0x00($0), %rsp 这是一个简单的指令, 它将存储在 $0 位置 的 0x00(16进制表示, 这里表示不偏移) 偏移量的值移动到 rsp 寄存器中. 因为 rsp 寄存器保存一个指向栈中下一个值的指针, 我们有效地将我们提供的地址 push 到当前的栈顶来覆盖原先存在的地址.\n你可能认为 $0 看起来不是一个普通的汇编代码. 这是汇编模板的部分, 表示第一个参数的占位符. 这个参数从0, 1, 2\u0026hellip;计数, 首先是 output 参数, 紧接着是 input 参数. 我们在这里只使用了对应于 $0 的输入参数.\n如果在汇编中碰到 $ 符号可能大部分时候表示一个立即数(常量整数)但是这是有依赖的(yeah, $ 在不同的方言或者是不同的架构如 x86 与 x86-64 之间都表示不同的意义).\n译者: 在 llvm_asm! 宏中, 使用 : 来分割参数, 所以第一个 : 后面的是输出参数(我们没有用到), 第二个为输入参数\u0026hellip;\nret ret 关键字命令 CPU 弹出栈顶的内存位置并且无条件地跳转到该位置. 实际上我们劫持了 CPU 让它返回到我们的栈中.\noutput : 内联 ASM 和普通的 ASM 有一点不同. 我们有四个额外的参数需要传递到汇编模板中. 第一个是输出参数, 我们在这里传递我们想要用作 Rust 函数返回值的参数.\n举个例子:\nfn add(a: i32, b: i32) -\u0026gt; i32 { let c: i32; unsafe { llvm_asm!(\u0026#34;add $2, $0\u0026#34; : \u0026#34;=r\u0026#34;(c) : \u0026#34;0\u0026#34;(a), \u0026#34;r\u0026#34;(b) ); } c } 这里的输出参数为 c, 最终结果会保存在变量 c 中.\ninput : \u0026#34;r\u0026#34;(new) 第二个表示我们的输入参数, 在内联汇编中 r 被称作约束. 你可以使用一些约束来有效地命令编译器能够决定将我们的输入放到哪里(在一个寄存器中作为值或者使用它作为一个内存地址). r 意味着它将被放置在由编译器选择的通用寄存器中. 内联汇编的约束是一个很大的主题, 幸运的是我们只需要简单的了解.\nclobber list : 下一个参数是 clobber 列表, 可以放置我们不想让编译器接触的寄存器, 并且让编译器知道我们想要在自己的汇编代码中管理那些寄存器. 如果我们弹出栈的任何值, 我们需要让编译器知道哪些寄存器它不能随便使用, 那么就需要在这里指定. 由于我们返回了一个全新的栈所以在这里不需要它.\noptions : \u0026#34;alignstack\u0026#34; 最后一个参数是 options. 这是 Rust 特有的, 有三个选项可以设置: \u0026ldquo;alignstack\u0026rdquo;, \u0026ldquo;volatile\u0026rdquo;, \u0026ldquo;intel\u0026rdquo;. 我倾向你访问该 文档 来获取解释. 值得注意的是我们需要 \u0026ldquo;alignstack\u0026rdquo; 来让我们的代码在 Windows 上工作.\n运行我们的例子 fn main() { let mut ctx = ThreadContext::default(); let mut stack = vec![0_u8; SSIZE as usize]; unsafe { let stack_bottom = stack.as_mut_ptr().offset(SSIZE); let sb_aligned = (stack_bottom as usize \u0026amp; !15) as *mut u8; std::ptr::write(sb_aligned.offset(-16) as *mut u64, hello as u64); ctx.rsp = sb_aligned.offset(-16) as u64; gt_switch(\u0026amp;mut ctx); } } 这下我们确切的设计了我们自己的栈. hello 是一个指针(一个函数指针)所以我们可以直接把它转成 u64, 因为所有的指针在64位操作系统上是 u64. 然后我们把这个指针写到我们的栈里.\n我们会在下一个章节更多的讨论这个栈, 但是现在有件需要我们知道的事是栈是向下增长的. 如果我们的栈从索引0开始, 结束于索引47. 那么32就是从堆栈末尾开始偏移16个字节的第一位.\n请注意, 我们将指针写入到距离栈底部16个字节偏移的位置.\n这行做了什么 let sb_aligned = (stack_bottom as usize \u0026amp;! 15) as *mut u8?\n我们申请了一个 Vec\u0026lt;u8\u0026gt; 的内存, 但是没有任何保证我们得到的是16字节对齐的地址, 这行将地址四舍五入到最近的16字节对齐. 如果已经16字节对齐了那什么也不会做.\n我们把指针强制转换成 u64 而不是 u8. 我们想要写入的是32,33,34,35,36,37,38,39这八个字节, 如果我们不做这个转换那么则仅仅是尝试把 u64 的指针写入到32处, 这不是我们想要的.\n我们设置了 rsp 为我们的栈索引32的位置, 我们不传递存储在那里的64位的值, 而是第一个字节的地址.\n当我们用 cargo run 运行我们的代码:\nFinished dev [unoptimized + debuginfo] target(s) in 0.58s Running `target\\debug\\green_thread_start.exe` I LOVE WAKING UP ON A NEW STACK! ok, 所以发生了什么? 我们在任何地方都没有调用 hello 函数但是它确实运行了. 我们实际上让 CPU 直接跳到我们的栈并且运行那里的代码. 我们实现了上下文切换的第一步.\n在下一个章节我们在实现我们的绿色线程前将会讲一下我们的栈. 我们已经讲了那么多基础知识了, 所以事情会很简单.\n栈 栈不过是一块连续的内存空间.\n这一点很重要, 电脑只有内存, 没有所谓的 \u0026ldquo;栈\u0026rdquo; 内存和 \u0026ldquo;堆\u0026rdquo; 内存, 它们都是同一个内存的一部分.\n它们的不同是怎么访问和使用内存. 栈在连续的内存空间支持简单的 push/pop 命令, 这使得它们用起来会很快. 堆则是由内存分配器根据需要而分配的, 可能分散在不同的位置.\n我们不会在这里探讨堆和栈的不同, 因为有许多文章都有讨论包括 The Rust Programming Language 的其中一章.\n一个栈看起来长什么样子 让我们从一个简化的栈视图开始. 一个64位 CPU 每次读取8个字节, 尽管我们普通看到的栈是一长行的 u8, 但我们传递指针的时候需要确保我们传递的是 0016, 0008 或者 0000.\n栈是向下增长的, 所以我们从顶部开始向下进行.\n当我们设置一个16字节对齐的栈指针, 我们需要确保把我们的栈指针放在16倍数的地址, 在上面的地址中, 唯一满足条件的地址是 0008 (记住栈是从顶部开始的).\n如果我们在上一章例子中主函数切换之前加入如下几行代码, 我们可以有效地打印我们的栈并查看它.\nfor i in (0..SSIZE).rev() { println!(\u0026#34;mem: {}, val: {}\u0026#34;, stack_ptr.offset(i as isize) as usize, *stack_ptr.offset(i as isize)) } 我们得到的输出:\nmem: 94846750517871, val: 0 mem: 94846750517870, val: 0 mem: 94846750517869, val: 0 mem: 94846750517868, val: 0 mem: 94846750517867, val: 0 mem: 94846750517866, val: 0 mem: 94846750517865, val: 0 mem: 94846750517864, val: 0 mem: 94846750517863, val: 0 mem: 94846750517862, val: 0 mem: 94846750517861, val: 86 mem: 94846750517860, val: 67 mem: 94846750517859, val: 56 mem: 94846750517858, val: 252 mem: 94846750517857, val: 205 mem: 94846750517856, val: 240 mem: 94846750517855, val: 0 mem: 94846750517854, val: 0 mem: 94846750517853, val: 0 mem: 94846750517852, val: 0 mem: 94846750517851, val: 0 mem: 94846750517850, val: 0 mem: 94846750517849, val: 0 mem: 94846750517848, val: 0 mem: 94846750517847, val: 0 mem: 94846750517846, val: 0 mem: 94846750517845, val: 0 mem: 94846750517844, val: 0 mem: 94846750517843, val: 0 mem: 94846750517842, val: 0 mem: 94846750517841, val: 0 mem: 94846750517840, val: 0 mem: 94846750517839, val: 0 mem: 94846750517838, val: 0 mem: 94846750517837, val: 0 mem: 94846750517836, val: 0 mem: 94846750517835, val: 0 mem: 94846750517834, val: 0 mem: 94846750517833, val: 0 mem: 94846750517832, val: 0 mem: 94846750517831, val: 0 mem: 94846750517830, val: 0 mem: 94846750517829, val: 0 mem: 94846750517828, val: 0 mem: 94846750517827, val: 0 mem: 94846750517826, val: 0 mem: 94846750517825, val: 0 mem: 94846750517824, val: 0 I LOVE WAKING UP ON A NEW STACK! 我以 u64 打印了内存地址所以如果你对16进制不是很熟悉的话那这个更容易解析点.\n第一件事就是注意到这仅仅是一段连续的内存, 从 94846750517824 开始, 94846750517871 结束.\n地址 94846750517856 到 94846750517863 是我们感兴趣的一块. 第一个地址是我们栈指针的地址, 它的值我们写入到了 CPU 的 %rsp 寄存器中. 这个范围表示我们在切换上下文之前写入到栈的值.\n换句话说, 240,205,252,56,67,86,0,0 是我们写为u8 的 hello() 函数的指针.\n这里有一个有趣的附带说明, CPU 将 u64 作为 u8 写入的顺序取决于它是用的大端法还是小端法. 如果你手动解析这些数字, 请务必记住这一点.\n在我们写更加复杂的程序时我们非常小的48字节的栈很快就会用完了, 你明白的, 当我们运行在 Rust 中编写的函数时, 代码将指示 CPU 在我们的栈上 pop 和 push 值来运行我们的程序.\n栈大小 在大多数现代操作系统中启动一个进程时标准栈的大小通常是8MB, 但也是可以配置为别的. 对于大多数程序来说这已经够了但是要由程序员来确保使用的栈不会超出拥有的栈大小. 这是我们大多数程序员经历 \u0026ldquo;stack overflow\u0026rdquo; 的原因.\n然而, 当我们自己控制栈的时候我们能选择我们自己想要的大小. 首先, 8MB对于一个运行在 web 服务的例子来说已经远远超出所需了, 所以我们可以减少栈大小来在一个机器上有上百万的绿色线程, 而用操作系统提供的栈则会很快地耗尽内存.\n可增长栈 有一些实现使用的是可增长栈, 这允许我们为大多数任务分配足够用的一小部分内存给栈空间, 但是在用完后不会发生 \u0026ldquo;stack overflow\u0026rdquo;, 而是分配一个新的更大的栈并且把所有东西都移到这个新栈里, 在新栈里可以恢复程序的执行.\nGO 就是这样的一个例子. 它从8KB的栈开始当超出后就会重新分配一个更大的栈. 就像编程中的每件事一样, 这也是需要一定的取舍, 所有的指针需要自己保证正确地更新, 这不是一个简单的任务. 如果你对 GO 如何操作栈有兴趣(一个很好的例子在权衡和使用可增长栈上). 我建议你读这篇文章: how-stacks-are-handled-in-go.\n要说明一些重要的事: 我们使用了标准库中普通的 Vec\u0026lt;u8\u0026gt; 来作为栈, 这很方便但是会有一些问题. 换句话说, 我们没法保证它在内存中的位置一直不变.\n就像你所想的, 如果栈移动到一个不同的地址空间, 那么我们的程序可能就会崩溃因为所有的指针就会失效. 很简单的 push 操作可能会使 vec 拓展到一个新的更大的内存空间, 然后其中的值会被移动到那里.\nOK, 现在我们已经学习了栈长什么样子, 是如何工作的, 我们已经准备好去实现我们的绿色线程了. 你已经做完了艰难的工作所以我保证我们可以写更多的代码了.\n如何设置栈 Windows x64-86 的栈设置与 x64-86 psABI 的调用约定有一些不同. 我将在附录 Windows支持 中更多的讲关于 Windows 的栈. 不过有件重要的事要说, 如果像我们这样只是用简单不带参数的函数来设置堆栈, 那么它们不会有太多的不同.\npsABI 栈布局长这样:\n如你所看到的 %rsp 是我们的栈指针. 我们需要把栈指针放在从基地址开始16的倍数的地方. 返回的地址位于相邻的8个字节中, 其上还有一个存储内存参数的房间. 当我们想要做更复杂的事情的时候我们必须牢记这点.\n你会注意到我们通常把函数地址写入到 stack_ptr + SSIZE - 16 而没有进行说明. 顺便说一下 SSIZE 是栈的字节大小.\n这么说吧, 我们知道一个指针(在例子里是函数指针)的大小是8字节. 我们也知道我们需要把 rsp 写入到16字节的边界中.\n我们除了把函数指针写入到 stack_ptr + SSIZE - 16 以外没有其它的选择. 因为我们从低到高写入我们的地址:\n不能将它写入到 stack_ptr + SSIZE(也是16字节的倍数) 因为这可能导致写入的字节超出我们分配的内存, 那是不被允许的(因为我们为了16字节对齐而进行了四舍五入). 不能写入到 stack_ptr + SSIZE - 8, 虽然它也是一个有效的内存空间, 但是它没有对齐16字节的边界. 由于这些原因因此 stack_ptr + SSIZE - 16 是第一个合适的位置. 在我们的代码中, 我们写入了8个字节在位置: -16,-15,\u0026hellip;,-10,-9 从我们栈的高地址开始(这通常称为栈的底部, 因为栈是向下增长, 这可能有些令人困惑).\n幕后花絮 如果你足够好奇, 你可能会思考在我们切换栈之后发生了什么?\n答案是我们在 Rust 写的代码编译为 CPU 指令, 然后它接管并像使用其它栈一样使用我们的栈.\n然而不幸的是如果想证明这一点那我不得不把栈大小增加到1024字节来允许代码有足够的空间打印出栈本身. 所以我们不会在这打印它来证明这点.\n看一眼栈 我又做了一个我们代码例子的修改版本, 你可以打印内容到两个文本文件中, BEFORE.txt 打印我们的在切换之前的栈, AFTER.txt 打印切换后的栈. 然后你就可以自己看看栈是如何被我们的代码激活和使用.\n如果你发现里面有些你看不懂的东西, 放松, 我们会很快彻底的进行解释.\n#![feature(llvm_asm)] #![feature(naked_functions)] use std::io::Write; const SSIZE: isize = 1024; static mut S_PTR: *const u8 = 0 as *const u8; #[derive(Debug, Default)] #[repr(C)] struct ThreadContext { rsp: u64, r15: u64, r14: u64, r13: u64, r12: u64, rbx: u64, rbp: u64, } fn print_stack(filename: \u0026amp;str) { let mut f = std::fs::File::create(filename).unwrap(); unsafe { for i in (0..SSIZE).rev() { writeln!( f, \u0026#34;mem: {}, val: {}\u0026#34;, S_PTR.offset(i as isize) as usize, *S_PTR.offset(i as isize) ) .expect(\u0026#34;Error writing to file.\u0026#34;); } } } fn hello() { println!(\u0026#34;I LOVE WAKING UP ON A NEW STACK!\u0026#34;); print_stack(\u0026#34;AFTER.txt\u0026#34;); loop {} } unsafe fn gt_switch(new: *const ThreadContext) { llvm_asm!(\u0026#34; mov 0x00($0), %rsp ret \u0026#34; : : \u0026#34;r\u0026#34;(new) : : \u0026#34;alignstack\u0026#34; ); } fn main() { let mut ctx = ThreadContext::default(); let mut stack = vec![0_u8; SSIZE as usize]; let stack_ptr = stack.as_mut_ptr(); unsafe { S_PTR = stack_ptr; std::ptr::write(stack_ptr.offset(SSIZE - 16) as *mut u64, hello as u64); print_stack(\u0026#34;BEFORE.txt\u0026#34;); ctx.rsp = stack_ptr.offset(SSIZE - 16) as u64; gt_switch(\u0026amp;mut ctx); } } 一个绿色线程的实现 在开始之前, 我先说明我们编写的代码非常不安全并且也不是最佳实践, 我希望尽可能编写安全代码的同时不引入额外的复杂度, 所以我鼓励亲爱的读者们如果你们有更好的方案来让代码变得更加安全并且也不会太复杂的话, 欢迎给我的仓库提PR.\n让我们开始吧 首先我们把 main.rs 文件中的内容替换如下:\n#![feature(llvm_asm)] #![feature(naked_functions)] use std::ptr; const DEFAULT_STACK_SIZE: usize = 1024 * 1024 * 2; const MAX_THREADS: usize = 4; static mut RUNTIME: usize = 0; 我们启用了两个特性, asm 在之前有讲到, 接下来我们需要解释下 naked_functions 特性.\nnaked_functions 当 Rust 编译一个函数的时候, 可能会给每个函数添加开场白和后记, 而这可能会导致没有对齐栈以至于我们在切换上下文的时候出现问题. 在我们的第一个简单示例中可能没出现什么问题, 但是一旦我们需要再次切换到相同的栈, 就会遇到麻烦. 将函数标记为 #[naked] 可以移除开场白和后记. 此属性主要用于内联汇编.\n如果你对该属性感兴趣, 想了解更多, 可以参照 RFC #1201.\n我们将 DEFAULT_STACK_SIZE 设置为2MB, MAX_THREADS 设置为4, 这已经足够我们并且远超我们编写的绿色线程所需了.\n最后一个常量 RUNTIME 是我们运行时的指针(是的我知道使用可变全局变量不是很好, 但是我们需要这样并且仅仅在运行时初始化的时候设置该变量).\n译者: Rust 新特性const function是不是可以解决这个问题?\n让我们开始充实我们的代码:\npub struct Runtime { threads: Vec\u0026lt;Thread\u0026gt;, current: usize, } #[derive(PartialEq, Eq, Debug)] enum State { Available, Running, Ready, } struct Thread { id: usize, stack: Vec\u0026lt;u8\u0026gt;, ctx: ThreadContext, state: State, } #[derive(Debug, Default)] #[repr(C)] struct ThreadContext { rsp: u64, r15: u64, r14: u64 r13: u64 r12: u64 rbx: u64 rbp: u64 } Runtime 将会成为我们主要的入口点. 基本上, 我们将会创建一个非常小的运行时来调度切换我们的线程. 这个运行时持有一个 Threads 的数组和一个 current 属性来表明当前运行的线程.\nThread 持有了一个线程应有的数据. 每个线程有一个 id 来让我们分辨它们. stack 和我们在第一个例子中看到的类似. ctx 域是一个表示我们 CPU 所需要恢复的数据在堆栈上位置的上下文, 这些数据要在调度的时候得以恢复. state 表示我们线程的状态.\nState 是一个用来表示我们线程状态的枚举:\nAvailable 意味着线程已经准备好被分配一个任务如果需要的话. Running 意味着该线程已经运行了. Ready 意味着该线程准备好继续向前并恢复执行. ThreadContext 持有着 CPU 恢复在栈上执行所需的寄存器数据.\n如果你不记得寄存器了, 返回 Background Information 章节来阅读寄存器相关. 那里有一些在 x86-64 架构上标记为 callee saved 的寄存器.\n让我们继续:\nimpl Thread { fn new(id: usize) -\u0026gt; Self { Thread { id, stack: vec![0_u8; DEFAULT_STACK_SIZE], ctx: ThreadContext::default(), state: State:Available, } } } 这相当简单. 一个新的线程从 Available 状态开始表明它已经准备好被分配一个任务.\n需要注意的点, 我们在这里分配栈. 这并不必要而且也不是资源使用的好方法, 我们应该在线程需要的时候分配而不是第一次使用 new 时就分配. 然而这降低了我们这部分代码的复杂度, 这更加重要比起去关注如何给我们的栈分配内存.\n重要的一点, 一旦给栈分配了内存就不能再移动它! 不能使用 push() 或其它可能触发 vector 重分配内存的方法. 在该代码更好的版本中, 我们可以包装 vector 并且仅公开我们认为可以安全使用的方法.\n值得一提的是, Vec\u0026lt;T\u0026gt; 有一个 into_boxed_slice() 方法, 该方法返回一个堆分配的切片 Box\u0026lt;T\u0026gt;. 切片不能增长, 所以我们如果用它代替的话可以解决重分配问题.\n实现运行时 该部分中所有的代码都是 impl Runtime 块中的, 这意味着它们都是 Runtime 结构体的方法.\nimpl Runtime { pub fn new() -\u0026gt; Self{ // This will be our base thread, which will be initialized in // the `running` state let base_thread = Thread { id: 0, stack: vec![0_u8; DEFAULT_STACK_SIZE], ctx: ThreadContext::default(), state: State::Running, }; let mut threads = vec![base_thread]; let mut available_threads: Vec\u0026lt;Thread\u0026gt; = (1..MAX_THREADS).map(|i| Thread::new(i)).collect(); threads.append(\u0026amp;mut available_threads); Runtime { threads, current: 0, } } } 当我们实例化 Runtime 的时候我们设置了一个基线程. 这个线程被设置为 Running 状态并且确保在所有任务完成之前保持运行时持续地运行.\n然后我们实例化其它线程, 并将当前线程设置为0 , 这是我们的基线程.\n/// This is cheating a bit, but we need a pointer to our Runtime /// stored so we can call yield on it even if we don\u0026#39;t have a /// reference to it pub fn init(\u0026amp;self) { unsafe { let r_ptr: *const Runtime = self; RUNTIME = r_ptr as usize; } } 现在我们需要这个, 就像我提到过的当我们遍历我们的常量的时候我们需要能够在后续调用 yield, 它并不漂亮, 但是我们知道只要有任何线程 yield 我们的运行时就会存活着, 只要我们不滥用它那就是安全的.\npub fn run(\u0026amp;mut self) -\u0026gt; ! { while self.t_yield() {} std::process::exit(0); } 这是我们开始运行时的地方, 它将持续调用 t_yield() 直到返回 false, 那时候意味着没有更多的任务需要再做了, 所以我们可以退出程序了.\nfn t_return(\u0026amp;mut self) { if self.current != 0 { self.threads[self.current].state = Stete::Available; self.t_yield(); } } 这是当我们线程运行完成后调用的返回函数. return 是 rust 中的保留字所以我们改为了 t_return(). 注意我们线程的用户不能调用它, 当任务完成后我们在我们设置的栈中调用它.\n如果正在调用的线程是 base_thread 那么将什么都不做. 我们的运行时将会在基线程中调用 yield. 如果从一个分发的线程中调用了 t_return() 我们可以知道这个线程已经完成任务了, 我们只会在 guard (后续展示)函数中调用 t_return(), 并且 guard已经在栈顶了.\n我们设置状态为 Available 让运行时知道这个线程已经准备好被分配一个新的任务然后立即调用 t_yield 来调度要运行的新线程.\nNext: 我们的 yield 函数:\nfn t_yield(\u0026amp;mut self) -\u0026gt; bool { let mut pos = self.current; while self.threads[pos].state != State::Ready { pos += 1; if pos == self.threads.len() { pos = 0; } if pos == self.current { return false; } } if self.threads[self.current].state != State::Available { self.threads[self.current].state = State::Ready; } self.threads[pos].state = State::Running; let old_pos = self.current; self.current = pos; unsafe { switch(\u0026amp;mut self.threads[old_pos].ctx, \u0026amp;self.threads[pos].ctx); } // Prevents compiler from optimizing our code away on Windows. self.threads.len() \u0026gt; 0 } 这是我们运行时的核心. 我们使用 t_yield() 而不是 yield 因为这是一个 Rust 的保留字.\n我们遍历所有线程来查看是否有人处于 Ready 状态, 这表明该线程已准备就绪可以继续进行.\n如果没有线程是就绪状态的, 我们就运行结束. 这是一个使用循环算法的简单调度器, 真正的调度程序可能具有更复杂的方式来决定下一步要执行的任务.\n这是定制给我们的粒子的非常幼稚的实现. 想想当我们的线程没有准备好继续(没有在准备状态) 并且在等待一个响应例如数据库.\n解决这个问题并不难, 比起在线程 Ready 时直接运行我们的代码, 我们可以改为轮询它的状态. 举个例子, 如果真的准备好了它可以返回一个 IsReady 或者等待一些其它操作完成那么就 Pending. 在第二种情况, 我们可以将其保持在 Ready 状态以便稍后再次轮询. 它听起来是不是有些熟悉? 如果你读过 Futures 如何在 Rust 中工作, 我们将所有这些点组合串联起来.\n如果我们发现有一个线程准备就绪, 那么我们就把当前线程的状态从 Running 设置为 Ready 以便后续继续运行它.\n然后我们调用 switch 来保存当前线程的上下文, 然后将新的上下文加载到 CPU 中. 这个新的上下文可以是一个新的任务, 也可能是恢复一个已有任务工作所需的上下文信息.\n最后一行只是我们阻止编译器优化代码的一种方法. 我在 Windows 上会需要这行, 但在 Linux 上不会, 而在基准测试的时候是一个常见问题. 因此我们使用 std::hint::black_box 来阻止编译器为了执行更快而跳过了我们需要执行的一些代码. 我使用了另外一种方法同样OK. 代码无论如何不会运行到这个地方.\n下一个是我们的 spawn() 函数:\npub fn spawn(\u0026amp;mut self, f: fn()) { let available = self .threads .iter_mut() .find(|t| t.state == State::Available) .expect(\u0026#34;no available thread.\u0026#34;); let size = available.stack.len(); unsafe { let s_ptr = available.stack.as_mut_ptr().offset(size as isize); let s_ptr = (s_ptr as usize \u0026amp; !15) as *mut u8; std::ptr::write(s_ptr.offset(-16) as *mut u64, guard as u64); std::ptr::write(s_ptr.offset(-24) as *mut u64, skip as u64); std::ptr::write(s_ptr.offset(-32) as *mut u64, f as u64); available.ctx.rsp = s_ptr.offset(-32) as u64; } available.state = State::Ready; } 我认为 t_yield 是逻辑上有趣的函数同时也是技术上最有趣的.\n这是我们设置我们的栈的地方就像我们在上一章节中讲述的那样, 需要确保我们的栈与 psABI 栈布局 类似.\n当我们 spawn 一个新县城我们首先检查是否有线程是 available 状态. 在这个场景如果我们超出了线程数就会 panic, 虽然有一些更好的操作不过我们目前保持我们的例子.\n当我们找到一个 available 线程我们获取它的栈长度和 u8 字节数组的指针.\n在下一部分我们会使用一些 unsafe 函数. 首先我们应该确保我们使用的内存块是16字节对齐的. 然后把 guard 函数的地址写入栈顶, 这是在任务完成函数返回的时候调用的地方. 其次我们写入 skip 函数的地址, 它只是用来填充 f 和 guard 之间的空隙来满足16字节对齐. 然后把 f 地址写到16字节边界处.\n记住我们在 The Stack 章节解释的栈是如何工作的. 我们需要让 f 函数第一个运行, 所以我们设置基指针指向 f 并且确保16字节对齐, 然后我们把 skip 的地址压入, 最后是 guard. 这样做可以确保我们遵守 ABI 要求满足 guard 是16字节对齐的.\n最后我们将状态设置为 Ready 这意味着我们有工作并且也准备好去做了. 记住, 这实际上取决于我们的调度器来启动该线程.\n我们现在完成了我们运行时的实现, 如果你掌握了这些知识, 那么你基本上了解绿色线程是如何工作的. 然而依然有一些细节部分需要实现.\nGuard, skip and switch functions fn guard() { unsafe { let rt_ptr = RUNTIME as *mut RUNTIME; (*rt_ptr).t_return(); }; } 这个函数表示着我们传进来的函数已经返回意味着我们的线程已经完成了运行它的任务, 所以我们解引用我们的 Runtime 并且调用 t_return. 当一个线程完成的时候我们可能需要做一些额外的工作但现在 t_return 就够了. 这使得我们的线程 Available (如果它不是我们的基线程) 并且 yield 以让我们可以恢复其它线程的工作.\n#[naked] fn skip() {} 在 skip 函数里什么也没做. 我们使用 #[naked] 属性, 所以这个函数基本上只是编译为 ret 命令. ret 将会从栈中弹出下一个值并且跳到那个地址指向的任何命令. 在我们的例子中它是 guard 函数. 就像你上一章节看到的那样, 这个函数为了确保我们遵从 ABI 的要求.\npub fn yield_thread() { unsafe { let rt_ptr = RUNTIME as *mut RUNTIME; (*rt_ptr).t_yield(); }; } 这只是一个帮助函数为了我们可以在任何地方调用 yield. 这很不安全, 如果我们的 Runtime 还没有初始化完成或者运行时已经被释放, 它将会有一个 undefined behavior. 然而我们仅仅是想让我们的示例正常运行, 安全性不是我们优先考虑的.\n我们很快到了最后一部分, 最后一个函数了. 如果你理解了前面的部分那你应该不需要注释也可以理解这个函数:\n#[naked] #[inline(never)] unsafe fn switch(old: *mut ThreadContext, new: *const ThreadContext) { llvm_asm!(\u0026#34; mov %rsp, 0x00($0) mov %r15, 0x08($0) mov %r14, 0x10($0) mov %r13, 0x18($0) mov %r12, 0x20($0) mov %rbx, 0x28($0) mov %rbp, 0x30($0) mov 0x00($1), %rsp mov 0x08($1), %r15 mov 0x10($1), %r14 mov 0x18($1), %r13 mov 0x20($1), %r12 mov 0x28($1), %rbx mov 0x30($1), %rbp ret \u0026#34; : :\u0026#34;r\u0026#34;(old), \u0026#34;r\u0026#34;(new) : : \u0026#34;volatile\u0026#34;, \u0026#34;alignstack\u0026#34; ); } 译者: 0x10是16进制, 为10进制的16, 所以上面的内联函数是每8个字节交换old和new.\n这是我们的内联汇编, 就像你在第一个例子中记得的那样只是更复杂一点, 我们首先读取寄存器中的所有我们需要的值然后将所有寄存器中的值设置为 new 线程中挂起执行时保存的值.\n本质上, 这是我们保存和恢复执行所需的全部工作.\n我们再一次看见了 #[naked] 属性. 通常函数都是有开场白和尾声, 但是我们不想要那些因为我们用的都是汇编, 并且我们想要自己掌控一切. 如果我们不使用这个属性我们可能会在第二次切换回我们的栈的时候失败.\n更多的内联汇编的解释请参考这一章节的结尾部分. 如果这些看起来像火星文那么建议你返回读一下这部分.\n有两件事情做的与我们的第一个例子不同.\n首先是 #[inline(never)], 这个属性阻止编译器内联这个函数, 我试了很多次, 如果我们不加这个属性那么在 --release 模式编译的话会运行失败.\n\u0026quot;volatile\u0026quot; 选项是另一个. 就像我先前警告的那样, 内联汇编有点啰嗦, 这表明了我们的汇编有副作用. 就是说当我们传入输入参数的时候我们需要确保编译器知道我们改变了传入的参数而不仅仅是读取它们.\n0x00($1) # 0 0x08($1) # 8 0x10($1) # 16 0x18($1) # 24 我之前有简单提到过, 但是我们再看一次. 这些都是 hex 数字表明我们想要从内存指针偏移多少来读写. 我们每次仅仅偏移8个字节这与我们 ThreadContext 结构体中的 u64 属性是相同大小的.\n同样重要的一点需要说明的是 ThreadContext 被 #[repr(C)] 标记着, 所以我们知道数据在内存中表示的方法并且写入正确的字段. Rust ABI 不保证我们的结构体的属性在内存中是按顺序表示的, 而 C-ABI 有保证.\nmain函数 fn main() { let mut runtime = Runtime::new(); runtime.init(); runtime.spawn(|| { println!(\u0026#34;THREAD 1 STARTING\u0026#34;); let id = 1; for i in 0..10 { println!(\u0026#34;thread: {} counter: {}\u0026#34;, id, i); yield_thread(); } println!(\u0026#34;THREAD 1 FINISHED\u0026#34;); }); runtime.spawn(|| { println!(\u0026#34;THREAD 2 STARTING\u0026#34;); let id = 2; for i in 0..15 { println!(\u0026#34;thread: {} counter: {}\u0026#34;, id, i); yield_thread(); } println!(\u0026#34;THREAD 2 FINISHED\u0026#34;); }); runtime.run(); } 正如你看到的那样, 我们初始化运行时并且发放了两个线程, 一个从1计数到10, 在每次计数之间让出控制权/yield, 而另一个计数到15. 我们可以使用 cargo run 来运行我们的项目, 我们可以看到以下输出:\nFinished dev [unoptimized + debuginfo] target(s) in 2.17s Running `target/debug/green_threads` THREAD 1 STARTING thread: 1 counter: 0 THREAD 2 STARTING thread: 2 counter: 0 thread: 1 counter: 1 thread: 2 counter: 1 thread: 1 counter: 2 thread: 2 counter: 2 thread: 1 counter: 3 thread: 2 counter: 3 thread: 1 counter: 4 thread: 2 counter: 4 thread: 1 counter: 5 thread: 2 counter: 5 thread: 1 counter: 6 thread: 2 counter: 6 thread: 1 counter: 7 thread: 2 counter: 7 thread: 1 counter: 8 thread: 2 counter: 8 thread: 1 counter: 9 thread: 2 counter: 9 THREAD 1 FINISHED. thread: 2 counter: 10 thread: 2 counter: 11 thread: 2 counter: 12 thread: 2 counter: 13 thread: 2 counter: 14 THREAD 2 FINISHED. 漂亮, 我们的线程是交替的, 因为我们在每个计数之间让出控制权直到线程1完成, 线程2在完成任务之前继续剩下的计数.\n恭喜 你现在已经实现了一个超级简单但是能运行的绿色线程例子. 这是我们必须经历的一段旅程, 如果你已经读了很久完全理解了这些, 现在你应该休息一会了. 谢谢阅读!\n完成的200行代码 #![feature(llvm_asm, naked_functions)] const DEFAULT_STACK_SIZE: usize = 1024 * 1024 * 2; const MAX_THREADS: usize = 4; static mut RUNTIME: usize = 0; pub struct Runtime { threads: Vec\u0026lt;Thread\u0026gt;, current: usize, } #[derive(PartialEq, Eq, Debug)] enum State { Available, Running, Ready, } struct Thread { id: usize, stack: Vec\u0026lt;u8\u0026gt;, ctx: ThreadContext, state: State, } #[derive(Debug, Default)] #[repr(C)] struct ThreadContext { rsp: u64, r15: u64, r14: u64, r13: u64, r12: u64, rbx: u64, rbp: u64, } impl Thread { fn new(id: usize) -\u0026gt; Self { Thread { id, stack: vec![0_u8; DEFAULT_STACK_SIZE], ctx: ThreadContext::default(), state: State::Available, } } } impl Runtime { pub fn new() -\u0026gt; Self { let base_thread = Thread { id: 0, stack: vec![0_u8; DEFAULT_STACK_SIZE], ctx: ThreadContext::default(), state: State::Running, }; let mut threads = vec![base_thread]; let mut available_threads: Vec\u0026lt;Thread\u0026gt; = (1..MAX_THREADS).map(|i| Thread::new(i)).collect(); threads.append(\u0026amp;mut available_threads); Runtime { threads, current: 0, } } pub fn init(\u0026amp;self) { unsafe { let r_ptr: *const Runtime = self; RUNTIME = r_ptr as usize; } } pub fn run(\u0026amp;mut self) -\u0026gt; ! { while self.t_yield() {} std::process::exit(0); } fn t_return(\u0026amp;mut self) { if self.current != 0 { self.threads[self.current].state = State::Available; self.t_yield(); } } fn t_yield(\u0026amp;mut self) -\u0026gt; bool { let mut pos = self.current; while self.threads[pos].state != State::Ready { pos += 1; if pos == self.threads.len() { pos = 0; } if pos == self.current { return false; } } if self.threads[self.current].state != State::Available { self.threads[self.current].state = State::Ready; } self.threads[pos].state = State::Running; let old_pos = self.current; self.current = pos; unsafe { switch(\u0026amp;mut self.threads[old_pos].ctx, \u0026amp;self.threads[pos].ctx); } self.threads.len() \u0026gt; 0 } pub fn spawn(\u0026amp;mut self, f: fn()) { let available = self .threads .iter_mut() .find(|t| t.state == State::Available) .expect(\u0026#34;no available thread.\u0026#34;); let size = available.stack.len(); unsafe { let s_ptr = available.stack.as_mut_ptr().offset(size as isize); let s_ptr = (s_ptr as usize \u0026amp; !15) as *mut u8; std::ptr::write(s_ptr.offset(-16) as *mut u64, guard as u64); std::ptr::write(s_ptr.offset(-24) as *mut u64, skip as u64); std::ptr::write(s_ptr.offset(-32) as *mut u64, f as u64); available.ctx.rsp = s_ptr.offset(-32) as u64; } available.state = State::Ready; } } #[naked] fn skip() { } fn guard() { unsafe { let rt_ptr = RUNTIME as *mut Runtime; (*rt_ptr).t_return(); }; } pub fn yield_thread() { unsafe { let rt_ptr = RUNTIME as *mut Runtime; (*rt_ptr).t_yield(); }; } #[naked] #[inline(never)] unsafe fn switch(old: *mut ThreadContext, new: *const ThreadContext) { llvm_asm!(\u0026#34; mov %rsp, 0x00($0) mov %r15, 0x08($0) mov %r14, 0x10($0) mov %r13, 0x18($0) mov %r12, 0x20($0) mov %rbx, 0x28($0) mov %rbp, 0x30($0) mov 0x00($1), %rsp mov 0x08($1), %r15 mov 0x10($1), %r14 mov 0x18($1), %r13 mov 0x20($1), %r12 mov 0x28($1), %rbx mov 0x30($1), %rbp ret \u0026#34; : :\u0026#34;r\u0026#34;(old), \u0026#34;r\u0026#34;(new) : : \u0026#34;volatile\u0026#34;, \u0026#34;alignstack\u0026#34; ); } fn main() { let mut runtime = Runtime::new(); runtime.init(); runtime.spawn(|| { println!(\u0026#34;THREAD 1 STARTING\u0026#34;); let id = 1; for i in 0..10 { println!(\u0026#34;thread: {} counter: {}\u0026#34;, id, i); yield_thread(); } println!(\u0026#34;THREAD 1 FINISHED\u0026#34;); }); runtime.spawn(|| { println!(\u0026#34;THREAD 2 STARTING\u0026#34;); let id = 2; for i in 0..15 { println!(\u0026#34;thread: {} counter: {}\u0026#34;, id, i); yield_thread(); } println!(\u0026#34;THREAD 2 FINISHED\u0026#34;); }); runtime.run(); } 译者: 下一个章节是对 Windows 的额外支持, 有兴趣的可以自行阅读.\n如果翻译有任何问题, 欢迎给我提 issue.\n","date":"2020-11-18T13:28:44+08:00","image":"/post/translation/rust/green_threads_explained_in_200_lines_of_rust/cover_hud99fec317f0d171bfccb5e21f0f08cf5_179342_120x120_fill_box_smart1_3.png","permalink":"/post/translation/rust/green_threads_explained_in_200_lines_of_rust/","title":"200行Rust代码解释绿色线程"},{"content":"小记自己为什么会学 Rust . Rust 有什么特性吸引到我了~\n如果说 C 语言是具备高灵活性, 信任着开发者, 将一切交给开发者来解决的话.\n那么 Rust 就是降低该灵活性, 毫不信任开发者, 将开发者的大部分错误都在编译期发掘出来, 强制要求开发者去了解可能存在的问题并解决掉它.\nC 语言可能条条大路通罗马, Rust 可能只有寥寥无几的道路.\n总之, Rust 拔高了开发者的下限, 如果水平不够是连编译器都不会通过的, 更不要说 commit 了.\n优雅的Rust 听说到 Rust 最多的自然是所谓的内存安全. 那么什么是内存安全？ 内存安全体现在哪里呢？\n比如说这段 C语言 代码.\nint a[5]; a[6] = 6; printf(\u0026#34;%d\u0026#34;, a[6]); 这段代码能正确输出 a[6] 吗?\n答案是可以的, 虽然它很明显的内存越界了, 但内存越界似乎在 C 里并不是什么大不了的事, 编写的代码随便越界, 只不过导致的后果需要自己承担而已.\n当然现今大部分的高级语言对指针越界都会有很明确的编译错误, 所以仅这点来看并不能体现出 Rust 的特点, 只不过是有了现代语言该有的东西——内存越界提示.\n那么有什么可以体现出 Rust 独有特性的地方呢?\n参考这一段结构体.\ntypedef struct { struct Node *next; int val; }Node; typedef struct { Node *head; Node *tail; int size; }LinkedList; struct { void (*push)(struct LinkedList *self, Node val); Node *(*peek)(struct LinkedList *self); Node *(*pop)(struct LinkedList *self); }StackMethod; 这是一个简单的数据结构栈, 在栈方法中定义了三个函数指针, 不需要关注 push 方法, 来看看 peek 方法.\npeek 方法将栈中的尾结点返回, 和 pop 方法的区别是它不会从链表中删除该节点. 但此时该方法的调用者拥有了该节点的所有权限, 如果调用者此时又释放了该地址指向的内存, 当再次调用 pop 方法时, pop 方法将返回一个已经释放了内存的结点指针, 此时如果访问该结点大概率会出现 Segementation fault. 因为访问了一个没有分配的内存空间. Segementation fault 大概是我写 C 时候最讨厌的错误了.\n那么 Rust 是如何解决的呢? 答案是所有权.\n所有权 fn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; } 在将 s1 赋值给 s2 后, 此时 s1 就已经是无效的了, 它的作用域仅到赋值给 s2 之前为止.\n同样类似的.\nfn hello(str: String) { println!(\u0026#34;{}\u0026#34;, str); } fn main() { let s1 = \u0026#34;hello\u0026#34;.to_string(); hello(s1); println!(\u0026#34;{}\u0026#34;, s1); // error } 这段相等同的 C 代码会有问题么?\n可能会有问题. 如果在 hello 中释放了内存, 那么 main 函数中后续对 s1 的访问就会出现段错误. 就像这样:\nvoid hello(char* str) { printf(\u0026#34;%s\\n\u0026#34;, str); free(str); } int main() { char s1[5] = { \u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;}; hello(s1); printf(\u0026#34;%s\\n\u0026#34;, s1); } 在 Rust 中就完全避免了这种情况, 这样的代码在Rust中连编译都不会通过的.\n那么 main 函数后续不能再用该变量了吗? 有两种方法可以解决该问题.\n可以将 hello 函数的签名增加个返回值, 使用完变量后将其所有权返回给调用者. main 函数也需要提供一个接收者接收该变量的所有, 该做法使用了 Rust 变量覆盖的特性, 可以声明同名变量, 就跟 Javascript 类似. 后续声明的同名变量会覆盖先前的.\nfn hello(str: String) -\u0026gt;String { println(\u0026#34;{}\u0026#34;, str); str } fn main() { let s1 = \u0026#34;hello\u0026#34;.to_string(); let s1 = hello(s1); println!(\u0026#34;{}\u0026#34;, s1); } 第一种是个很自然而且很容易想到并理解的做法( Rust 中函数块最后一行且没有带分号的会被当做返回值, 所以可以省略掉 return ). 还有另一种做法, 那就是引用.\nfn hello(str: \u0026amp;String) { println!(\u0026#34;{}\u0026#34;, *str); } fn main() { let s1 = \u0026#34;hello\u0026#34;.to_string(); hello(\u0026amp;s1); println!(\u0026#34;{}\u0026#34;, s1); } 使用 \u0026amp; 表示一个引用或引用类型, * 则表现为消除 \u0026amp;, 也就是解引用. 用法类似与 C 中的指针. 而在 Rust 中是会自动解引用的, 所以 hello 函数也可以改为:\nfn hello(str: \u0026amp;String){ println!(\u0026#34;{}\u0026#34;, str); } 在 C 中可能存在的野指针问题在 Rust 中也可以通过所有权系统来解决.\n野指针主要为未初始化或释放后未置空或操作超越变量作用域.\n参照如下 C 代码:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { int *p = (int *)malloc(4); *p = 4; free(p); int *q = (int *)malloc(4); *q = 2; printf(\u0026#34;q = %d\\n\u0026#34;, *q); //此处打印 q = 2 *p = 4; printf(\u0026#34;q = %d\\n\u0026#34;, *q); //此处打印 q = 4 } 是不是很神奇. 那么为什么会出现这种现象?\n因为在 C 中使用 malloc 分配内存的时候, 会优先分配前次释放的内存, 所以两处调用 malloc 所得到的地址是一样的. 在释放 p 之后, 没有对 p 进行赋空操作, 此时 p 就成了一个野指针. 然后接着又分配了一个跟前序 p 一样大小的内存空间, 此时 p 和 q 就是一样的了——指向相同的地址. 所以对 p 指向的值进行的修改会反映在 q 上. 虽然简单的在释放 p 后给其赋值为 NULL 就可以了, 但是如果有个人疏忽了呢? 毕竟人是不会永远不犯错的. 在 Rust 中类似这样的代码是不可能通过的, 因为在释放 p 的时候所有权已经转移给 free 函数了, main函数后续是不能再使用的.\n不管是学过 Java 的还是学过 C 的, 肯定都多多少少了解过关于引用传递和值传递, 有相当多的教学声明 Java 中仅存在值传递.\n在 C 语言中指针则类似于引用传递, 通过地址引用指向内存空间的值. 因为有地址所以可以修改其中的值并且被其它函数观察到. 传递引用有一个问题, 有时候我们并不想别人改变我们的值, 但又不得不声明为指针(比如说结构体的自引用), 同时又忘了给该参数声明为 const , 这样就会有很多问题. 尤其在初学 C 的时候, 几乎很少有人会用到 const 关键词. 很多人是不晓得该关键词到底有多么重要的, 而 Rust 就会强迫我们去学习, 了解不可变的重要性.\n那么很自然的就过渡到下一个阶段~\n可变性与不可变性 然而在 Rust 中所有的变量如果不显式声明, 那就是不可修改的( unsafe 是特例). 所以如果要传递一个可变引用, 就需要如下的声明:\nfn hello(str: \u0026amp;mut String) { println!(\u0026#34;{}\u0026#34;, str); str.push_str(\u0026#34;world\u0026#34;); //3. 修改str的值. } fn main() { let mut s1 = \u0026#34;hello\u0026#34;.to_string(); //1. 此处声明s1是可变的变量. hello(\u0026amp;mut s1); //2. 传递一个可变引用给hello函数. println!(\u0026#34;{}\u0026#34;, s1); } 显式声明 str 是可变的, 否则对变量做的任何修改在编译期都是无法通过的. 这就避免了很多 Code 时的隐性错误.\nRust 中关于该特性有几个关键点.\n变量可以有多个不可变引用. 变量只能有一个可变引用. 变量有可变引用的同时不能有不可变引用. 比如如下代码:\nfn main() { let mut s1 = \u0026#34;hello\u0026#34;.to_string(); let s2 = \u0026amp;s1; hello(\u0026amp;mut s1); println!(\u0026#34;{}\u0026#34;, s1); println!(\u0026#34;{}\u0026#34;, s2); } 编译时会报错\nerror[E0502]: cannot borrow s1 as mutable because it is also borrowed as immutable\n错误提示相当友好了, 不能将 s1 作为可变引用因为它已经有一个不可变引用了. 为什么要这么设计?\n可以想象一下在 C 中, 编写了一个返回指针的函数, 有多个不同调用方或许都对指向的值进行了修改, 某个调用方又如何知道该值是否是最初的函数所返回的呢? 还是因为各个调用方可能进行的修改后的结果. 解决方法肯定是有的, 比如说注意一下各个调用方的顺序之类的, 只是有时项目庞大而复杂, 是没法顾及到方方面面, 这时是需要有个 \u0026ldquo;人\u0026rdquo; 来提醒一下我们.\n因此, 可变引用与不可变引用直接是互斥的, 不可变引用之间也是互斥的, 它们不能同时存在.\n上面的代码调换一下位置就可以了.\nfn main() { let mut s1 = \u0026#34;hello\u0026#34;.to_string(); hello(\u0026amp;mut s1); let s2 = \u0026amp;s1; println!(\u0026#34;{}\u0026#34;, s1); println!(\u0026#34;{}\u0026#34;, s2); } 此时在 s2 声明的位置, s1 的可变引用的作用域已经结束, 现在 s1 是没有其它引用的, 所以可以拿到其的一个引用.\n在这里, 为了引入个下一话题, 我们不自然地回顾一下上一章节的野指针问题~\n类似的如下 C 代码:\n#include \u0026lt;stdio.h\u0026gt; char *dangle() { char a[3] = \u0026#34;abc\u0026#34;; printf(\u0026#34;%s\\n\u0026#34;, a); return a; } int main(void) { char *p = dangle(); printf(\u0026#34;%s\\n\u0026#34;, p); } 在函数结束的时候变量 a 已经被销毁, 将该地址返回就会产生野指针.\n如何修正该代码?\n#include \u0026lt;stdio.h\u0026gt; char *dangle() { char *a = \u0026#34;abc\u0026#34;; printf(\u0026#34;%s\\n\u0026#34;, a); return a; } int main(void) { char *p = dangle(); printf(\u0026#34;%s\\n\u0026#34;, p); } 这样就可以了.这样所声明的变量 a 实际上为字符串常量, 是不可变的, 存储在静态存储区. 由程序结束后操作系统回收该部分内存. 所以在函数结束后 a 指向的值是不会被销毁的. 将该地址返回也是完全没有错误的.\n这些细枝末节在初学 C 的时候是很难注意到的. 毕竟大多数大学生使用的教材还是谭浩强版, 用于应试是够了, 实际开发是远远不行的.\n如果在 Rust 中写出这样的代码呢?\nfn main() { let reference_to_nothing = dangle(); } fn dangle() -\u0026gt; \u0026amp;String { let s = String::from(\u0026#34;hello\u0026#34;); \u0026amp;s } 首先说点题外话, 在 Rust 中命名通常用蛇形命名法, 不像 Java 中普遍的是大驼峰和小驼峰. 至于好看与否, 看眼缘吧~\n这里同样的编译是不能通过的.\nerror[E0106]: missing lifetime specifier \u0026ndash;\u0026gt; src\\main.rs:5:16 | 5 | fn dangle() -\u0026gt; \u0026amp;String { | ^ expected named lifetime parameter | = help: this function\u0026rsquo;s return type contains a borrowed value, but there is no value for it to be borrowed from help: consider using the 'static lifetime | 5 | fn dangle() -\u0026gt; \u0026amp;\u0026lsquo;static String { | ^^^^^^^^\n可以说相当友好了, 编译器同时提示了错误是什么, 以及该如何解决它.\n该错误说明了该函数缺少生命周期指示符. 帮助说明了该函数返回的值包含了一个引用值, 但是这种类型是没有可以用来借用的, 需要考虑加上 'static 生命周期, 这样就杜绝了返回局部变量引用的情况.\n这样就引入了下一个话题~\n生命周期 以下内容主要参考 The Rust Programming Language\n生命周期只是一个标签, 语法是'+字符串/字符. 比如 'a, 'b. 'static 是一个特殊的生命周期, 表示静态存储, 类似于 Java 和 C\\C++ 中的 static, 也就是一直存活到程序结束运行才会销毁.\n生命周期主要是为了避免悬垂引用(野指针), 在 Rust编译器 中实现了一个借用检查器, 通过比较作用域来确保所有借用的有效性.\n{ let r; // ---------+-- \u0026#39;a { // | let x = 5; // -+-- \u0026#39;b | r = \u0026amp;x; // | | } // -+ | println!(\u0026#34;r: {}\u0026#34;, r); // | } // ---------+ 这里 r 的生命周期为 'a, x 的生命周期为 'b , 'b 的范围小于 'a 的范围, 由于 r 引用了一个存活范围小于它的变量, 所以会编译失败.\n{ let x = 5; // ----------+-- \u0026#39;b let r = \u0026amp;x; // --+-- \u0026#39;a | println!(\u0026#34;r: {}\u0026#34;, r); // | | // --+ | } // ----------+ 改为这样子, 因为 r 的生命周期 'a 小于 'b , 这样就能保证在 r 有效的时候 x 总是有效的, 这样 r 就不可能变成一个野指针.\n考虑这样一个函数:\nfn longest(x: \u0026amp;str, y: \u0026amp;str) -\u0026gt; \u0026amp;str { if x.len() \u0026gt; y.len() { x } else { y } } fn main() { let string1 = String::from(\u0026#34;long string is long\u0026#34;); { let string2 = String::from(\u0026#34;xyz\u0026#34;); let result = longest(string1.as_str(), string2.as_str()); println!(\u0026#34;The longest string is {}\u0026#34;, result); } } 乍看之下没有什么问题对吧? 但是编译还是不通过.\nerror[E0106]: missing lifetime specifier \u0026ndash;\u0026gt; src\\main.rs:1:33 | 1 | fn longest(x: \u0026amp;str, y: \u0026amp;str) -\u0026gt; \u0026amp;str { | \u0026mdash;- \u0026mdash;- ^ expected named lifetime parameter | = help: this function\u0026rsquo;s return type contains a borrowed value, but the signature does not say whether it is borrowed from x or y help: consider introducing a named lifetime parameter | 1 | fn longest\u0026lt;\u0026lsquo;a\u0026gt;(x: \u0026amp;\u0026lsquo;a str, y: \u0026amp;\u0026lsquo;a str) -\u0026gt; \u0026amp;\u0026lsquo;a str { | ^^^^ ^^^^^^^ ^^^^^^^ ^^^\n根据报错提示, 我们修改函数签名为fn longest\u0026lt;'a\u0026gt;(x: \u0026amp;'a str, y: \u0026amp;'a str) -\u0026gt; \u0026amp;'a str 这样这段代码就可以正确运行了. 生命周期在函数签名中的用法类似于泛型, 前面多个单引号而已. 然后在对应的参数上声明所需要的生命周期就可以了.\n这个函数签名表示告诉调用者 x , y , str 这三个至少能存活的一样久, 否则就不能编译通过.\n我们修改下 main 函数为如下:\nfn main() { let string1 = String::from(\u0026#34;long string is long\u0026#34;); let result; { let string2 = String::from(\u0026#34;xyz\u0026#34;); result = longest(string1.as_str(), string2.as_str()); } println!(\u0026#34;The longest string is {}\u0026#34;, result); } 我们将延长 result 的生命周期, 并且将 println 移动到块外面, 这样子编译是不通过的. 来看看编译错误信息:\nerror[E0597]: string2 does not live long enough \u0026ndash;\u0026gt; src\\main.rs:14:44 | 14 | result = longest(string1.as_str(), string2.as_str()); | ^^^^^^^ borrowed value does not live long enough 15 | } | - string2 dropped here while still borrowed 16 | println!(\u0026ldquo;The longest string is {}\u0026rdquo;, result); | \u0026mdash;\u0026mdash; borrow later used here\n提示我们 string2 在 println 前就被释放了. 如果像之前那样没有给函数签名加上生命周期的话, 编译器是不能知道函数返回的值到底能存活多久的, 生命周期表明了返回的值与参数的生命周期应该是一致的, 这里所谓的一致是指同样生命周期标签中最小的那个. 在正确的代码中, 三个参数分别对应的 string1, string2, result 中, 最短的那个是 result , 编译器能推断出在 result 存活的范围它所引用的值是一直有效的.\n而在错误的代码中, string2 是生命周期最短的那个, 所以编译器推断出 result 只能在 string2 存活的范围内使用, 一旦超出该范围, 就可以提示调用者需要修改代码.\n简单说下 Rust 如何清理内存, 只要让它离开作用域就可以了, 离开作用域的时候会自动调用该类型的 drop 方法, 而 drop 一般都是由编译器提供默认实现的, 有时候默认实现不够高效才需要自己去实现. 我们不能调用变量的 drop 方法, 那样就会有多次释放的问题, 如有需要可以调用标准库提供的 drop 函数.\n标准库有提供一个 drop 函数, 用来手动释放内存, 可以看看它的实现~\ncore::mem pub fn drop(_x: T) Disposes of a value. This does so by calling the argument\u0026rsquo;s implementation of Drop. This effectively does nothing for types which implement Copy, e.g. integers. Such values are copied and then moved into the function, so the value persists after this function call. This function is not magic; it is literally defined as pub fn drop(_x: T) { }\nBecause _x is moved into the function, it is automatically dropped before the function returns.\n它的实现仅仅是一个空函数块, 将该变量的所有权转移到该函数块中, 在结束的时候调用该变量的 drop 方法.\n上面似乎都是一些内存安全相关的特性, 感觉只体现出来 Rust 编译器的强大, 接下来, 可以转下一个话题了, 简单介绍下 Rust 的一些优雅的语法特性~\nTrait Trait 类似与 Java 中的接口概念, 近年来一直以来都有组合大于继承的口号, Trait 就是在 Rust 中用来实现组合这一理念的.\n继承有时候用起来是真的不顺心. 继承吧, 好多用不到的东西, 不继承吧, 又有很多重复工作要做. Rust 中干脆扔掉了继承.\n像前面讲到的实现 drop 方法, 怎么为我们的类型实现 drop 方法呢?\nDrop 中只有一个方法, 它的签名为: fn drop(\u0026amp;mut self); 所以我们就像实现接口一样实现该方法就可以了.\nstruct MyVar { names: Vec\u0026lt;String\u0026gt; } impl Drop for MyVar { fn drop(\u0026amp;mut self) { \u0026amp;self.names; println!(\u0026#34;MyVar drops\u0026#34;); } } fn main() { let _ = MyVar { names: vec![\u0026#34;hello\u0026#34;.to_string(), \u0026#34;world\u0026#34;.to_string()] }; } 运行后将打印出 MyVar drops , 可以看出来在离开作用域后就自动调用了我们自定义的 drop 方法.\n可以用 Trait 配合泛型编写一个通用的 largest 函数.\nfn largest\u0026lt;T: PartialOrd + Clone\u0026gt;(list: \u0026amp;[T]) -\u0026gt; T { let mut largest = list[0].clone(); for item in list.iter() { if *item \u0026gt; largest { largest = item.clone(); } } largest } fn main() { let number_list = vec![34, 50, 25, 100, 65]; let result = largest(\u0026amp;number_list); println!(\u0026#34;The largest number is {}\u0026#34;, result); let char_list = vec![\u0026#39;y\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;q\u0026#39;]; let result = largest(\u0026amp;char_list); println!(\u0026#34;The largest char is {}\u0026#34;, result); } PartialOrd 是基于排序为目的而比较一个类型, 实现了该 Trait 的类型就可以使用 \u0026gt; , \u0026lt;= , \u0026gt; , \u0026gt;= , 可以近似的看作 C++ 中的操作符重载.\n这里再简单说明一下 Copy 和 Clone.\nClone 就是所谓的 深拷贝 , 我们也可以用 Copy , Copy 是浅拷贝.\nCopy 是简单的拷贝存储再栈上的位来赋值值, 比较高效, 是一个标记型 Trait , 该 Trait 的实现基准是: 如果一个类型内部的类型全部是 Copy 的, 那么该类型也是 Copy , 比如所有的基本类型. 而 Clone 是深拷贝, 我们需要为必要的类型自己实现该 Trait , 当调用一个 Clone 的时候我们应该知道该操作可能会比较慢.\n我们也可以为 Triat 实现 Trait , 这用到了 Rust 中的动态分发, 这里不详细说明, 只做介绍.\ntrait Animal { fn name(\u0026amp;self) -\u0026gt; String; } trait Bark { fn bark(\u0026amp;self); } struct Dog; impl Animal for Dog { fn name(\u0026amp;self) -\u0026gt; String { \u0026#34;Kitty\u0026#34;.to_string() } } impl Bark for Box\u0026lt;dyn Animal\u0026gt; { fn bark(\u0026amp;self) { println!(\u0026#34;{} bark.\u0026#34;, self.name()); } } fn main() { let dog: Box\u0026lt;dyn Animal\u0026gt; = Box::new(Dog); dog.bark(); } 我们可以用 Trait 来组合成我们最终所需要的类型, 每个 Trait 都是那么的小巧简洁~ 不像是继承, 继承有着严重的耦合, 并且显得不是那么精巧.\n之前我们有提到过 Rust 中是没有空指针的, 那么我们如何表示一个可能存在的值呢?\n如果有人用过 JDK8 中的 Optional 的话, 那应该就很熟悉了~答案就是 Option.\nOptional 在 Java 中出现的太晚了, 很多人对这个特性是不怎么了解的, 迁移起来也很麻烦, 普遍还是使用空指针和捕获空指针异常来处理.\n而在 Rust 中 Option 遍布了各个角落, Option 只是一个简单的枚举, 所以我们直接说明下 Rust 中使用枚举处理空指针和异常错误的方法.\n枚举 Option Option 只是一个简单的枚举类型, 但是在 Rust 中枚举是很强大的.\nOption 的签名是\npub enum Option\u0026lt;T\u0026gt; { None, Some(T), } 它是这么使用的:\nfn main() { let x = Option::Some(1); match x { Some(x) =\u0026gt; println!(\u0026#34;Val is: {}\u0026#34;, x), None =\u0026gt; println!(\u0026#34;No val\u0026#34;) }; } 在 Rust 中对于枚举的所有类型都强制遍历处理, 当然也可以用 _ 来忽略掉不需要的部分, 所有我们不确定是否有值的地方都需要用 Option 来表示.\nResult Rust 中也是用枚举来处理异常错误.\nuse std::net::TcpStream; fn main() { let tcp_stream = TcpStream::connect(\u0026#34;127.0.0.1:8000\u0026#34;); match tcp_stream { Ok(_) =\u0026gt; println!(\u0026#34;success\u0026#34;), Err(e) =\u0026gt; println!(\u0026#34;{}\u0026#34;, e), }; } 不需要捕获异常, 要知道 Java 中捕获异常是很耗费性能的, 使用枚举来处理空指针和异常错误是不是很优雅~\n除了使用模式匹配外, 我们还可以使用 if let , 如下:\nuse std::net::TcpStream; fn main() { let tcp_stream = TcpStream::connect(\u0026#34;127.0.0.1:8000\u0026#34;); if let Ok(_) = tcp_stream { println!(\u0026#34;success\u0026#34;); } else { println!(\u0026#34;error\u0026#34;); } } 同样类似的还有 while let .\nSummary 上述差不多说明了一些为什么我选择学 Rust 的理由, 当然还有很多其它的, 我所述并不足以解释 Rust 在最受程序员欢迎的语言调查中占据榜一.\n我在写 C 代码的时候, 总会纠结该不该释放内存, 有没有野指针的可能. 也烦恼与标准库不够好用, 各平台头文件不够统一, 没法编写多平台通用的代码.\n同样的, 在写 Java 的时候又会感觉有些啰嗦, 很多写法不够简洁.\n而 Rust 的话, 标准库足够好用, 是否内存安全有编译器提醒, 而且写起来有很多语法糖比 Java 要小巧很多, 也只有很小的运行时, 没有垃圾回收, 可以直接打包成二进制文件运行. 性能与 C 是差不多的.\n不过说来我学 Rust 还有一个原因是因为它够难, 而且没什么历史包袱, 比较有挑战. C++ 的历史包袱换个词也可以说是经验积累, 不过我个人觉得有些太过厚重, 有些难啃吧.\n本文浅尝辄止, 简单说明了一些 Rust 的特性. 这些特性差不多都是众多程序员在编写 C/C++ 程序中总结出来的类似于最佳实践之类的东西. 所以本文也大量对比了 Rust 和 C , 并且学习 Rust 也是离不开 C 的, 其中存在了 unsafe 这样的东西. 不了解 C 的话是没法写 unsafe 部分的, 当然这部分大部分程序员也不怎么会接触到.\n同时 Rust 作为系统级语言, 与 C 也有着非常友好的交互性, 很容易使用的 FFI , 不管是为了从 C 逐步切换到 Rust , 还是为了牺牲点安全提高灵活性的目的而使用 FFI , 这都算是一个亮点了. 毕竟 C 在各个领域都算是不可或缺的基本编程语言了.\n","date":"2020-09-15T15:30:44+08:00","image":"/post/rust/elegent_rust/cover_hu99bb65b34be40363fd484c863e327c7b_227902_120x120_fill_box_smart1_3.png","permalink":"/post/rust/elegent_rust/","title":"优雅的Rust"}]