<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on</title><link>/post/</link><description>Recent content in Posts on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 01 May 2021 00:50:44 +0800</lastBuildDate><atom:link href="/post/index.xml" rel="self" type="application/rss+xml"/><item><title>逆变与协变</title><link>/post/programming_language/covariance_and_contravariance/</link><pubDate>Sat, 01 May 2021 00:50:44 +0800</pubDate><guid>/post/programming_language/covariance_and_contravariance/</guid><description>&lt;blockquote>
&lt;p>逆变和协变看了忘忘了看, 这次学C#顺带查阅各处总结了下&amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>协变&lt;/strong>&lt;/p>
&lt;p>协变是指能够使用比原始指定的类型派生程度更大的类型.&lt;/p>
&lt;p>例如Dog与Cat继承自Animal, 那么从Dog-&amp;gt;Animal就称为协变, 那么协变有什么作用呢?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c#" data-lang="c#">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Animal.cs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">abstract&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Animal&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Dog&lt;/span> : Animal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c#" data-lang="c#">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Main.cs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Main()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Dog dog = &lt;span style="color:#66d9ef">new&lt;/span> Dog();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Animal animal = dog;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&amp;lt;Dog&amp;gt; dogs = &lt;span style="color:#66d9ef">new&lt;/span> List&amp;lt;Dog&amp;gt;();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&amp;lt;Animal&amp;gt; animals = dogs; &lt;span style="color:#75715e">// error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Dog继承自Animal, 所以Dog可以隐式的转化为Animal, 但是List&lt;!-- raw HTML omitted -->与List&lt;!-- raw HTML omitted -->之间没有继承关系, 所以无法隐式转换, 如果想要隐式转换需要如下代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c#" data-lang="c#">&lt;span style="display:flex;">&lt;span>List&amp;lt;Animal&amp;gt; animals = dogs.Select(d =&amp;gt; (Animal)d).ToList();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将小狗列表中的小狗挨个显式转换为Animal.&lt;/p>
&lt;p>所以C#提供了协变的语法糖, 也就是out, 意思是指该泛型可以作为输出返回.
也就是说可以用如下代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c#" data-lang="c#">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Main.cs &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Main()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Dog dog = &lt;span style="color:#66d9ef">new&lt;/span> Dog();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Animal animal = dog;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IEnumerable&amp;lt;Dog&amp;gt; dogs = &lt;span style="color:#66d9ef">new&lt;/span> List&amp;lt;Dog&amp;gt;();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IEnumerable&amp;lt;Animal&amp;gt; animals = dogs;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// IEnumerable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">IEnumerable&lt;/span>&amp;lt;&lt;span style="color:#66d9ef">out&lt;/span> T&amp;gt;: IEnumerable
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为T只能作为结果返回, 所以T不会被修改, 编译器可以帮我们进行强制转换.
但实际上out只是上面强制转换的一个语法糖而已, 实际上反编译的代码依然进行的是强制类型转换.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c#" data-lang="c#">&lt;span style="display:flex;">&lt;span>IEnumerable&amp;lt;Animal&amp;gt; animals = (IEnumerable&amp;lt;Animal&amp;gt;) dogs;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>至于为什么只能作为结果返回而不能作为输入呢?
我们假设:&lt;/p>
&lt;ul>
&lt;li>A ≼ B 意味着 A 是 B 的子类型.&lt;/li>
&lt;li>A → B 指的是以 A 为参数类型, 以 B 为返回值类型的函数类型.&lt;/li>
&lt;li>x : A 意味着 x 的类型为 A.
假设我有如下三种类型:&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>Greyhound ≼ Dog ≼ Animal
&lt;/code>&lt;/pre>&lt;p>问题: 以下哪种类型是 Dog → Dog 的子类型呢？&lt;/p>
&lt;ol>
&lt;li>Greyhound → Greyhound&lt;/li>
&lt;li>Greyhound → Animal&lt;/li>
&lt;li>Animal → Animal&lt;/li>
&lt;li>Animal → Greyhound&lt;/li>
&lt;/ol>
&lt;p>我们假设 f 是一个以 Dog → Dog 为参数的函数, 那么可以这样假设: f : (Dog → Dog) → String&lt;/p>
&lt;p>那么容易回答上述问题:&lt;/p>
&lt;ol>
&lt;li>不是, 因为传入的类型可能是狗的其它自类型但不是灰狗, 这样也是符合函数签名的, 但是答案1就不符合了.&lt;/li>
&lt;li>同上&lt;/li>
&lt;li>不是, 因为有可能 f 在调用完参数之后让它的返回值(Animal)狗叫, 但是并非所有的动物都会狗叫, 所以同样存在符合函数签名但不是答案4的结果.&lt;/li>
&lt;li>是的, 所有的Dog都是Animal, 所以传进去的任何Dog都是符合的, 而所有的Greyhoud都是狗, 也都可以狗叫.&lt;/li>
&lt;/ol>
&lt;p>这样就可以得到我们最初的答案了&amp;mdash;为什么只能作为结果返回而不能作为参数输入, 因为所有的Dog都是Animal, 但是如果作为参数的话, 那么不是所有的Animal都是Dog, 就有可能往IEnumerable&lt;!-- raw HTML omitted -->里传一个Cat, 但这又是符合IEnumerable&lt;!-- raw HTML omitted -->签名的, 所以是不行的.&lt;/p>
&lt;p>而由上面的例子也可以得到, 与协变相反的就是逆变, 也就是超类可以作为泛型参数而不能作为输出结果, 简单的公式为:
(Animal → Greyhound) ≼ (Dog → Dog)&lt;/p>
&lt;p>解释为: 我们允许一个函数类型中, 返回值类型是协变的, 而参数类型是逆变的. 返回值类型是协变的, 意思是 A ≼ B 就意味着 (T → A) ≼ (T → B) . 参数类型是逆变的, 意思是 A ≼ B 就意味着 (B → T) ≼ (A → T)  A 和 B 的位置颠倒过来了, 通俗点协变就是返回值可以是超类, 而逆变则是参数可以是子类.&lt;/p></description></item><item><title>深入Rust枚举</title><link>/post/translation/rust/peeking_inside_a_rust_enum/</link><pubDate>Wed, 13 Jan 2021 11:00:00 +0800</pubDate><guid>/post/translation/rust/peeking_inside_a_rust_enum/</guid><description>&lt;img src="/post/translation/rust/peeking_inside_a_rust_enum/cover.png" alt="Featured image of post 深入Rust枚举" />&lt;blockquote>
&lt;p>本译文译自 &lt;a class="link" href="https://fasterthanli.me/articles/peeking-inside-a-rust-enum" target="_blank" rel="noopener"
>Peeking inside a Rust enum&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h1 id="前言">前言&lt;/h1>
&lt;p>在我最近 &lt;code>Rust Q&amp;amp;A&lt;/code> &lt;code>twitch&lt;/code> 频道里, 有些人提出了一个看起来简单的问题: 为什么 &lt;code>small string&lt;/code> 类型, 像 &lt;code>SmartString&lt;/code> or &lt;code>SmolStr&lt;/code> 和 &lt;code>String&lt;/code> 有着一样的大小, 但是 &lt;code>small vec&lt;/code> 类型, 像 &lt;code>SmallVec&lt;/code> 却要比 &lt;code>Vec&lt;/code> 大?&lt;/p>
&lt;p>我知道我使用了简单作为形容词, 但是事实上要了解这个问题, 我们需要一些背景知识&lt;/p>
&lt;blockquote>
&lt;p>译者: 亿点点&amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;h2 id="这个问题到底是什么">这个问题到底是什么?&lt;/h2>
&lt;p>我最近谈到 &lt;code>Rust&lt;/code> &lt;a class="link" href="https://fasterthanli.me/articles/small-strings-in-rust" target="_blank" rel="noopener"
>small string crates&lt;/a>.&lt;/p>
&lt;p>被这些 &lt;code>crates&lt;/code> 导出的类型可以避免多次内存分配, 并且降低内存使用量. 让我们看一个 &lt;a class="link" href="https://lib.rs/crates/smartstring" target="_blank" rel="noopener"
>smartstring&lt;/a> 的代码作为例子.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> smartstring::{Compact, SmartString};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::mem::size_of_val;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> smart &lt;span style="color:#f92672">=&lt;/span> SmartString::&lt;span style="color:#f92672">&amp;lt;&lt;/span>Compact&lt;span style="color:#f92672">&amp;gt;&lt;/span>::from(&lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(size_of_val(&lt;span style="color:#f92672">&amp;amp;&lt;/span>smart));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> stand &lt;span style="color:#f92672">=&lt;/span> String::from(&lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(size_of_val(&lt;span style="color:#f92672">&amp;amp;&lt;/span>stand));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:6&lt;span style="color:#f92672">]&lt;/span> size_of_val&lt;span style="color:#f92672">(&lt;/span>&amp;amp;smart&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:9&lt;span style="color:#f92672">]&lt;/span> size_of_val&lt;span style="color:#f92672">(&lt;/span>&amp;amp;stand&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">24&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>正如你看到的, 同样也是最初的问题描述的那样, 这两个类型的大小是相同的.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>是的, 这当然不是一个完整的故事, 在这个特别的例子中, &lt;code>smart&lt;/code> 以 &lt;code>inline&lt;/code> 的方式存储它的值(在栈上), 而标准库将值存储在堆上:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>如果我们想知道每个类型到底总共使用了多少内存, 我们可以这样做:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> smart &lt;span style="color:#f92672">=&lt;/span> SmartString::&lt;span style="color:#f92672">&amp;lt;&lt;/span>Compact&lt;span style="color:#f92672">&amp;gt;&lt;/span>::from(&lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(size_of_val(&lt;span style="color:#f92672">&amp;amp;&lt;/span>smart));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> stand &lt;span style="color:#f92672">=&lt;/span> String::from(&lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(size_of_val(&lt;span style="color:#f92672">&amp;amp;&lt;/span>stand) &lt;span style="color:#f92672">+&lt;/span> stand.capacity());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:6&lt;span style="color:#f92672">]&lt;/span> size_of_val&lt;span style="color:#f92672">(&lt;/span>&amp;amp;smart&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:9&lt;span style="color:#f92672">]&lt;/span> size_of_val&lt;span style="color:#f92672">(&lt;/span>&amp;amp;stand&lt;span style="color:#f92672">)&lt;/span> + stand.capacity&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">35&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>典型的, 在 &lt;code>Linux 64-bit&lt;/code> 系统中栈和堆在虚拟地址中的空间相差很远, 这意味着我们如果打印字符串的元数据的地址和内容的地址, 我们就可以看到:&lt;/p>
&lt;ul>
&lt;li>&lt;code>SmartString&lt;/code> 的元数据和内容在相邻的位置.&lt;/li>
&lt;li>&lt;code>String&lt;/code> 的元数据和内容相距很远.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> smartstring::{Compact, SmartString};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> smart &lt;span style="color:#f92672">=&lt;/span> SmartString::&lt;span style="color:#f92672">&amp;lt;&lt;/span>Compact&lt;span style="color:#f92672">&amp;gt;&lt;/span>::from(&lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> smart_meta &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>smart &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> _;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> smart_data &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>smart.as_bytes()[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> _;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!((smart_meta, smart_data));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> stand &lt;span style="color:#f92672">=&lt;/span> String::from(&lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> stand_meta &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>stand &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> _;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> stand_data &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>stand.as_bytes()[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> _;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!((stand_meta, stand_data));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:7&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>smart_meta, smart_data&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x00007ffce4cf4728,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x00007ffce4cf4729,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:12&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>stand_meta, stand_data&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x00007ffce4cf47f8,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x0000555f87686a60,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;p>不! 只有在小于24字节的时候是存储在栈上的, 就和 &lt;code>String&lt;/code> 一样. 我们用稍微长一点的字符串来看看.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> smartstring::{Compact, SmartString};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> input &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Turns out you can blame your tools *and* be a good craftsperson. Who knew?&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> smart &lt;span style="color:#f92672">=&lt;/span> SmartString::&lt;span style="color:#f92672">&amp;lt;&lt;/span>Compact&lt;span style="color:#f92672">&amp;gt;&lt;/span>::from(input);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> smart_meta &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>smart &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> _;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> smart_data &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>smart.as_bytes()[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> _;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!((smart_meta, smart_data));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> stand &lt;span style="color:#f92672">=&lt;/span> String::from(input);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> stand_meta &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>stand &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> _;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> stand_data &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>stand.as_bytes()[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> _;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!((stand_meta, stand_data));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:9&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>smart_meta, smart_data&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x00007ffd460d0268,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x0000555f4636ca30,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:14&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>stand_meta, stand_data&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x00007ffd460d0338,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x0000555f4636cac0,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;然后我们就可以看到这两个类型的内容现在都放在堆上了.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h2 id="一个单词-多种意义">一个单词, 多种意义&lt;/h2>
&lt;p>如果你有着 &lt;code>C/C++/Java/C#&lt;/code> 的语言背景, 一个 &lt;code>enum&lt;/code> 仅仅意味着一个 &lt;code>Integer&lt;/code> 类型, 只是它的值有着自己的意义.&lt;/p>
&lt;p>让我们看一个 &lt;code>C&lt;/code> 的例子:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> Drink {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Water,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Soda,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Juice,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">enum&lt;/span> Drink dri &lt;span style="color:#f92672">=&lt;/span> Soda;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;dri = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, dri);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(dri) = %ld&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(dri));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(int) = %ld&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里, 我们声明了一个枚举类型 &lt;code>enum Drink&lt;/code>, 有三个变体, 不过仅仅是从0开始的数字, 所以我们有 &lt;code>Water = 0&lt;/code>, &lt;code>Soda = 1&lt;/code>, &lt;code>Juice = 2&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ clang -Wall main.c -o main &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ./main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dri &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sizeof&lt;span style="color:#f92672">(&lt;/span>dri&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sizeof&lt;span style="color:#f92672">(&lt;/span>int&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然而我不是很喜欢这个代码, 我不想要额外的限定词, 并且想要我的变体有着自己的命名空间, 但在 &lt;code>C&lt;/code> 里面我们需要自己做这些事:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// this could also be done in two separate declarations
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> Drink {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink_Water,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink_Soda,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink_Juice,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} Drink;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink dri &lt;span style="color:#f92672">=&lt;/span> Drink_Soda;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;dri = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, dri);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(dri) = %ld&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(dri));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(int) = %ld&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ahhh, 好多了. 但是这里仍然有其它的东西我不是特别喜欢, 像是 &lt;code>C&lt;/code> 的 &lt;code>switch&lt;/code>. 下面的代码是错误的:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> Drink {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink_Water,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink_Soda,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink_Juice,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} Drink;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">print_drink&lt;/span>(Drink dri) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (dri) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Drink_Water:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;It&amp;#39;s water!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Drink_Soda:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;It&amp;#39;s soda!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Drink_Juice:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;It&amp;#39;s juice!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_drink(Drink_Soda);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>正确的代码是在每个 &lt;code>case&lt;/code> 语句的结尾都使用 &lt;code>break&lt;/code>. 这是刚起步的开发人员很早就应该了解的事情之一.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>即使我们修复了 &lt;code>switch&lt;/code> 的问题, 还有件我不喜欢 &lt;code>C&lt;/code> 枚举的事情, 那就是没什么可以阻止我传递一个无意义的值:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> Drink {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink_Water,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink_Soda,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink_Juice,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} Drink;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">print_drink&lt;/span>(Drink dri) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (dri) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Drink_Water:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;It&amp;#39;s water!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Drink_Soda:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;It&amp;#39;s soda!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Drink_Juice:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;It&amp;#39;s juice!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_drink(&lt;span style="color:#ae81ff">47&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ clang -Wall main.c -o main &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ./main
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在, 如果我们看看 &lt;code>Rust&lt;/code> 的枚举&amp;hellip; 这是个完全不同的事情.&lt;/p>
&lt;p>让我们尽量写一个相同的程序.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::mem::size_of_val;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">Drink&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Water,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Soda,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Juice,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> dri &lt;span style="color:#f92672">=&lt;/span> Drink::Water;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(size_of_val(&lt;span style="color:#f92672">&amp;amp;&lt;/span>dri));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(dri &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">u32&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>warning: variant is never constructed: &lt;span style="color:#e6db74">`&lt;/span>Soda&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --&amp;gt; src/main.rs:5:5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">5&lt;/span> | Soda,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | ^^^^
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> note: &lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#75715e">#[warn(dead_code)]` on by default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>warning: variant is never constructed: &lt;span style="color:#e6db74">`&lt;/span>Juice&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --&amp;gt; src/main.rs:6:5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6&lt;/span> | Juice,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | ^^^^^
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>warning: &lt;span style="color:#ae81ff">2&lt;/span> warnings emitted
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:11&lt;span style="color:#f92672">]&lt;/span> size_of_val&lt;span style="color:#f92672">(&lt;/span>&amp;amp;dri&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:12&lt;span style="color:#f92672">]&lt;/span> dri as u32 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么我们明显地得到了什么好处呢?&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>对的, 但那并不是全部! 编译器警告我们有没有使用的变体, 并且我们可以简单地给这个枚举派生一个 &lt;code>Debug&lt;/code> trait 的实现:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[derive(Debug)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">Drink&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Water,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Soda,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Juice,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_drink(&lt;span style="color:#f92672">&amp;amp;&lt;/span>Drink::Water);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_drink(&lt;span style="color:#f92672">&amp;amp;&lt;/span>Drink::Juice);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_drink(&lt;span style="color:#f92672">&amp;amp;&lt;/span>Drink::Soda);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">print_drink&lt;/span>(dri: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Drink&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;{:?}&amp;#34;&lt;/span>, dri);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Water
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Juice
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Soda
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;并且假如我们不那么做, 我们也能使用 &lt;code>match&lt;/code> 而不是 &lt;code>switch&lt;/code>, &lt;code>match&lt;/code> 会检查是否匹配了枚举的所有变体, 举个例子, 下面的代码不能通过编译:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">print_drink&lt;/span>(dri: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Drink&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">match&lt;/span> dri {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink::Water &lt;span style="color:#f92672">=&amp;gt;&lt;/span> println!(&lt;span style="color:#e6db74">&amp;#34;it&amp;#39;s water!&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink::Soda &lt;span style="color:#f92672">=&amp;gt;&lt;/span> println!(&lt;span style="color:#e6db74">&amp;#34;it&amp;#39;s soda!&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>error&lt;span style="color:#f92672">[&lt;/span>E0004&lt;span style="color:#f92672">]&lt;/span>: non-exhaustive patterns: &lt;span style="color:#e6db74">`&lt;/span>&amp;amp;Juice&lt;span style="color:#e6db74">`&lt;/span> not covered
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --&amp;gt; src/main.rs:15:11
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span> | / enum Drink &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span> | | Water,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span> | | Soda,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">5&lt;/span> | | Juice,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | | ----- not covered
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6&lt;/span> | | &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | |_- &lt;span style="color:#e6db74">`&lt;/span>Drink&lt;span style="color:#e6db74">`&lt;/span> defined here
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">15&lt;/span> | match dri &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | ^^^ pattern &lt;span style="color:#e6db74">`&lt;/span>&amp;amp;Juice&lt;span style="color:#e6db74">`&lt;/span> not covered
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> note: the matched value is of type &lt;span style="color:#e6db74">`&lt;/span>&amp;amp;Drink&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编译器给出了两种可能的方法来修复这个问题, 或是添加一个通配符:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">print_drink&lt;/span>(dri: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Drink&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">match&lt;/span> dri {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink::Water &lt;span style="color:#f92672">=&amp;gt;&lt;/span> println!(&lt;span style="color:#e6db74">&amp;#34;it&amp;#39;s water!&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink::Soda &lt;span style="color:#f92672">=&amp;gt;&lt;/span> println!(&lt;span style="color:#e6db74">&amp;#34;it&amp;#39;s soda!&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _ &lt;span style="color:#f92672">=&amp;gt;&lt;/span> println!(&lt;span style="color:#e6db74">&amp;#34;it&amp;#39;s something we don&amp;#39;t know about!&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者是覆盖到所有的情况:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">print_drink&lt;/span>(dri: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Drink&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">match&lt;/span> dri {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink::Water &lt;span style="color:#f92672">=&amp;gt;&lt;/span> println!(&lt;span style="color:#e6db74">&amp;#34;it&amp;#39;s water!&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink::Soda &lt;span style="color:#f92672">=&amp;gt;&lt;/span> println!(&lt;span style="color:#e6db74">&amp;#34;it&amp;#39;s soda!&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink::Juice &lt;span style="color:#f92672">=&amp;gt;&lt;/span> println!(&lt;span style="color:#e6db74">&amp;#34;it&amp;#39;s juice!&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;p>讲到 &lt;code>match&lt;/code>, 它也是一个表达式, 所以我们也可以这么做:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">print_drink&lt;/span>(dri: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Drink&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;{}&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">match&lt;/span> dri {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink::Water &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;it&amp;#39;s water!&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink::Soda &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;it&amp;#39;s soda!&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink::Juice &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;it&amp;#39;s juice!&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>尽管就我个人而言, 我可能更倾向于这样写:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">print_drink&lt;/span>(dri: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Drink&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">match&lt;/span> dri {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink::Water &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;water&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink::Soda &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;soda&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink::Juice &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;juice&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;it&amp;#39;s {}!&amp;#34;&lt;/span>, name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>让我们想想, 我们还抱怨了 &lt;code>C&lt;/code> 枚举的什么地方?&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>对! 让我们试试:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_drink(&lt;span style="color:#f92672">&amp;amp;&lt;/span>Drink::Water);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_drink(&lt;span style="color:#f92672">&amp;amp;&lt;/span>Drink::Juice);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_drink(&lt;span style="color:#f92672">&amp;amp;&lt;/span>Drink::Soda);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> val: &lt;span style="color:#a6e22e">Drink&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> Drink;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_drink(&lt;span style="color:#f92672">&amp;amp;&lt;/span>val);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>error&lt;span style="color:#f92672">[&lt;/span>E0605&lt;span style="color:#f92672">]&lt;/span>: non-primitive cast: &lt;span style="color:#e6db74">`&lt;/span>i32&lt;span style="color:#e6db74">`&lt;/span> as &lt;span style="color:#e6db74">`&lt;/span>Drink&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --&amp;gt; src/main.rs:13:22
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">13&lt;/span> | let val: Drink &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span> as Drink;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | ^^^^^^^^^^
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> note: an &lt;span style="color:#e6db74">`&lt;/span>as&lt;span style="color:#e6db74">`&lt;/span> expression can only be used to convert between primitive types. Consider using the &lt;span style="color:#e6db74">`&lt;/span>From&lt;span style="color:#e6db74">`&lt;/span> traitt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ah, 这看起来并不能工作! 然而在某些情形中我们可能需要这么做, 我们可以解析一个二进制格式, 并且已经确保检查这个数字类型的值在这个枚举中是有意义的 - 那么我们可以使用 &lt;code>transmute&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[allow(dead_code)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">Drink&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Water,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Soda,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Juice,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> juice_from_binary_format &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> val: &lt;span style="color:#a6e22e">Drink&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">unsafe&lt;/span> { std::mem::transmute(juice_from_binary_format &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>) };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_drink(&lt;span style="color:#f92672">&amp;amp;&lt;/span>val);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">print_drink&lt;/span>(dri: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Drink&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">match&lt;/span> dri {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink::Water &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;water&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink::Soda &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;soda&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink::Juice &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;juice&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;it&amp;#39;s {}!&amp;#34;&lt;/span>, name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>it&lt;span style="color:#ae81ff">\&amp;#39;&lt;/span>s juice!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当前, 通常我们希望给这个不安全操作提供一个安全的接口:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::convert::{TryFrom, TryInto};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[allow(dead_code)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">Drink&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Water,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Soda,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Juice,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> TryFrom&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">i32&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> Drink {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Error&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;#39;&lt;/span>static &lt;span style="color:#66d9ef">str&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">try_from&lt;/span>(x: &lt;span style="color:#66d9ef">i32&lt;/span>) -&amp;gt; Result&lt;span style="color:#f92672">&amp;lt;&lt;/span>Self, Self::Error&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">match&lt;/span> x {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">..=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> Ok(&lt;span style="color:#66d9ef">unsafe&lt;/span> { std::mem::transmute(x &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>) }),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _ &lt;span style="color:#f92672">=&amp;gt;&lt;/span> Err(&lt;span style="color:#e6db74">&amp;#34;invalid Drink value&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> juice_from_binary_format: &lt;span style="color:#66d9ef">i32&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> val: &lt;span style="color:#a6e22e">Drink&lt;/span> &lt;span style="color:#f92672">=&lt;/span> juice_from_binary_format.try_into().unwrap();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_drink(&lt;span style="color:#f92672">&amp;amp;&lt;/span>val);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> invalid_value: &lt;span style="color:#66d9ef">i32&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> val: &lt;span style="color:#a6e22e">Drink&lt;/span> &lt;span style="color:#f92672">=&lt;/span> invalid_value.try_into().unwrap();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_drink(&lt;span style="color:#f92672">&amp;amp;&lt;/span>val);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>it&lt;span style="color:#ae81ff">\&amp;#39;&lt;/span>s juice!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>thread &lt;span style="color:#e6db74">&amp;#39;main&amp;#39;&lt;/span> panicked at &lt;span style="color:#e6db74">&amp;#39;called `Result::unwrap()` on an `Err` value: &amp;#34;invalid Drink value&amp;#34;&amp;#39;&lt;/span>, src/main.rs:27:22
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>note: run with &lt;span style="color:#e6db74">`&lt;/span>RUST_BACKTRACE&lt;span style="color:#f92672">=&lt;/span>1&lt;span style="color:#e6db74">`&lt;/span> environment variable to display a backtrace
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>并且我们的快乐还并不止步于此.&lt;/p>
&lt;p>还记得我们之前打印我们的枚举大小么? 让我们来 &lt;a class="link" href="https://en.wikipedia.org/wiki/Memory_refresh" target="_blank" rel="noopener"
>refresh out memory&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::mem::size_of;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[allow(dead_code)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">Drink&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Water,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Soda,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Juice,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(size_of::&lt;span style="color:#f92672">&amp;lt;&lt;/span>Drink&lt;span style="color:#f92672">&amp;gt;&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:11&lt;span style="color:#f92672">]&lt;/span> size_of::&amp;lt;Drink&amp;gt;&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>单位是字节, 所以这里显示我们的枚举只有一个字节.&lt;/p>
&lt;p>让我们与 &lt;code>C&lt;/code> 的对比下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> Drink {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink_Water,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink_Soda,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Drink_Juice,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} Drink;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(Drink) = %ld&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(Drink));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ clang -Wall main.c -o main &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ./main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sizeof&lt;span style="color:#f92672">(&lt;/span>Drink&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里枚举有足足4个字节, 所以我们可以近似地说 &lt;code>Rust&lt;/code> 的枚举是 &lt;code>u8&lt;/code>, &lt;code>C&lt;/code> 枚举是 &lt;code>u32&lt;/code>.&lt;/p>
&lt;p>如果 &lt;code>Rust&lt;/code> 的枚举超过256个变体呢?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::mem::size_of;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[allow(dead_code)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">Drink&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Variant0,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Variant1,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Variant2,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Variant3,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Variant4,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// (etc.)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Variant252,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Variant253,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Variant254,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Variant255,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Variant256,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(size_of::&lt;span style="color:#f92672">&amp;lt;&lt;/span>Drink&lt;span style="color:#f92672">&amp;gt;&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>译者: &lt;a class="link" href="https://en.wikipedia.org/wiki/Off-by-one_error#Fencepost_error" target="_blank" rel="noopener"
>counting the fences, when you should be counting the posts.&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>不管怎样, 我们先看看现在的枚举大小?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:265&lt;span style="color:#f92672">]&lt;/span> size_of::&amp;lt;Drink&amp;gt;&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>2个字节! 看起来又像是 &lt;code>u16&lt;/code>.&lt;/p>
&lt;p>当然看起来像并不是一个专业术语 - 专业术语应该是 &amp;ldquo;representation&amp;rdquo;. 一个 &lt;code>Rust&lt;/code> 枚举是对特定整数类型的抽象.&lt;/p>
&lt;p>让我们看看我们原来的 &lt;code>Drink&lt;/code>:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>概念上, &lt;code>Drink&lt;/code> 只有三个有意义的值, 但是它的表现是一个 &lt;code>u8&lt;/code>, 能持有256个不同的值. 这就是你为什么总是能把 &lt;code>Drink&lt;/code> 转为 &lt;code>u8&lt;/code>, 但是把 &lt;code>u8&lt;/code> 转为 &lt;code>Drink&lt;/code> 却是一个容易出错的操作.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>对的! 潜在的 &lt;code>Drink&lt;/code> 作为一个 &lt;code>u8&lt;/code> 应该总是为0, 1或者2, 这被称为不变体(invariant). 如果我们破坏了这个不变体, 我们的代码就不是那么健壮了.&lt;/p>
&lt;p>在 &lt;code>Rust&lt;/code>, 破坏不变体需要使用 &lt;code>unsafe&lt;/code> 代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::mem::transmute;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[allow(dead_code)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[derive(Debug, PartialEq)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">Drink&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Water,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Soda,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Juice,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// woops! that&amp;#39;s unsound.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> d: &lt;span style="color:#a6e22e">Drink&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">unsafe&lt;/span> { transmute(&lt;span style="color:#ae81ff">15_&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>) };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(&lt;span style="color:#f92672">&amp;amp;&lt;/span>d);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(d &lt;span style="color:#f92672">==&lt;/span> Drink::Juice);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:14&lt;span style="color:#f92672">]&lt;/span> &amp;amp;d &lt;span style="color:#f92672">=&lt;/span> Juice
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:15&lt;span style="color:#f92672">]&lt;/span> d &lt;span style="color:#f92672">==&lt;/span> Drink::Juice &lt;span style="color:#f92672">=&lt;/span> false
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>问题的关键在于不是所有的事情都可以交由计算机去做(意味着需要你自己去做), 可以使用 &lt;code>Rust&lt;/code> 的模型检查. 因为种种原因, 你仍然需要 &lt;code>unsafe&lt;/code> 代码.&lt;/p>
&lt;p>这并不意味有着两种 &lt;code>Rust&lt;/code>, 仅仅意味着不同的风险以及不同的可信任等级.&lt;/p>
&lt;p>如果你相信 &lt;code>Rust&lt;/code> 核心团队可以根除标准库中的不健全之处, 那么你甚至就可以让团队中的初级人员在此基础上编写受 &lt;code>Rust&lt;/code> 安全保证的 &lt;code>safe code&lt;/code>.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="rust枚举不止于此">Rust枚举不止于此&lt;/h2>
&lt;p>Cool bear早先说 &lt;code>SmartString&lt;/code> 有着买一送一的处理字符串的方式. Cool bear是对的!&lt;/p>
&lt;p>让我们来自己做一个 &lt;code>two-for-one&lt;/code> 的处理方式:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">UserID&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Number(&lt;span style="color:#66d9ef">u64&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(String),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>UserID&lt;/code> 是一个聚合类型, 一个 &lt;code>UserID&lt;/code> 的值可以是一个 &lt;code>UserID::Number&lt;/code> 变体, 或是一个 &lt;code>UserID::Text&lt;/code> 变体.如果我们想对它的内容做些操作, 我们需要用模式匹配:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">print_user_id&lt;/span>(id: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">UserID&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">match&lt;/span> id {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UserID::Number(n) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;user id number {}&amp;#34;&lt;/span>, n);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UserID::Text(s) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> println!(&lt;span style="color:#e6db74">&amp;#34;user id {}&amp;#34;&lt;/span>, s),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>希望你对这个用法很熟悉, 我们在不久前刚提到过这个用法.&lt;/p>
&lt;p>让我们进行一次打印操作:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_user_id(&lt;span style="color:#f92672">&amp;amp;&lt;/span>UserID::Number(&lt;span style="color:#ae81ff">79&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_user_id(&lt;span style="color:#f92672">&amp;amp;&lt;/span>UserID::Text(&lt;span style="color:#e6db74">&amp;#34;fh99a73gbh8&amp;#34;&lt;/span>.into()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>user id number &lt;span style="color:#ae81ff">79&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>user id fh99a73gbh8
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们在这文章之前看到过另一个聚合类型, 然后我们实现 &lt;code>TryInto&lt;/code>, 我们会返回 &lt;code>Result&amp;lt;T, E&amp;gt;&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> TryFrom&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">i32&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> Drink {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Error&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;#39;&lt;/span>static &lt;span style="color:#66d9ef">str&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">try_from&lt;/span>(x: &lt;span style="color:#66d9ef">i32&lt;/span>) -&amp;gt; Result&lt;span style="color:#f92672">&amp;lt;&lt;/span>Self, Self::Error&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// omitted
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Result&lt;/code> 值是一个枚举, 它实际是这样定义的:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> Result&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, E&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">/// Contains the success value
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span> Ok(T),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">/// Contains the error value
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span> Err(E),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>让我们返回看我们的 &lt;code>UserID&lt;/code> 枚举:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">UserID&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Number(&lt;span style="color:#66d9ef">u64&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(String),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>它的大小是多少呢? 如果我们尝试在 &lt;code>C&lt;/code> 里模拟实现一个 &lt;code>Rust&lt;/code> 的枚举, 它将会看起来如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdint.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> UserIDKind {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UserIDKind_Number,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UserIDKind_Text,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> UserID {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">enum&lt;/span> UserIDKind kind;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> number;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>text;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>尽管我们只需要两个变体, 但我们需要三个属性, 以让我们知道我们现在处理的是哪一个变体.&lt;/p>
&lt;p>举个例子, 在 &lt;code>print_user_id&lt;/code>, 我们应该使用 &lt;code>switch&lt;/code> 来处理我们使用的是 &lt;code>Number&lt;/code> 变体还是 &lt;code>Text&lt;/code> 变体:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">print_user_id&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> UserID&lt;span style="color:#f92672">*&lt;/span> id) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (id&lt;span style="color:#f92672">-&amp;gt;&lt;/span>kind) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> UserIDKind_Number:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;user id number %lu&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, id&lt;span style="color:#f92672">-&amp;gt;&lt;/span>number);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> UserIDKind_Text:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;user id %s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, id&lt;span style="color:#f92672">-&amp;gt;&lt;/span>text);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>并且当我们初始化 &lt;code>UserID&lt;/code> 结构体的时候, 我们仅需要初始化我们需要的属性, 并且设置它的 &lt;code>kind&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> UserID a &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .kind &lt;span style="color:#f92672">=&lt;/span> UserIDKind_Number,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .number &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">79&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_user_id(&lt;span style="color:#f92672">&amp;amp;&lt;/span>a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> UserID b &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .kind &lt;span style="color:#f92672">=&lt;/span> UserIDKind_Text,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .text &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fh99a73gbh8&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_user_id(&lt;span style="color:#f92672">&amp;amp;&lt;/span>b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是可以工作的:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ clang -Wall main.c -o main &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ./main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>user id number &lt;span style="color:#ae81ff">79&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>user id fh99a73gbh8
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但这并不理想, 这并没有像 &lt;code>Rust&lt;/code> 那样的安全保证, 我们无法阻止你创建一个 &lt;code>Text&lt;/code> 而 &lt;code>kind&lt;/code> 是一个 &lt;code>Number&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> UserID woops &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .kind &lt;span style="color:#f92672">=&lt;/span> UserIDKind_Number,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .text &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;woops&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_user_id(&lt;span style="color:#f92672">&amp;amp;&lt;/span>woops);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ clang -Wall main.c -o main &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ./main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>user id number &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们实现了一个不完善的抽象 - 我们可以直接访问它的底层表示, 并且以不合理的方式操作它.&lt;/p>
&lt;p>举个例子, 如果我们的 &lt;code>UserID&lt;/code> 是使用 &lt;code>malloc&lt;/code> 在堆上分配的并且也没有清零, 那会发生什么?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> UserID &lt;span style="color:#f92672">*&lt;/span>woops &lt;span style="color:#f92672">=&lt;/span> malloc(&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> UserID));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> woops&lt;span style="color:#f92672">-&amp;gt;&lt;/span>kind &lt;span style="color:#f92672">=&lt;/span> UserIDKind_Text;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> woops&lt;span style="color:#f92672">-&amp;gt;&lt;/span>number &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">79&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_user_id(woops);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在debug模式编译下, 它不会很糟糕:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ clang -Wall main.c -o main &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ./main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>user id &lt;span style="color:#f92672">(&lt;/span>null&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然而在release模式编译下, 随着优化的打开, 将会发生很有趣的现象:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ clang -O3 -Wall main.c -o main &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ./main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>user id &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ clang -O3 -Wall main.c -o main &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ./main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>user id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ clang -O3 -Wall main.c -o main &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ./main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>user id m
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从哪里来的? 谁知道呢. 但是它没有导致段错误 - 这意味着它从程序的其他部分读取数据. 在一个大型程序中, 那可能是用户的隐私数据, 而这个漏洞就可能被用来窃取隐私数据.&lt;/p>
&lt;p>不过这并不是一篇讲 &lt;code>C&lt;/code> 有多危险的文章,&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&amp;hellip;emmm, 让我们看看还有什么不好的地方.&lt;/p>
&lt;p>首先让我们看看我们 &lt;code>struct UserID&lt;/code> 的大小:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ clang -Wall main.c -o main &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ./main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sizeof&lt;span style="color:#f92672">(&lt;/span>struct UserID&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">24&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>24字节. 这只是一个结构体, 所以我们可以自己计算出来:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(struct UserID) = %ld&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> UserID));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%ld + %ld + %ld = %ld&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">enum&lt;/span> UserIDKind), &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">uint64_t&lt;/span>), &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">enum&lt;/span> UserIDKind) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">uint64_t&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ clang -Wall main.c -o main &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ./main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sizeof&lt;span style="color:#f92672">(&lt;/span>struct UserID&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span> + &lt;span style="color:#ae81ff">8&lt;/span> + 8 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Oh, woops. 我们哪里做错了?&lt;/p>
&lt;p>淡定, 这是因为在 &lt;code>kind&lt;/code> 和 &lt;code>number&lt;/code> 之间有 &lt;code>padding&lt;/code>, 以使我们的属性是64位对齐的(后面会详细说明).&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>这就是为什么我们的 &lt;code>UserID&lt;/code> 结构体是3*8=24个字节.&lt;/p>
&lt;p>当前, 我们可以命令编译器不要做对齐, 然后在计算一次:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">__attribute__&lt;/span>((packed)) UserID {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">enum&lt;/span> UserIDKind kind;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> number;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>text;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ clang -Wall main.c -o main &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ./main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sizeof&lt;span style="color:#f92672">(&lt;/span>struct UserID&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span> + &lt;span style="color:#ae81ff">8&lt;/span> + 8 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;p>现在让我们看看 &lt;code>Rust&lt;/code> 中 &lt;code>UserID&lt;/code> 枚举的大小:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::mem::size_of;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[allow(dead_code)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">UserID&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Number(&lt;span style="color:#66d9ef">u64&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(String),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(size_of::&lt;span style="color:#f92672">&amp;lt;&lt;/span>UserID&lt;span style="color:#f92672">&amp;gt;&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:10&lt;span style="color:#f92672">]&lt;/span> size_of::&amp;lt;UserID&amp;gt;&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Oh, uh, 这太大了. 太大了. 我不认为 &lt;code>Rust&lt;/code> 的 &lt;code>String&lt;/code> 类型只是一个单纯的指向空字符结尾的指针(c-style). 我认为 &lt;a class="link" href="https://fasterthanli.me/articles/working-with-strings-in-rust" target="_blank" rel="noopener"
>it&amp;rsquo;s a little more involved&lt;/a>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::{mem::size_of, os::raw::c_char};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[allow(dead_code)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">UserID&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Number(&lt;span style="color:#66d9ef">u64&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> c_char),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(size_of::&lt;span style="color:#f92672">&amp;lt;&lt;/span>UserID&lt;span style="color:#f92672">&amp;gt;&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:10&lt;span style="color:#f92672">]&lt;/span> size_of::&amp;lt;UserID&amp;gt;&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ok, 这看起来合理多了. 并且比 &lt;code>C&lt;/code> 版本要小很多. 这里是为什么呢?&lt;/p>
&lt;p>首先, 这里必须有一个等同于上面写的 &lt;code>C&lt;/code> 语言的 &lt;code>kind&lt;/code> 一样作用的东西. 在 &lt;code>Rust&lt;/code> 中, 它叫做 &lt;code>discriminant&lt;/code>(判别符). 这是一个 &amp;ldquo;tagged unions&amp;rdquo; 中的 &amp;ldquo;tag&amp;rdquo;.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&amp;hellip;&amp;hellip;我猜它应该是通过重叠 &lt;code>*const c_char&lt;/code> 和 &lt;code>u64&lt;/code> 来节省空间, 因为它们只能有一个是有效的, 不能同时存在: 这也是为什么称他们为 &amp;ldquo;disjoint union&amp;rdquo;.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>所以总共只有16个字节.&lt;/p>
&lt;p>我们能做相同的事情在 &lt;code>C&lt;/code> 里面吗? 这当然可以! &lt;code>union&lt;/code> 关键字就是起着类似作用的. 这就像是一个结构体, 只是所有内容的内存地址是重叠的, 它的大小是它内部最大的那一个 (或多或少依然是需要考虑对齐的).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> UserID {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">enum&lt;/span> UserIDKind kind;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">union&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> number;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>text;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(struct UserID) = %ld&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> UserID));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ clang -Wall main.c -o main &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ./main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sizeof&lt;span style="color:#f92672">(&lt;/span>struct UserID&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们得到了与 &lt;code>Rust&lt;/code> 相同的结果.&lt;/p>
&lt;p>进一步的, 我们可以把 &lt;code>UserIDKind&lt;/code> 改成一个 &lt;code>uint8_t&lt;/code>(在64位计算机, &lt;code>clang 10&lt;/code>作为编译器的情况下它是4个字节):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> UserID {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> kind;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">union&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> number;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>text;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ clang -Wall main.c -o main &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ./main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sizeof&lt;span style="color:#f92672">(&lt;/span>struct UserID&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> 16;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Mhhhh好像没发生什么变化&amp;hellip;&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>对的, 让我们再次 &lt;code>packing&lt;/code> 我们的结构体:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">__attribute__&lt;/span>((packed)) UserID {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> kind;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">union&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> number;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>text;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ clang -Wall main.c -o main &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ./main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sizeof&lt;span style="color:#f92672">(&lt;/span>struct UserID&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>只有9个字节了! 现在它压缩了.&lt;/p>
&lt;p>我们可以在 &lt;code>Rust&lt;/code> 中做类似的事情吗? &lt;code>Rust&lt;/code> 默认是以属性做适应性对齐的, 如果我们有一个 &lt;code>u8&lt;/code> and &lt;code>u64&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Foo&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bar: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> baz: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(size_of::&lt;span style="color:#f92672">&amp;lt;&lt;/span>Foo&lt;span style="color:#f92672">&amp;gt;&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;它增长到了16个字节&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:16&lt;span style="color:#f92672">]&lt;/span> size_of::&amp;lt;Foo&amp;gt;&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是, 像 &lt;code>C&lt;/code> 一样, 如果我们友好地要求, &lt;code>Rust&lt;/code> 也可以 &lt;code>pack&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[repr(packed)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Foo&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bar: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> baz: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:17&lt;span style="color:#f92672">]&lt;/span> size_of::&amp;lt;Foo&amp;gt;&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是如果在枚举上呢?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[repr(packed)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">UserID&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Number(&lt;span style="color:#66d9ef">u64&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> c_char),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>error&lt;span style="color:#f92672">[&lt;/span>E0517&lt;span style="color:#f92672">]&lt;/span>: attribute should be applied to struct or union
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --&amp;gt; src/main.rs:4:8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span> | &lt;span style="color:#75715e">#[repr(packed)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | ^^^^^^
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">5&lt;/span> | / enum UserID &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6&lt;/span> | | Number&lt;span style="color:#f92672">(&lt;/span>u64&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">7&lt;/span> | | Text&lt;span style="color:#f92672">(&lt;/span>*const c_char&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">8&lt;/span> | | &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | |_- not a struct or union
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们不能 &lt;code>pack&lt;/code>. 这之前已经 &lt;a class="link" href="https://github.com/rust-lang/rust/issues/42547" target="_blank" rel="noopener"
>讨论&lt;/a> 过了, 也有 &lt;a class="link" href="https://github.com/rust-lang/rfcs/issues/1230" target="_blank" rel="noopener"
>讨论其它奇异的枚举布局优化的方案&lt;/a>, 但是现在, 还不能那么做.&lt;/p>
&lt;p>然而显然, &lt;code>smartstring&lt;/code> 就是那么做的.&lt;/p>
&lt;p>当一个 &lt;code>SmartString&lt;/code> 存在堆里的时候(这是一个 &lt;code>boxed&lt;/code> 变体), 它是24字节, 就像 &lt;code>String&lt;/code> 一样.&lt;/p>
&lt;p>但是如果我们尝试做一个我们自己的 &lt;code>smartstring&lt;/code>, 使用 &lt;code>Rust&lt;/code> 的枚举, 我们甚至无法接近它的大小:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::mem::size_of;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[allow(dead_code)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">SmartString&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Boxed(String),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Inline([&lt;span style="color:#66d9ef">u8&lt;/span>; &lt;span style="color:#ae81ff">24&lt;/span>]),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(size_of::&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(size_of::&lt;span style="color:#f92672">&amp;lt;&lt;/span>[&lt;span style="color:#66d9ef">u8&lt;/span>; &lt;span style="color:#ae81ff">24&lt;/span>]&lt;span style="color:#f92672">&amp;gt;&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(size_of::&lt;span style="color:#f92672">&amp;lt;&lt;/span>SmartString&lt;span style="color:#f92672">&amp;gt;&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:10&lt;span style="color:#f92672">]&lt;/span> size_of::&amp;lt;String&amp;gt;&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:11&lt;span style="color:#f92672">]&lt;/span> size_of::&amp;lt;&lt;span style="color:#f92672">[&lt;/span>u8; 24&lt;span style="color:#f92672">]&lt;/span>&amp;gt;&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:12&lt;span style="color:#f92672">]&lt;/span> size_of::&amp;lt;SmartString&amp;gt;&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里有件事是我们可以做的, 既然 &lt;code>Rust&lt;/code> 不允许我们打包它的枚举, 那我们就做一个自己的枚举.&lt;/p>
&lt;h2 id="写一个自己的枚举">写一个自己的枚举&lt;/h2>
&lt;p>首先, 我们不能使用 &lt;a class="link" href="https://doc.rust-lang.org/reference/items/unions.html" target="_blank" rel="noopener"
>Rust unions&lt;/a>, 因为它只支持 &lt;code>Copy&lt;/code> 和非 &lt;code>Drop&lt;/code> 类型.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::mem::size_of;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[allow(dead_code)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[repr(packed)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">SmartString&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> discriminant: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data: [&lt;span style="color:#66d9ef">u8&lt;/span>; &lt;span style="color:#ae81ff">24&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(size_of::&lt;span style="color:#f92672">&amp;lt;&lt;/span>SmartString&lt;span style="color:#f92672">&amp;gt;&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:11&lt;span style="color:#f92672">]&lt;/span> size_of::&amp;lt;SmartString&amp;gt;&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">25&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看! 25个字节. 这是我们目前最好的预想了.&lt;/p>
&lt;p>但是实际上还没做任何事 - 我们只是存了25个字节在结构体里.&lt;/p>
&lt;p>我们需要想出一个方法来保存我们的变体:&lt;/p>
&lt;ul>
&lt;li>boxed: a String&lt;/li>
&lt;li>inline: some utf-8 bytes, and I guess a length?&lt;/li>
&lt;/ul>
&lt;p>在 &amp;ldquo;inline&amp;rdquo; 变体时我们不能存大于24个字节的内容, 所以我们可以使用一个 &lt;code>u8&lt;/code> 来表示长度, 实际像下面所示:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Inline&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> len: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data: [&lt;span style="color:#66d9ef">u8&lt;/span>; &lt;span style="color:#ae81ff">23&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后, 为了确保我们这几个类型实际上有着相同的大小, 我们使用 &lt;a class="link" href="https://lib.rs/crates/static_assertions" target="_blank" rel="noopener"
>static_assertions&lt;/a> crate:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> static_assertions::&lt;span style="color:#f92672">*&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::mem::size_of;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[allow(dead_code)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[repr(packed)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">SmartString&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> discriminant: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data: [&lt;span style="color:#66d9ef">u8&lt;/span>; &lt;span style="color:#ae81ff">24&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[allow(dead_code)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Inline&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> len: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data: [&lt;span style="color:#66d9ef">u8&lt;/span>; &lt;span style="color:#ae81ff">23&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>assert_eq_size&lt;span style="color:#f92672">!&lt;/span>(String, Inline);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(size_of::&lt;span style="color:#f92672">&amp;lt;&lt;/span>SmartString&lt;span style="color:#f92672">&amp;gt;&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo check
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Finished dev &lt;span style="color:#f92672">[&lt;/span>unoptimized + debuginfo&lt;span style="color:#f92672">]&lt;/span> target&lt;span style="color:#f92672">(&lt;/span>s&lt;span style="color:#f92672">)&lt;/span> in 0.00s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Good, 要确保足够傻瓜, 因为我们将要写很多 &lt;code>unsafe&lt;/code> 代码, 我们甚至能按照 &lt;code>String&lt;/code> 的大小来定义我们的 &lt;code>Inline&lt;/code>, 这个 &amp;ldquo;crate&amp;rdquo; 就可以帮忙检查我们的 &lt;code>Inline&lt;/code> 和 &lt;code>String&lt;/code> 大小相同.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> static_assertions::&lt;span style="color:#f92672">*&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::mem::size_of;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> VARIANT_SIZE: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> std::mem::size_of::&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[allow(dead_code)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[repr(packed)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">SmartString&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> discriminant: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data: [&lt;span style="color:#66d9ef">u8&lt;/span>; VARIANT_SIZE],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[allow(dead_code)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Inline&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> len: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data: [&lt;span style="color:#66d9ef">u8&lt;/span>; VARIANT_SIZE &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>assert_eq_size&lt;span style="color:#f92672">!&lt;/span>(String, Inline);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(size_of::&lt;span style="color:#f92672">&amp;lt;&lt;/span>SmartString&lt;span style="color:#f92672">&amp;gt;&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Okay, 现在让我们实现我们的手动枚举. 首先让它能够被构建.&lt;/p>
&lt;p>我们仅使用了 &lt;code>[u8; VARIANT_SIZE]&lt;/code> 来保留 &lt;code>VARIANT_SIZE&lt;/code> 字节 - 如果我们真的想要往里面存一点东西, 我们将会用一个 &lt;code>*mut&lt;/code> 指针指向它, 然后把它转型为我们所需要的:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> SmartString {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">new_boxed&lt;/span>(s: String) -&amp;gt; &lt;span style="color:#a6e22e">Self&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Self::new(&lt;span style="color:#ae81ff">0&lt;/span>, s)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">new_inline&lt;/span>() -&amp;gt; &lt;span style="color:#a6e22e">Self&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Self::new(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Inline {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> len: &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data: Default::default(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">new&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>(discriminant: &lt;span style="color:#66d9ef">u8&lt;/span>, data: &lt;span style="color:#a6e22e">T&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">Self&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> Self {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> discriminant,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data: Default::default(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> ptr: &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> T &lt;span style="color:#f92672">=&lt;/span> res.data.as_mut_ptr().cast();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> { ptr.write_unaligned(data) };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们现在可以在我们的 &lt;code>SmartString&lt;/code> 构建这两种变体:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> boxed &lt;span style="color:#f92672">=&lt;/span> SmartString::new_boxed(&lt;span style="color:#e6db74">&amp;#34;This is a longer string, would not fit inline&amp;#34;&lt;/span>.into());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> inline &lt;span style="color:#f92672">=&lt;/span> SmartString::new_inline();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除此之外我们目前也不能对它做其它事情了.&lt;/p>
&lt;p>让我们把它变得有用点, 例如, 从它获取一个 &lt;code>&amp;amp;str&lt;/code> 切片:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> AsRef&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> SmartString {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">as_ref&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self) -&amp;gt; &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">match&lt;/span> self.discriminant {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s: &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> ManuallyDrop&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">=&lt;/span> self.data.as_ptr().cast();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> tmp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">unsafe&lt;/span> { s.read_unaligned() };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> { &lt;span style="color:#f92672">&amp;amp;*&lt;/span>(tmp.as_ref() &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">str&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s: &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> Inline &lt;span style="color:#f92672">=&lt;/span> self.data.as_ptr().cast();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> slice &lt;span style="color:#f92672">=&lt;/span> std::slice::from_raw_parts((&lt;span style="color:#f92672">*&lt;/span>s).data.as_ptr(), (&lt;span style="color:#f92672">*&lt;/span>s).len &lt;span style="color:#66d9ef">as&lt;/span> _);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std::&lt;span style="color:#66d9ef">str&lt;/span>::from_utf8_unchecked(slice)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _ &lt;span style="color:#f92672">=&amp;gt;&lt;/span> unreachable!(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还记得我之前说过的我们应该如何努力审查不安全代码以确保不会违反不变体, 在这里就比较适用. 我们使用了更安全的变体, &lt;code>unreachable&lt;/code>, 但是如果我想冒险的话, 我会考虑使用 &lt;a class="link" href="https://doc.rust-lang.org/std/hint/fn.unreachable_unchecked.html" target="_blank" rel="noopener"
>unreachable_unchecked&lt;/a>.&lt;/p>
&lt;blockquote>
&lt;p>译者: 审查指: 在这里我们把 &lt;code>discriminant&lt;/code> 当作一个枚举或者说不变体 &lt;code>match&lt;/code> 了, 因为它的值只有可能是0或者1以表示内容是 &lt;code>inline&lt;/code> or &lt;code>boxed&lt;/code>, 但是可能会有前文像 &lt;code>C&lt;/code> 那样在开发过程中传递了非法的值而导致错误, 所以使用 &lt;code>unreachable!&lt;/code> 宏来确保不会有这种情况出现, 在编译期就可以友好地提示开发者, 以使代码更加安全.&lt;/p>
&lt;/blockquote>
&lt;p>现在我们有了一个 &lt;code>AsRef&lt;/code> 实现, 我们可以打印出它的实际内容了 - 而不需要在意实际上它的变体是什么(&lt;code>Inline&lt;/code> or &lt;code>Boxoed&lt;/code>).&lt;/p>
&lt;p>方便起见, 我们实现 &lt;code>Display&lt;/code> 和 &lt;code>Debug&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::fmt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> fmt::Display &lt;span style="color:#66d9ef">for&lt;/span> SmartString {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self, f: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">mut&lt;/span> fmt::Formatter&lt;span style="color:#f92672">&amp;lt;&amp;#39;&lt;/span>_&lt;span style="color:#f92672">&amp;gt;&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">fmt&lt;/span>::Result {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span> &lt;span style="color:#f92672">=&lt;/span> self.as_ref();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt::Display::fmt(s, f)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> fmt::Debug &lt;span style="color:#66d9ef">for&lt;/span> SmartString {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self, f: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">mut&lt;/span> fmt::Formatter&lt;span style="color:#f92672">&amp;lt;&amp;#39;&lt;/span>_&lt;span style="color:#f92672">&amp;gt;&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">fmt&lt;/span>::Result {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span> &lt;span style="color:#f92672">=&lt;/span> self.as_ref();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt::Debug::fmt(s, f)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> boxed &lt;span style="color:#f92672">=&lt;/span> SmartString::new_boxed(&lt;span style="color:#e6db74">&amp;#34;This is a longer string, would not fit inline&amp;#34;&lt;/span>.into());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> inline &lt;span style="color:#f92672">=&lt;/span> SmartString::new_inline();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(boxed, inline);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:84&lt;span style="color:#f92672">]&lt;/span> boxed &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;This is a longer string, would not fit inline&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:84&lt;span style="color:#f92672">]&lt;/span> inline &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们还有很多事情没做 - 我们不能改变我们的 &lt;code>SmartString&lt;/code>, 但是 &lt;code>smartstring&lt;/code> 是允许的. 我们也不能降级我们的 &lt;code>boxed&lt;/code> 为 &lt;code>inline&lt;/code>, 我们也不能把 &lt;code>inline&lt;/code> 提升为 &lt;code>boxed&lt;/code> 以防它存太多东西了.&lt;/p>
&lt;p>虽然, 但目前有更紧迫的事情要做.&lt;/p>
&lt;p>请允许我缓缓道来.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s: String &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;this is just some text&amp;#34;&lt;/span>.into();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo build --quiet --release &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> valgrind --tool&lt;span style="color:#f92672">=&lt;/span>memcheck ./target/release/enumpeek
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173592&lt;span style="color:#f92672">==&lt;/span> Memcheck, a memory error detector
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173592&lt;span style="color:#f92672">==&lt;/span> Copyright &lt;span style="color:#f92672">(&lt;/span>C&lt;span style="color:#f92672">)&lt;/span> 2002-2017, and GNU GPL&lt;span style="color:#ae81ff">\&amp;#39;&lt;/span>d, by Julian Seward et al.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173592&lt;span style="color:#f92672">==&lt;/span> Using Valgrind-3.16.1 and LibVEX; rerun with -h &lt;span style="color:#66d9ef">for&lt;/span> copyright info
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173592&lt;span style="color:#f92672">==&lt;/span> Command: ./target/release/enumpeek
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173592&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:82&lt;span style="color:#f92672">]&lt;/span> s &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;this is just some text&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173592&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173592&lt;span style="color:#f92672">==&lt;/span> HEAP SUMMARY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173592&lt;span style="color:#f92672">==&lt;/span> in use at exit: &lt;span style="color:#ae81ff">0&lt;/span> bytes in &lt;span style="color:#ae81ff">0&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173592&lt;span style="color:#f92672">==&lt;/span> total heap usage: &lt;span style="color:#ae81ff">15&lt;/span> allocs, &lt;span style="color:#ae81ff">15&lt;/span> frees, 2,335 bytes allocated
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173592&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173592&lt;span style="color:#f92672">==&lt;/span> All heap blocks were freed -- no leaks are possible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173592&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173592&lt;span style="color:#f92672">==&lt;/span> For lists of detected and suppressed errors, rerun with: -s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173592&lt;span style="color:#f92672">==&lt;/span> ERROR SUMMARY: &lt;span style="color:#ae81ff">0&lt;/span> errors from &lt;span style="color:#ae81ff">0&lt;/span> contexts &lt;span style="color:#f92672">(&lt;/span>suppressed: &lt;span style="color:#ae81ff">0&lt;/span> from 0&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s: &lt;span style="color:#a6e22e">SmartString&lt;/span> &lt;span style="color:#f92672">=&lt;/span> SmartString::new_boxed(&lt;span style="color:#e6db74">&amp;#34;this is just some text&amp;#34;&lt;/span>.into());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo build --quiet --release &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> valgrind --tool&lt;span style="color:#f92672">=&lt;/span>memcheck ./target/release/enumpeek
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span> Memcheck, a memory error detector
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span> Copyright &lt;span style="color:#f92672">(&lt;/span>C&lt;span style="color:#f92672">)&lt;/span> 2002-2017, and GNU GPL&lt;span style="color:#ae81ff">\&amp;#39;&lt;/span>d, by Julian Seward et al.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span> Using Valgrind-3.16.1 and LibVEX; rerun with -h &lt;span style="color:#66d9ef">for&lt;/span> copyright info
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span> Command: ./target/release/enumpeek
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:82&lt;span style="color:#f92672">]&lt;/span> s &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;this is just some text&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span> HEAP SUMMARY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span> in use at exit: &lt;span style="color:#ae81ff">22&lt;/span> bytes in &lt;span style="color:#ae81ff">1&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span> total heap usage: &lt;span style="color:#ae81ff">15&lt;/span> allocs, &lt;span style="color:#ae81ff">14&lt;/span> frees, 2,335 bytes allocated
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span> LEAK SUMMARY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span> definitely lost: &lt;span style="color:#ae81ff">22&lt;/span> bytes in &lt;span style="color:#ae81ff">1&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span> indirectly lost: &lt;span style="color:#ae81ff">0&lt;/span> bytes in &lt;span style="color:#ae81ff">0&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span> possibly lost: &lt;span style="color:#ae81ff">0&lt;/span> bytes in &lt;span style="color:#ae81ff">0&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span> still reachable: &lt;span style="color:#ae81ff">0&lt;/span> bytes in &lt;span style="color:#ae81ff">0&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span> suppressed: &lt;span style="color:#ae81ff">0&lt;/span> bytes in &lt;span style="color:#ae81ff">0&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span> Rerun with --leak-check&lt;span style="color:#f92672">=&lt;/span>full to see details of leaked memory
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span> For lists of detected and suppressed errors, rerun with: -s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>173779&lt;span style="color:#f92672">==&lt;/span> ERROR SUMMARY: &lt;span style="color:#ae81ff">0&lt;/span> errors from &lt;span style="color:#ae81ff">0&lt;/span> contexts &lt;span style="color:#f92672">(&lt;/span>suppressed: &lt;span style="color:#ae81ff">0&lt;/span> from 0&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们发生了内存泄漏!&lt;/p>
&lt;p>&lt;code>String&lt;/code> 只是一个单纯的结构体, 但它在堆中有自己的内存分配. 在我们的 &lt;code>SmartString::new_boxed&lt;/code> 中, 我们拿了 &lt;code>String&lt;/code> 的所有权, 并且它有着在堆中相关联的内存我们不曾释放.&lt;/p>
&lt;p>编译器不知道释放我们保存在 &lt;code>SmartString&lt;/code> 以 &lt;code>boxed&lt;/code> 形式存放的 &lt;code>String&lt;/code>, 因为它不知道我们拿的是什么类型 - 它只知道我们用了24个字节, 这24个字节可能放着任何东西.&lt;/p>
&lt;p>如果我们知道这个类型, 事实上确实, 只是个 &lt;code>String&lt;/code>, 并且它们需要被 &lt;code>dropped&lt;/code>, 我们需要告诉编译器.&lt;/p>
&lt;p>下面是我们做 &lt;code>Drop&lt;/code> 的第一次痛苦经历:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Drop &lt;span style="color:#66d9ef">for&lt;/span> SmartString {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">drop&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">match&lt;/span> self.discriminant {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s: &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> String &lt;span style="color:#f92672">=&lt;/span> self.data.as_mut_ptr().cast();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> b: String &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">unsafe&lt;/span> { &lt;span style="color:#f92672">*&lt;/span>s };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> drop(b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// etc.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _ &lt;span style="color:#f92672">=&amp;gt;&lt;/span> unreachable!(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>error&lt;span style="color:#f92672">[&lt;/span>E0507&lt;span style="color:#f92672">]&lt;/span>: cannot move out of &lt;span style="color:#e6db74">`&lt;/span>*s&lt;span style="color:#e6db74">`&lt;/span> which is behind a raw pointer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --&amp;gt; src/main.rs:46:42
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">46&lt;/span> | let b: String &lt;span style="color:#f92672">=&lt;/span> unsafe &lt;span style="color:#f92672">{&lt;/span> *s &lt;span style="color:#f92672">}&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | ^^
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | move occurs because &lt;span style="color:#e6db74">`&lt;/span>*s&lt;span style="color:#e6db74">`&lt;/span> has type &lt;span style="color:#e6db74">`&lt;/span>std::string::String&lt;span style="color:#e6db74">`&lt;/span>, which does not implement the &lt;span style="color:#e6db74">`&lt;/span>Copy&lt;span style="color:#e6db74">`&lt;/span> trait
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | help: consider borrowing here: &lt;span style="color:#e6db74">`&lt;/span>&amp;amp;*s&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Woops, 这不能工作, 我们不能从一个 &lt;code>raw pointer&lt;/code> &lt;code>move&lt;/code> 因为 &lt;code>String&lt;/code> 不是 &lt;code>Copy&lt;/code>.&lt;/p>
&lt;p>我们能做些什么? 我们能把它 &lt;code>Box&lt;/code> 起来么, &lt;code>Box&lt;/code> 有一个 &lt;code>from_raw&lt;/code> 方法, 这听起来不错:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Drop &lt;span style="color:#66d9ef">for&lt;/span> SmartString {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">drop&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">match&lt;/span> self.discriminant {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s: &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> String &lt;span style="color:#f92672">=&lt;/span> self.data.as_mut_ptr().cast();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">unsafe&lt;/span> { Box::from_raw(s) };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> drop(b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// etc.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _ &lt;span style="color:#f92672">=&amp;gt;&lt;/span> unreachable!(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:117&lt;span style="color:#f92672">]&lt;/span> s &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;this is just some text&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>free&lt;span style="color:#f92672">()&lt;/span>: invalid pointer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#ae81ff">179297&lt;/span> abort &lt;span style="color:#f92672">(&lt;/span>core dumped&lt;span style="color:#f92672">)&lt;/span> cargo run -q
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Uh, oh.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>让我们用我们友好的 &lt;code>Valgrind&lt;/code> 检查一下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">$&lt;/span> cargo build &lt;span style="color:#f92672">--&lt;/span>quiet &lt;span style="color:#f92672">--&lt;/span>release &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> valgrind &lt;span style="color:#f92672">--&lt;/span>tool&lt;span style="color:#f92672">=&lt;/span>memcheck .&lt;span style="color:#f92672">/&lt;/span>target&lt;span style="color:#f92672">/&lt;/span>release&lt;span style="color:#f92672">/&lt;/span>enumpeek
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> Memcheck, a memory error detector
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> Copyright (C) &lt;span style="color:#ae81ff">2002&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2017&lt;/span>, and GNU GPL&lt;span style="color:#f92672">&amp;#39;&lt;/span>&lt;span style="color:#a6e22e">d&lt;/span>, by Julian Seward et al.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> Using Valgrind&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">3.16.1&lt;/span> and LibVEX; rerun with &lt;span style="color:#f92672">-&lt;/span>h &lt;span style="color:#66d9ef">for&lt;/span> copyright info
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> Command: .&lt;span style="color:#f92672">/&lt;/span>target&lt;span style="color:#f92672">/&lt;/span>release&lt;span style="color:#f92672">/&lt;/span>enumpeek
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[src&lt;span style="color:#f92672">/&lt;/span>main.rs:&lt;span style="color:#ae81ff">117&lt;/span>] s &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;this is just some text&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> Invalid free() &lt;span style="color:#f92672">/&lt;/span> delete &lt;span style="color:#f92672">/&lt;/span> delete[] &lt;span style="color:#f92672">/&lt;/span> realloc()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> at &lt;span style="color:#ae81ff">0x483B9AB&lt;/span>: &lt;span style="color:#a6e22e">free&lt;/span> (vg_replace_malloc.c:&lt;span style="color:#ae81ff">538&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> by &lt;span style="color:#ae81ff">0x10D501&lt;/span>: &lt;span style="color:#a6e22e">enumpeek&lt;/span>::main (&lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#f92672">/&lt;/span>home&lt;span style="color:#f92672">/&lt;/span>amos&lt;span style="color:#f92672">/&lt;/span>ftl&lt;span style="color:#f92672">/&lt;/span>enumpeek&lt;span style="color:#f92672">/&lt;/span>target&lt;span style="color:#f92672">/&lt;/span>release&lt;span style="color:#f92672">/&lt;/span>enumpeek)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> by &lt;span style="color:#ae81ff">0x10D8E2&lt;/span>: &lt;span style="color:#a6e22e">std&lt;/span>::rt::lang_start::{{closure}} (&lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#f92672">/&lt;/span>home&lt;span style="color:#f92672">/&lt;/span>amos&lt;span style="color:#f92672">/&lt;/span>ftl&lt;span style="color:#f92672">/&lt;/span>enumpeek&lt;span style="color:#f92672">/&lt;/span>target&lt;span style="color:#f92672">/&lt;/span>release&lt;span style="color:#f92672">/&lt;/span>enumpeek)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> by &lt;span style="color:#ae81ff">0x1163F7&lt;/span>: {{closure}} (rt.rs:&lt;span style="color:#ae81ff">52&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> by &lt;span style="color:#ae81ff">0x1163F7&lt;/span>: &lt;span style="color:#a6e22e">do_call&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>closure&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#66d9ef">i32&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> (panicking.rs:&lt;span style="color:#ae81ff">297&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> by &lt;span style="color:#ae81ff">0x1163F7&lt;/span>: &lt;span style="color:#a6e22e">try&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">i32&lt;/span>,closure&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> (panicking.rs:&lt;span style="color:#ae81ff">274&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> by &lt;span style="color:#ae81ff">0x1163F7&lt;/span>: &lt;span style="color:#a6e22e">catch_unwind&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>closure&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#66d9ef">i32&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> (panic.rs:&lt;span style="color:#ae81ff">394&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> by &lt;span style="color:#ae81ff">0x1163F7&lt;/span>: &lt;span style="color:#a6e22e">std&lt;/span>::rt::lang_start_internal (rt.rs:&lt;span style="color:#ae81ff">51&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> by &lt;span style="color:#ae81ff">0x10D561&lt;/span>: &lt;span style="color:#a6e22e">main&lt;/span> (&lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#f92672">/&lt;/span>home&lt;span style="color:#f92672">/&lt;/span>amos&lt;span style="color:#f92672">/&lt;/span>ftl&lt;span style="color:#f92672">/&lt;/span>enumpeek&lt;span style="color:#f92672">/&lt;/span>target&lt;span style="color:#f92672">/&lt;/span>release&lt;span style="color:#f92672">/&lt;/span>enumpeek)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> Address &lt;span style="color:#ae81ff">0x1ffefff561&lt;/span> is on thread &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;#39;&lt;/span>&lt;span style="color:#a6e22e">s&lt;/span> stack
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> frame #&lt;span style="color:#ae81ff">1&lt;/span>, created by enumpeek::main (&lt;span style="color:#f92672">???&lt;/span>:)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> HEAP SUMMARY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">use&lt;/span> at exit: &lt;span style="color:#ae81ff">0&lt;/span> bytes &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> total heap usage: &lt;span style="color:#ae81ff">15&lt;/span> allocs, &lt;span style="color:#ae81ff">16&lt;/span> frees, &lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">335&lt;/span> bytes allocated
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> All heap blocks were freed &lt;span style="color:#f92672">--&lt;/span> no leaks are possible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> For lists of detected and suppressed errors, rerun with: &lt;span style="color:#f92672">-&lt;/span>s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">179648&lt;/span>&lt;span style="color:#f92672">==&lt;/span> ERROR SUMMARY: &lt;span style="color:#ae81ff">1&lt;/span> errors from &lt;span style="color:#ae81ff">1&lt;/span> contexts (suppressed: &lt;span style="color:#ae81ff">0&lt;/span> from &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>问题看起来像是它在试图释放 &lt;code>String&lt;/code> 就像它分配在堆上一样, 然而并没有! 实际上是 &lt;code>String&lt;/code> 中的数据分配在堆上, 而不是 &lt;code>String&lt;/code> 本身.&lt;/p>
&lt;p>这里有一个看起来生效的方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Drop &lt;span style="color:#66d9ef">for&lt;/span> SmartString {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">drop&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">match&lt;/span> self.discriminant {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s: &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> String &lt;span style="color:#f92672">=&lt;/span> self.data.as_mut_ptr().cast();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s: String &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">unsafe&lt;/span> { std::ptr::read_unaligned(s) };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> drop(s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// etc.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _ &lt;span style="color:#f92672">=&amp;gt;&lt;/span> unreachable!(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以更进一步:&lt;/p>
&lt;ul>
&lt;li>使用泛型函数来减少重复代码.&lt;/li>
&lt;li>省略掉 &lt;code>drop&lt;/code>, 在 &lt;code>std::ptr::read_unaligned&lt;/code> 离开作用域后自动调用.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> SmartString {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">drop_variant&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> { std::ptr::read_unaligned(self.data.as_ptr().cast::&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>()) };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Drop &lt;span style="color:#66d9ef">for&lt;/span> SmartString {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">drop&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">match&lt;/span> self.discriminant {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">unsafe&lt;/span> { self.drop_variant::&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span>() },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">unsafe&lt;/span> { self.drop_variant::&lt;span style="color:#f92672">&amp;lt;&lt;/span>Inline&lt;span style="color:#f92672">&amp;gt;&lt;/span>() },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _ &lt;span style="color:#f92672">=&amp;gt;&lt;/span> unreachable!(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo build --quiet --release &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> valgrind --tool&lt;span style="color:#f92672">=&lt;/span>memcheck ./target/release/enumpeek
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>181085&lt;span style="color:#f92672">==&lt;/span> Memcheck, a memory error detector
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>181085&lt;span style="color:#f92672">==&lt;/span> Copyright &lt;span style="color:#f92672">(&lt;/span>C&lt;span style="color:#f92672">)&lt;/span> 2002-2017, and GNU GPL&lt;span style="color:#ae81ff">\&amp;#39;&lt;/span>d, by Julian Seward et al.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>181085&lt;span style="color:#f92672">==&lt;/span> Using Valgrind-3.16.1 and LibVEX; rerun with -h &lt;span style="color:#66d9ef">for&lt;/span> copyright info
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>181085&lt;span style="color:#f92672">==&lt;/span> Command: ./target/release/enumpeek
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>181085&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:99&lt;span style="color:#f92672">]&lt;/span> s &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;this is just some text&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>181085&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>181085&lt;span style="color:#f92672">==&lt;/span> HEAP SUMMARY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>181085&lt;span style="color:#f92672">==&lt;/span> in use at exit: &lt;span style="color:#ae81ff">0&lt;/span> bytes in &lt;span style="color:#ae81ff">0&lt;/span> blocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>181085&lt;span style="color:#f92672">==&lt;/span> total heap usage: &lt;span style="color:#ae81ff">15&lt;/span> allocs, &lt;span style="color:#ae81ff">15&lt;/span> frees, 2,335 bytes allocated
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>181085&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>181085&lt;span style="color:#f92672">==&lt;/span> All heap blocks were freed -- no leaks are possible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>181085&lt;span style="color:#f92672">==&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>181085&lt;span style="color:#f92672">==&lt;/span> For lists of detected and suppressed errors, rerun with: -s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">==&lt;/span>181085&lt;span style="color:#f92672">==&lt;/span> ERROR SUMMARY: &lt;span style="color:#ae81ff">0&lt;/span> errors from &lt;span style="color:#ae81ff">0&lt;/span> contexts &lt;span style="color:#f92672">(&lt;/span>suppressed: &lt;span style="color:#ae81ff">0&lt;/span> from 0&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>完美, 但是这完全正确了吗? 我不知道, 在让一堆人测试看看之前我是不会把代码用到生产环境中的. 但是至少在我们的 &lt;code>case&lt;/code> 中, 它已经没有发生内存泄漏了.&lt;/p>
&lt;p>这总归是好的.&lt;/p>
&lt;p>我们可以在我们的结构体中花上整天时间都在这重新实现 &lt;code>smartstring&lt;/code> 里面的功能, 但是有个点需要记住, 我们的版本比 &lt;code>smartstring&lt;/code> 大了足足一个字节.&lt;/p>
&lt;p>就像 &lt;code>smallvec::SmallVec&lt;/code> 类型比 &lt;code>Vec&lt;/code> 大一样.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo add smallvec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Adding smallvec v1.4.2 to dependencies
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::mem::size_of;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> smallvec::SmallVec;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(size_of::&lt;span style="color:#f92672">&amp;lt;&lt;/span>Vec&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>(), size_of::&lt;span style="color:#f92672">&amp;lt;&lt;/span>SmallVec&lt;span style="color:#f92672">&amp;lt;&lt;/span>[&lt;span style="color:#66d9ef">u8&lt;/span>; &lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:100&lt;span style="color:#f92672">]&lt;/span> size_of::&amp;lt;Vec&amp;lt;u8&amp;gt;&amp;gt;&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">24&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:100&lt;span style="color:#f92672">]&lt;/span> size_of::&amp;lt;SmallVec&amp;lt;&lt;span style="color:#f92672">[&lt;/span>u8; 1&lt;span style="color:#f92672">]&lt;/span>&amp;gt;&amp;gt;&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因此, 希望到目前为止本文讲述的足足44分钟的时间里你已经 &lt;strong>完全&lt;/strong> 明白了为什么这是一个有趣的问题(请回忆下开篇所提到的问题).&lt;/p>
&lt;p>它的神秘不在于 &lt;code>SmallVec&amp;lt;[u8; 1]&amp;gt;&lt;/code> 比 &lt;code>Vec&amp;lt;u8&amp;gt;&lt;/code> 大8个字节, 因为 &lt;code>SmallVec&lt;/code> 只是一个枚举, 它的判定式只需要考虑两个变体, 但是因为 &lt;code>Rust&lt;/code> 需要额外的空间来保证对齐, 所以多用了整整8个字节.&lt;/p>
&lt;p>它的神秘在于, &lt;code>SmartString&lt;/code> 是怎么做到只有24个字节的.&lt;/p>
&lt;p>为了回答这个问题, 我们需要更深入的观察指针.&lt;/p>
&lt;h2 id="仔细看看指针">仔细看看指针&lt;/h2>
&lt;p>So, 什么是指针? 只是一串数字? 它告诉了你有些东西在内存的哪个地方.&lt;/p>
&lt;p>举个例子, 如果我们声明了一个本地变量 &lt;code>x&lt;/code>, &lt;code>i32&lt;/code>, 它可能直立在栈上:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// this is a signed 32-bit integer
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">30&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// this is a reference to a signed 32-bit integer
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> x_ref &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// this is a pointer to a signed 32-bit integer
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> x_ptr &lt;span style="color:#f92672">=&lt;/span> x_ref &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> _;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(x_ptr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:105&lt;span style="color:#f92672">]&lt;/span> x_ptr &lt;span style="color:#f92672">=&lt;/span> 0x00007fff10be39ec
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然, 一个本地变量也可能在寄存器中. 但这在这里无关紧要. 一旦我们获取了某个对象的地址, 它就需要映射到虚拟内存地址空间的某个地方, 而在寄存器中的则不需要, 为了方便解释, 我们现在假装寄存器不存在.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>So, 数字是为了告诉你某些东西在内存中的位置. 这就像是地址, 就跟国家有实际位置的地址一样, 只是多了些间接性.&lt;/p>
&lt;p>一个对齐的指针是一个其值(地址)是数据大小的倍数的指针. 当数据是自然对齐的时候对 CPUs 来说很方便.&lt;/p>
&lt;p>让我们看一些例子.&lt;/p>
&lt;p>我们可以在内存中寻址的的最小单元是字节. 一个指向字节的指针总是对齐的, 因为指针用字节来计数, 换句话说, 一个 &lt;code>u8&lt;/code> 的对齐单位就是1.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> arr &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>arr[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> _,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>arr[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> _,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>arr[&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> _,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>arr[&lt;span style="color:#ae81ff">3&lt;/span>] &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> _,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:106&lt;span style="color:#f92672">]&lt;/span> &amp;amp;arr&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> as *const _ &lt;span style="color:#f92672">=&lt;/span> 0x00007ffd6474abdc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:106&lt;span style="color:#f92672">]&lt;/span> &amp;amp;arr&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> as *const _ &lt;span style="color:#f92672">=&lt;/span> 0x00007ffd6474abdd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:106&lt;span style="color:#f92672">]&lt;/span> &amp;amp;arr&lt;span style="color:#f92672">[&lt;/span>2&lt;span style="color:#f92672">]&lt;/span> as *const _ &lt;span style="color:#f92672">=&lt;/span> 0x00007ffd6474abde
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:106&lt;span style="color:#f92672">]&lt;/span> &amp;amp;arr&lt;span style="color:#f92672">[&lt;/span>3&lt;span style="color:#f92672">]&lt;/span> as *const _ &lt;span style="color:#f92672">=&lt;/span> 0x00007ffd6474abdf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果讨论的是指向 &lt;code>u16&lt;/code> 的指针, 那么它的对齐单位是2.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>fn main&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> let arr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>1u16, 2u16, 3u16, 4u16&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fn inspect&amp;lt;T&amp;gt;&lt;span style="color:#f92672">(&lt;/span>t: *const T&lt;span style="color:#f92672">)&lt;/span> -&amp;gt; &lt;span style="color:#f92672">(&lt;/span>*const T, bool&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">(&lt;/span>t, t as usize % 2 &lt;span style="color:#f92672">==&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!&lt;span style="color:#f92672">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inspect&lt;span style="color:#f92672">(&lt;/span>&amp;amp;arr&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> as *const _&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inspect&lt;span style="color:#f92672">(&lt;/span>&amp;amp;arr&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> as *const _&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inspect&lt;span style="color:#f92672">(&lt;/span>&amp;amp;arr&lt;span style="color:#f92672">[&lt;/span>2&lt;span style="color:#f92672">]&lt;/span> as *const _&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inspect&lt;span style="color:#f92672">(&lt;/span>&amp;amp;arr&lt;span style="color:#f92672">[&lt;/span>3&lt;span style="color:#f92672">]&lt;/span> as *const _&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:110&lt;span style="color:#f92672">]&lt;/span> inspect&lt;span style="color:#f92672">(&lt;/span>&amp;amp;arr&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> as *const _&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x00007ffd81bf5918,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> true,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:110&lt;span style="color:#f92672">]&lt;/span> inspect&lt;span style="color:#f92672">(&lt;/span>&amp;amp;arr&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> as *const _&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x00007ffd81bf591a,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> true,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:110&lt;span style="color:#f92672">]&lt;/span> inspect&lt;span style="color:#f92672">(&lt;/span>&amp;amp;arr&lt;span style="color:#f92672">[&lt;/span>2&lt;span style="color:#f92672">]&lt;/span> as *const _&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x00007ffd81bf591c,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> true,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:110&lt;span style="color:#f92672">]&lt;/span> inspect&lt;span style="color:#f92672">(&lt;/span>&amp;amp;arr&lt;span style="color:#f92672">[&lt;/span>3&lt;span style="color:#f92672">]&lt;/span> as *const _&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x00007ffd81bf591e,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> true,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同理, 对于 &lt;code>u32&lt;/code> 是4, &lt;code>u64&lt;/code> 是8.&lt;/p>
&lt;p>下面有一个正确对齐的例子:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>底部的小方块表示如果我们想要存该类型, 可以把它放在那里.&lt;/p>
&lt;p>顶部部分表示实际的内存布局, 举个例子, 一个结构体:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdint.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stddef.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> S {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint16_t&lt;/span> c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint32_t&lt;/span> d;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(S) = %ld&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> S));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;offsetof(struct S, a) = %zu&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, offsetof(&lt;span style="color:#66d9ef">struct&lt;/span> S, a));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;offsetof(struct S, b) = %zu&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, offsetof(&lt;span style="color:#66d9ef">struct&lt;/span> S, b));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;offsetof(struct S, c) = %zu&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, offsetof(&lt;span style="color:#66d9ef">struct&lt;/span> S, c));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;offsetof(struct S, d) = %zu&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, offsetof(&lt;span style="color:#66d9ef">struct&lt;/span> S, d));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ clang -Wall main.c -o main &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ./main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sizeof&lt;span style="color:#f92672">(&lt;/span>S&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>offsetof&lt;span style="color:#f92672">(&lt;/span>struct S, a&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>offsetof&lt;span style="color:#f92672">(&lt;/span>struct S, b&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>offsetof&lt;span style="color:#f92672">(&lt;/span>struct S, c&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>offsetof&lt;span style="color:#f92672">(&lt;/span>struct S, d&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这里, 一切顺利.&lt;/p>
&lt;p>我们用另一个布局代替看看:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> S {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint16_t&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint32_t&lt;/span> d;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ clang -Wall main.c -o main &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ./main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sizeof&lt;span style="color:#f92672">(&lt;/span>S&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">12&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>offsetof&lt;span style="color:#f92672">(&lt;/span>struct S, a&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>offsetof&lt;span style="color:#f92672">(&lt;/span>struct S, b&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>offsetof&lt;span style="color:#f92672">(&lt;/span>struct S, c&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>offsetof&lt;span style="color:#f92672">(&lt;/span>struct S, d&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为了维持对齐, 编译器插入了废料:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&amp;ldquo;Padding&amp;rdquo; 不绝对是置零 - 它只是没有使用的空间. 即使它初始化置零了, 也不能保证它会在你分配成员的时候维持0.&lt;/p>
&lt;p>经常使用该结构体可能会混淆值和填充的 &lt;code>padding&lt;/code>, 因此一个好的 &lt;code>old block memory comparison&lt;/code> (memcmp) 不能够测试两个结构体是否完全相等.&lt;/p>
&lt;blockquote>
&lt;p>原文: Regular usage of the struct might mess with the values in the padding, and so a good old block memory comparison (memcmp) would not be enough to test two structs for equality.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>译者: 这里没懂作者想说什么, 有人清楚的话可以提个issue给我.&lt;/p>
&lt;/blockquote>
&lt;p>我们在 &lt;code>Rust&lt;/code> 中定义一个相同布局的结构体会发生什么?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">S&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b: &lt;span style="color:#66d9ef">u16&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d: &lt;span style="color:#66d9ef">u32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(std::mem::size_of::&lt;span style="color:#f92672">&amp;lt;&lt;/span>S&lt;span style="color:#f92672">&amp;gt;&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:112&lt;span style="color:#f92672">]&lt;/span> std::mem::size_of::&amp;lt;S&amp;gt;&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为什么只有8个字节? 发生了什么? 让我们来借助工具看看它的布局:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo add memoffset
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Adding memoffset v0.5.5 to dependencies
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">S&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b: &lt;span style="color:#66d9ef">u16&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d: &lt;span style="color:#66d9ef">u32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">use&lt;/span> memoffset::offset_of;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std::mem::size_of::&lt;span style="color:#f92672">&amp;lt;&lt;/span>S&lt;span style="color:#f92672">&amp;gt;&lt;/span>(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> offset_of&lt;span style="color:#f92672">!&lt;/span>(S, a),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> offset_of&lt;span style="color:#f92672">!&lt;/span>(S, b),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> offset_of&lt;span style="color:#f92672">!&lt;/span>(S, c),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> offset_of&lt;span style="color:#f92672">!&lt;/span>(S, d)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:113&lt;span style="color:#f92672">]&lt;/span> std::mem::size_of::&amp;lt;S&amp;gt;&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:113&lt;span style="color:#f92672">]&lt;/span> offset_of!&lt;span style="color:#f92672">(&lt;/span>S, a&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:113&lt;span style="color:#f92672">]&lt;/span> offset_of!&lt;span style="color:#f92672">(&lt;/span>S, b&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:113&lt;span style="color:#f92672">]&lt;/span> offset_of!&lt;span style="color:#f92672">(&lt;/span>S, c&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:113&lt;span style="color:#f92672">]&lt;/span> offset_of!&lt;span style="color:#f92672">(&lt;/span>S, d&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们的成员被重新排序了!&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>我们可以让 &lt;code>Rust compiler&lt;/code> 不要重排序就像 &lt;code>C&lt;/code> 一样通过 &lt;code>repr(C)&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#[repr(C)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">S&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b: &lt;span style="color:#66d9ef">u16&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d: &lt;span style="color:#66d9ef">u32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">use&lt;/span> memoffset::offset_of;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std::mem::size_of::&lt;span style="color:#f92672">&amp;lt;&lt;/span>S&lt;span style="color:#f92672">&amp;gt;&lt;/span>(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> offset_of&lt;span style="color:#f92672">!&lt;/span>(S, a),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> offset_of&lt;span style="color:#f92672">!&lt;/span>(S, b),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> offset_of&lt;span style="color:#f92672">!&lt;/span>(S, c),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> offset_of&lt;span style="color:#f92672">!&lt;/span>(S, d)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:11&lt;span style="color:#f92672">]&lt;/span> std::mem::size_of::&amp;lt;S&amp;gt;&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">12&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:11&lt;span style="color:#f92672">]&lt;/span> offset_of!&lt;span style="color:#f92672">(&lt;/span>S, a&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:11&lt;span style="color:#f92672">]&lt;/span> offset_of!&lt;span style="color:#f92672">(&lt;/span>S, b&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:11&lt;span style="color:#f92672">]&lt;/span> offset_of!&lt;span style="color:#f92672">(&lt;/span>S, c&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:11&lt;span style="color:#f92672">]&lt;/span> offset_of!&lt;span style="color:#f92672">(&lt;/span>S, d&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在我们有了和 &lt;code>C&lt;/code> 一样的布局了, 也有着相同的填充.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>或者也可以让编译器既不要重新排序也不要填充以完全忽略对齐:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#[repr(C, packed)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">S&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b: &lt;span style="color:#66d9ef">u16&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d: &lt;span style="color:#66d9ef">u32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">use&lt;/span> memoffset::offset_of;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std::mem::size_of::&lt;span style="color:#f92672">&amp;lt;&lt;/span>S&lt;span style="color:#f92672">&amp;gt;&lt;/span>(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> offset_of&lt;span style="color:#f92672">!&lt;/span>(S, a),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> offset_of&lt;span style="color:#f92672">!&lt;/span>(S, b),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> offset_of&lt;span style="color:#f92672">!&lt;/span>(S, c),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> offset_of&lt;span style="color:#f92672">!&lt;/span>(S, d)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在, &lt;code>S.b&lt;/code> 不再很好地对齐了.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:11&lt;span style="color:#f92672">]&lt;/span> std::mem::size_of::&amp;lt;S&amp;gt;&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:11&lt;span style="color:#f92672">]&lt;/span> offset_of!&lt;span style="color:#f92672">(&lt;/span>S, a&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:11&lt;span style="color:#f92672">]&lt;/span> offset_of!&lt;span style="color:#f92672">(&lt;/span>S, b&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:11&lt;span style="color:#f92672">]&lt;/span> offset_of!&lt;span style="color:#f92672">(&lt;/span>S, c&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:11&lt;span style="color:#f92672">]&lt;/span> offset_of!&lt;span style="color:#f92672">(&lt;/span>S, d&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;p>假如我们尝试获取一个引用, &lt;code>Rust&lt;/code> 会警告我们(当前只是 &lt;code>warn&lt;/code>, 以后可能会变成一个 &lt;code>error&lt;/code>):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#[repr(C, packed)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#[derive(Default)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">S&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b: &lt;span style="color:#66d9ef">u16&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d: &lt;span style="color:#66d9ef">u32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s: &lt;span style="color:#a6e22e">S&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Default::default();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbg!(&lt;span style="color:#f92672">&amp;amp;&lt;/span>s.b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>warning: borrow of packed field is unsafe and requires unsafe &lt;span style="color:#66d9ef">function&lt;/span> or block &lt;span style="color:#f92672">(&lt;/span>error E0133&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --&amp;gt; src/main.rs:12:10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">12&lt;/span> | dbg!&lt;span style="color:#f92672">(&lt;/span>&amp;amp;s.b&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | ^^^^
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> note: &lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#75715e">#[warn(safe_packed_borrows)]` on by default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> note: &lt;span style="color:#66d9ef">for&lt;/span> more information, see issue &lt;span style="color:#75715e">#46043 &amp;lt;https://github.com/rust-lang/rust/issues/46043&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>warning: &lt;span style="color:#ae81ff">1&lt;/span> warning emitted
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>src/main.rs:12&lt;span style="color:#f92672">]&lt;/span> &amp;amp;s.b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>迄今&amp;hellip; 所有的事情在我 &lt;code>2018 i7&lt;/code> 处理器上工作得很好.&lt;/p>
&lt;p>我们可以改变它也没有任何问题:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#[repr(C, packed)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#[derive(Default)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">S&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b: &lt;span style="color:#66d9ef">u16&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c: &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d: &lt;span style="color:#66d9ef">u32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> s: &lt;span style="color:#a6e22e">S&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Default::default();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s.b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x123&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;{:#x}&amp;#34;&lt;/span>, s.b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x123
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这并不是获得未对齐指针的唯一方法, 使用指针类型转换我们也可以把两个 &lt;code>u8&lt;/code> 当作一个单独的未对齐的 &lt;code>u16&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> arr &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> ptr_u16 &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> arr[&lt;span style="color:#ae81ff">1&lt;/span>]) &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> _ &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> &lt;span style="color:#66d9ef">u16&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>ptr_u16 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x123&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;{:#x}&amp;#34;&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>ptr_u16);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意, &lt;code>clippy&lt;/code> 会捕获到这个, 并且认为这是一个错误.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo clippy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Checking enumpeek v0.1.0 &lt;span style="color:#f92672">(&lt;/span>/home/amos/ftl/enumpeek&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>error: casting from &lt;span style="color:#e6db74">`&lt;/span>*mut u8&lt;span style="color:#e6db74">`&lt;/span> to a more-strictly-aligned pointer &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>*mut u16&lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &amp;lt; &lt;span style="color:#ae81ff">2&lt;/span> bytes&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --&amp;gt; src/main.rs:3:19
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span> | let ptr_u16 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&amp;amp;mut arr&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">])&lt;/span> as *mut _ as *mut u16;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> note: &lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#75715e">#[deny(clippy::cast_ptr_alignment)]` on by default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> help: &lt;span style="color:#66d9ef">for&lt;/span> further information visit https://rust-lang.github.io/rust-clippy/master/index.html#cast_ptr_alignment
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不过这在我的电脑上依旧是可以运行的:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cargo run -q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x123
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以为什么我们要再次关注对齐呢?&lt;/p>
&lt;p>好吧, 这是一个很长的故事&amp;hellip;&lt;/p>
&lt;h2 id="我们想要什么-对齐-我们为什么要它-well">我们想要什么? 对齐! 我们为什么要它? Well&amp;hellip;&lt;/h2>
&lt;p>回到 &lt;code>C&lt;/code> 发明的年代, 那个时候有些处理器不怎么支持没有对齐过的内存访问.&lt;/p>
&lt;p>对于这些处理器, 没有对齐的内存访问可能会导致&lt;a class="link" href="https://www.kernel.org/doc/Documentation/unaligned-memory-access.txt" target="_blank" rel="noopener"
>抛出一个处理器错误&lt;/a>: 异常处理器或许能够正常访问一个没有对齐的内存, 但是会浪费较多的性能, 或者是干脆没法访问未对齐的内存, 然后程序运行就被 abort 了.&lt;/p>
&lt;p>在另一些处理器架构里, 像是英特尔的 &amp;ldquo;Core 2&amp;rdquo; 系列, 通常会用一些性能损耗来支持未对齐的内存.&lt;/p>
&lt;p>我本来想在这里放上一些 microbenchmarks, 但是它们有时候会互相矛盾 - 基准测试有很多影响因素. 有些基准测试显示有 10% 的性能降低, 有些会降低 50%, 显然有很多会影响到关于访问未对齐内存的性能测试.&lt;/p>
&lt;p>但是请记住, 即使处理器开始对未对齐内存做了一级支持, 但是出于性能原因仍然要避免使用未对齐内存.&lt;/p>
&lt;p>我通常把最好的东西留到最后说 但是:&lt;/p>
&lt;p>一些架构可能不会抛出处理器异常, 而是静默地执行一些不同的读操作.&lt;/p>
&lt;p>&lt;img src="/post/translation/rust/peeking_inside_a_rust_enum/armv4t.jpg"
width="640"
height="518"
srcset="/post/translation/rust/peeking_inside_a_rust_enum/armv4t_hub50016a2bde62f69b78292ec788779b2_120594_480x0_resize_q75_box.jpg 480w, /post/translation/rust/peeking_inside_a_rust_enum/armv4t_hub50016a2bde62f69b78292ec788779b2_120594_1024x0_resize_q75_box.jpg 1024w"
loading="lazy"
alt="An example ARMv4t chip: the sound processor chip for the SEGA NAOMI arcade system."
class="gallery-image"
data-flex-grow="123"
data-flex-basis="296px"
>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h2 id="很久很久-在armv5以前">很久很久, 在ARMv5以前&amp;hellip;&lt;/h2>
&lt;p>我们已经在这篇文章里读了一些关于未对齐内存的内容.&lt;/p>
&lt;p>所以展示上面所说的不同的读操作会相对比较容易.&lt;/p>
&lt;p>首先你需要一些数据 - 我们只用了 8 个不同的字节值, 这很容易理解后面将会发生什么.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> arr[&lt;span style="color:#ae81ff">8&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#ae81ff">0xef&lt;/span>, &lt;span style="color:#ae81ff">0xcd&lt;/span>, &lt;span style="color:#ae81ff">0xab&lt;/span>, &lt;span style="color:#ae81ff">0x89&lt;/span>, &lt;span style="color:#ae81ff">0x67&lt;/span>, &lt;span style="color:#ae81ff">0x45&lt;/span>, &lt;span style="color:#ae81ff">0x23&lt;/span>, &lt;span style="color:#ae81ff">0x01&lt;/span> };
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后我们去读一个没有对齐的地址. 举个例子, 我们尝试从数组的第二个元素开始读取一个 &lt;code>uint32_t&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdint.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> arr[&lt;span style="color:#ae81ff">8&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#ae81ff">0xef&lt;/span>, &lt;span style="color:#ae81ff">0xcd&lt;/span>, &lt;span style="color:#ae81ff">0xab&lt;/span>, &lt;span style="color:#ae81ff">0x89&lt;/span>, &lt;span style="color:#ae81ff">0x67&lt;/span>, &lt;span style="color:#ae81ff">0x45&lt;/span>, &lt;span style="color:#ae81ff">0x23&lt;/span>, &lt;span style="color:#ae81ff">0x01&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// arrays are zero-indexed, so `1` is the second item
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">uint32_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">uint32_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(&lt;span style="color:#f92672">&amp;amp;&lt;/span>arr[&lt;span style="color:#ae81ff">1&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;0x%08x&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>ptr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>猜猜会打印什么? 是 &lt;code>0xcdab8967&lt;/code>? 错了!&lt;/p>
&lt;p>我2018年的i7处理器是一个小端处理器:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ lscpu | grep -E &lt;span style="color:#e6db74">&amp;#39;(Byte Order|Model name)&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Byte Order: Little Endian
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Model name: Intel&lt;span style="color:#f92672">(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> Core&lt;span style="color:#f92672">(&lt;/span>TM&lt;span style="color:#f92672">)&lt;/span> i7-8750H CPU @ 2.20GHz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这意味着字节是从最低有效值存储到最高有效值.&lt;/p>
&lt;p>所以与其说是这样子的:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>其实是这样子的:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ gcc -Wall main.c -o main &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ./main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x6789abcd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这就是为什么我为我的数组选了这些好辨识的值的原因.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;img src="/post/translation/rust/peeking_inside_a_rust_enum/gba.jpg"
width="1280"
height="884"
srcset="/post/translation/rust/peeking_inside_a_rust_enum/gba_hu302f1c2d37f956d6cc8b3c35003135c9_97592_480x0_resize_q75_box.jpg 480w, /post/translation/rust/peeking_inside_a_rust_enum/gba_hu302f1c2d37f956d6cc8b3c35003135c9_97592_1024x0_resize_q75_box.jpg 1024w"
loading="lazy"
alt="A &amp;lsquo;Glacier&amp;rsquo; Game Boy Advance - one of the colors available at launch in North America"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>| &lt;a class="link" href="https://devkitpro.org/wiki/Getting_Started" target="_blank" rel="noopener"
>devKitPro&lt;/a>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>我以前也没读过关于GBA开发的相关文档, 我只是找了个项目&lt;a class="link" href="https://vba-m.com/" target="_blank" rel="noopener"
>VisualBoyAdvance&lt;/a>:&lt;/p>
&lt;p>&lt;img src="/post/translation/rust/peeking_inside_a_rust_enum/gba-hello.png"
width="480"
height="349"
srcset="/post/translation/rust/peeking_inside_a_rust_enum/gba-hello_hu374745a0a15a6dd857febbf559df6352_9948_480x0_resize_box_3.png 480w, /post/translation/rust/peeking_inside_a_rust_enum/gba-hello_hu374745a0a15a6dd857febbf559df6352_9948_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="137"
data-flex-basis="330px"
>&lt;/p>
&lt;p>这个项目的 &lt;code>C&lt;/code> 代码看起来如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// (cut)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// clear screen
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> iprintf(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\x1b&lt;/span>&lt;span style="color:#e6db74">[2J&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// print at coordinates 10,10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> iprintf(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\x1b&lt;/span>&lt;span style="color:#e6db74">[10;10H&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> iprintf(&lt;span style="color:#e6db74">&amp;#34;Hello World!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// (cut)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>So - 足够简单了!他有一些自己的 &lt;code>printf&lt;/code> 实现 - 除此之外, 这就只是 &lt;code>C&lt;/code>! 然后同样用 &lt;code>GCC&lt;/code> 编译.&lt;/p>
&lt;p>所以让我们的代码跑起来并不是&lt;strong>很难&lt;/strong>.&lt;/p>
&lt;p>以下是完整的代码 &lt;code>source/console.c&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;gba_console.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;gba_video.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;gba_interrupt.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;gba_systemcalls.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> irqInit();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> irqEnable(IRQ_VBLANK);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consoleDemoInit();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// clear screen
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> iprintf(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\x1b&lt;/span>&lt;span style="color:#e6db74">[2J&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// print at coordinates 10,10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> iprintf(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\x1b&lt;/span>&lt;span style="color:#e6db74">[10;10H&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> arr[&lt;span style="color:#ae81ff">8&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#ae81ff">0xef&lt;/span>, &lt;span style="color:#ae81ff">0xcd&lt;/span>, &lt;span style="color:#ae81ff">0xab&lt;/span>, &lt;span style="color:#ae81ff">0x89&lt;/span>, &lt;span style="color:#ae81ff">0x67&lt;/span>, &lt;span style="color:#ae81ff">0x45&lt;/span>, &lt;span style="color:#ae81ff">0x23&lt;/span>, &lt;span style="color:#ae81ff">0x01&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// arrays are zero-indexed, so `1` is the second item
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">uint32_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">uint32_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(&lt;span style="color:#f92672">&amp;amp;&lt;/span>arr[&lt;span style="color:#ae81ff">1&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> iprintf(&lt;span style="color:#e6db74">&amp;#34;0x%08x&amp;#34;&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>ptr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> VBlankIntrWait();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>200行Rust代码解释绿色线程</title><link>/post/translation/rust/green_threads_explained_in_200_lines_of_rust/</link><pubDate>Wed, 18 Nov 2020 13:28:44 +0800</pubDate><guid>/post/translation/rust/green_threads_explained_in_200_lines_of_rust/</guid><description>&lt;img src="/post/translation/rust/green_threads_explained_in_200_lines_of_rust/cover.png" alt="Featured image of post 200行Rust代码解释绿色线程" />&lt;blockquote>
&lt;p>本译文译自 &lt;a class="link" href="https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/" target="_blank" rel="noopener"
>Green Threads Explained in 200 Lines of Rust&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h1 id="介绍">介绍&lt;/h1>
&lt;p>这本书目标是通过我们自己编写实现的一个简单可用的绿色线程代码, 来解释绿色线程.&lt;/p>
&lt;blockquote>
&lt;p>所有代码可以在该 &lt;a class="link" href="https://github.com/cfsamson/example-greenthreads" target="_blank" rel="noopener"
>Git仓库&lt;/a> 找到, 它有两个分支, &lt;code>main&lt;/code> 分支仅仅包括代码, &lt;code>commented&lt;/code> 分支包含解释我们做了什么的注释.&lt;/p>
&lt;/blockquote>
&lt;p>绿色线程, 用户态线程, 协程(goroutines), 纤程(fibers), 它们有多种称谓, 但是简单起见我将会在后续统一称之为绿色线程.&lt;/p>
&lt;p>在这篇文章中我将通过实现一个200行 &lt;code>Rust&lt;/code> 绿色线程代码的简单例子来解释它是如何工作的.&lt;/p>
&lt;blockquote>
&lt;p>我们不会使用任何的外部库来确保我们真正的理解发生了什么.&lt;/p>
&lt;/blockquote>
&lt;h2 id="谁适合阅读这篇文章">谁适合阅读这篇文章&lt;/h2>
&lt;p>我们深陷在一个兔子坑中, 如果它听起来很可怕, 那么这篇文章可能不适合你, 像曾经一样去做点轻松愉悦的事情吧~&lt;/p>
&lt;p>如果你还是很好奇事情是如何工作的, 那么继续读下去. 你可能听说过 &lt;code>Go&lt;/code> 的 &lt;code>goroutines&lt;/code>, 或者 &lt;code>Ruby&lt;/code> 和 &lt;code>Julia&lt;/code> 中等价的那些, 你可能知道它们怎么使用但是又想知道它们是如何工作的, 请继续读下去.&lt;/p>
&lt;p>另外, 如果你是以下这类人的话那也可能比较有趣:&lt;/p>
&lt;ul>
&lt;li>你是 &lt;code>Rust&lt;/code> 初学者并且想学习更多的特性.&lt;/li>
&lt;li>你已经在 &lt;code>Rust社区&lt;/code> 中了解讨论过 &lt;code>async/await&lt;/code>, &lt;code>Pin&lt;/code>, 和为什么需要生成器. 我们将试着把那些都整合在这篇文章中.&lt;/li>
&lt;li>或许你想了解 &lt;code>Rust&lt;/code> 内联汇编的基础知识.&lt;/li>
&lt;li>或许你只是单纯的感兴趣.&lt;/li>
&lt;/ul>
&lt;p>Well, 现在加入我们并且试着了解我们需要了解的一切~&lt;/p>
&lt;p>你不需要是一个 &lt;code>Rust&lt;/code> 程序员就可以理解本文, 但是我们强烈建议你首先能够知道一些简单的语法, 如果你想亲手尝试编写代码玩玩那么你可能需要获取 &lt;code>Rust&lt;/code> 并且学习些基础知识.&lt;/p>
&lt;h2 id="顺便">顺便&lt;/h2>
&lt;p>所有代码都在一个单文件中并且没有额外的依赖, 这意味着你可以简单的开始你的项目来自己亲自尝试, 你也可以在 &lt;a class="link" href="https://play.rust-lang.org/" target="_blank" rel="noopener"
>Rust playground&lt;/a> 中运行代码, 但是记住我们的代码是依赖于 &lt;code>nightly&lt;/code> 的部分特性, 所以你需要先将编译器切换到 &lt;code>nightly&lt;/code> 版本.&lt;/p>
&lt;h1 id="绿色线程">绿色线程&lt;/h1>
&lt;p>绿色线程解决了编程中的一个通用问题. 你不希望你的代码阻塞 &lt;code>CPU&lt;/code> 来阻止 &lt;code>CPU&lt;/code> 去做一些有意义的工作. 我们通过多任务来解决这个问题, 这使得我们可以挂起运行中的一块代码去执行另一块代码, 并且在上下文之间切换.&lt;/p>
&lt;p>虽然很容易把它和并行混淆但是它们是两回事. 想象一下, 绿色线程让我们使用现有的资源更加聪明高效的工作, 而并行则是在问题上投入了更多的资源.&lt;/p>
&lt;p>通常有两种途径来做到这一点:&lt;/p>
&lt;ul>
&lt;li>抢占式多任务&lt;/li>
&lt;li>非抢占式多任务&lt;/li>
&lt;/ul>
&lt;h2 id="抢占式多任务">抢占式多任务&lt;/h2>
&lt;p>某些外部调度器会停止一个任务并在切换回来之前去执行另一个任务. 在这种情形下任务与之无关, 决策取决于其它的东西(通常是某些调度程序). 内核在操作系统中使用这种方式, 举例来说, 这允许你在单线程系统中使用 &lt;code>UI&lt;/code> 的同时来让 &lt;code>CPU&lt;/code> 去做一些计算. 我们现在不会在本文中讨论这种线程, 但是我想当你理解了一个范例, 你能够对这两个范例都有很好的掌握.&lt;/p>
&lt;h2 id="非抢占式多任务">非抢占式多任务&lt;/h2>
&lt;p>这是我们今天所要讲的. 一个任务自己去决定让 &lt;code>CPU&lt;/code> 去做一些其他事情比起让它等待当前线程发生些什么. 通常通过 &lt;code>yielding/让出&lt;/code> 控制权给调度器来完成的. 一般是在阻塞事情发生的时候让出执行权. 一个简单的例子是 &lt;code>IO操作&lt;/code>. 当控制权让出后一个中心调度器指示 &lt;code>CPU&lt;/code> 继续其它已经准备好的任务的工作而不是就在那里停滞着.&lt;/p>
&lt;h1 id="背景知识">背景知识&lt;/h1>
&lt;p>这部分是本书中最具有技术性的部分, 但是如果我们真的想要理解绿色线程的话就不得不去了解它们, 我保证我会尽可能快地说到点子上来让我们足以开始编写代码.&lt;/p>
&lt;p>Here we go! 首先, 我们将直接干预控制 &lt;code>CPU&lt;/code>. 这并不是特别好移植的因为现实有很多种 &lt;code>CPU&lt;/code>, 主要思路是一样的, 一些实现细节可能会有些许不同.&lt;/p>
&lt;p>我们在本文中会覆盖到的是使用地更加通用的架构: &lt;code>x86-64&lt;/code>&lt;/p>
&lt;p>在这个架构中 &lt;code>CPU&lt;/code> 的特点是有一组16个寄存器.&lt;/p>
&lt;p>&lt;img src="/register_usage.png"
loading="lazy"
alt="register_usage"
>&lt;/p>
&lt;p>如果你对图片的其余部分有兴趣的话你可以在 &lt;a class="link" href="https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI" target="_blank" rel="noopener"
>这里&lt;/a> 找到它.&lt;/p>
&lt;p>我们感兴趣的是那些被标记为 &lt;code>callee saved&lt;/code> 的寄存器.&lt;/p>
&lt;blockquote>
&lt;p>译者: callee-saved 又称作非易失性/被调用者保存寄存器, 当调用者进行过程调用时, 可以期望这些寄存器在被调用者返回后将保持相同的值, 这使被调用者有责任在返回调用者之前保存它们并恢复它们.&lt;/p>
&lt;/blockquote>
&lt;p>这些寄存器用于记录我们的上下文: 下一个要运行的指令, 基指针, 栈指针&amp;hellip;&amp;hellip; 我们将会在后面了解更多的细节.&lt;/p>
&lt;p>如果我们想要直接指示 &lt;code>CPU&lt;/code> 我们需要编写一小部分汇编代码, 幸运的是在我们的关卡中我们只需要了解一小部分汇编指令. 比如怎么S从寄存器中移动值:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-assembly" data-lang="assembly">mov %rsp, %rax
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>&lt;code>Windows&lt;/code> 系有些不同的习惯. 在 &lt;code>Windows&lt;/code> 系统上 &lt;code>XMM6:XMM15&lt;/code> 也是 &lt;code>callee-saved&lt;/code> 寄存器, 如果我们在函数中使用了它们也必须保存和恢复它们. 我们如果在例子中只用 &lt;code>psABI&lt;/code> 的话, 那么代码在 &lt;code>Windows&lt;/code> 上也能很好的运行.&lt;/p>
&lt;/blockquote>
&lt;h2 id="超级快的汇编介绍">超级快的汇编介绍&lt;/h2>
&lt;p>首先并且也是最重要的, 汇编语言通常并不是很便携, 每个 &lt;code>CPU&lt;/code> 都可能有自己特别的指令, 然而有些指令在当今的桌面电脑上是通用的.&lt;/p>
&lt;p>&lt;code>AT&amp;amp;T&lt;/code> 方言是编写 &lt;code>Rust&lt;/code> 内联汇编的标准语言, 但是如果我们想的话我们也可以在 &lt;code>Rust&lt;/code> 中使用 &lt;code>Intel&lt;/code> 方言. &lt;code>Rust&lt;/code> 主要把内联汇编留给 &lt;code>LLVM&lt;/code> 处理, &lt;code>LLVM&lt;/code> 的内联汇编在语法上非常接近我们在 &lt;code>C&lt;/code> 中编写的内联汇编. 这就可以让我们可以通过 &lt;code>C inline ASM&lt;/code> 来学习(但并不完全相同).&lt;/p>
&lt;p>我们将会在我们的例子中使用 &lt;code>AT&amp;amp;T&lt;/code> 方言.&lt;/p>
&lt;p>汇编有着非常强的向后兼容性保证. 这也是为什么你可能会看到用不同的方法来寻址相同的寄存器. 让我们看看 &lt;code>%rax&lt;/code> 寄存器来解释我们之前所说的.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-assembly" data-lang="assembly">%rax # 64 bit register (8 bytes)
%eax # 32 low bits of the &amp;#34;rax&amp;#34; register
%ax # 16 low bits of the &amp;#34;rax&amp;#34; register
%ah # 8 high bits of the &amp;#34;ax&amp;#34; part of the &amp;#34;rax&amp;#34; register
%al # 8 low bits of the &amp;#34;ax&amp;#34; part of the &amp;#34;rax&amp;#34; register
&lt;/code>&lt;/pre>&lt;p>就像你看到的那样, 这就像是看到了 &lt;code>CPU&lt;/code> 的发展历史~从8位到16位到32再到如今的64位. 因为现今大部分 &lt;code>CPU&lt;/code> 都是64位的, 所以我们将在我们的代码中使用 &lt;code>64&lt;/code> 位寄存器.&lt;/p>
&lt;p>&lt;code>word/字&lt;/code> 的大小在汇编中有着历史原因, 它起源于 &lt;code>CPU&lt;/code> 有16位数据总线的时候, 所以一个字是16位. 这与我们使用的 &lt;code>AT&amp;amp;T&lt;/code> 方言是有关联性的, 因为我们后面将会使用一些以字作为后缀的命令, 比如: &lt;code>q/quad-word&lt;/code>, &lt;code>l/long-word&lt;/code>, 所以 &lt;code>movq&lt;/code> 表示 4 * 16 = 64 bits.&lt;/p>
&lt;p>&lt;code>mov&lt;/code> 使用的大小取决于你使用的寄存器, 这是标准 &lt;code>Intel&lt;/code> 方言并且也是我们接下来在代码中使用的标准.&lt;/p>
&lt;p>我们将会在下一个章节中遨游更多的内联汇编的语法.&lt;/p>
&lt;p>一个小贴士: 栈对齐在 &lt;code>x86-64&lt;/code> 架构上是16位. 请在之后记住这一点~&lt;/p>
&lt;h1 id="一个建立于可编译基础上的例子">一个建立于可编译基础上的例子&lt;/h1>
&lt;blockquote>
&lt;p>在这个例子中我们将创建自己的栈并且使我们的 &lt;code>CPU&lt;/code> 从当前执行的上下文到我们刚刚创建的栈中. 我们将在接下来的文字中建立这些概念(但我们不会基于代码).&lt;/p>
&lt;/blockquote>
&lt;h2 id="设置我们的项目">设置我们的项目&lt;/h2>
&lt;p>首先我们需要创建一个项目在文件夹 &amp;ldquo;green_threads&amp;rdquo; 中, 运行:&lt;/p>
&lt;blockquote>
&lt;p>cargo init&lt;/p>
&lt;/blockquote>
&lt;p>由于我们需要使用一些不稳定特性, 所以需要先切换到 &lt;code>Nightly&lt;/code> 版编译器:&lt;/p>
&lt;blockquote>
&lt;p>rustup override set nightly&lt;/p>
&lt;/blockquote>
&lt;p>在我们的 &lt;code>main.rs&lt;/code> 中我们设置一个特性标签来让我们可以使用 &lt;code>llvm_asm!&lt;/code> 宏:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// main.rs:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#![feature(llvm_asm)]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>让我们在这里设置一个48字节的栈大小以让我们在切换上下文之前可以打印看看它:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// main.rs:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> SSIZE: &lt;span style="color:#66d9ef">isize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>在 &lt;code>OSX&lt;/code> 系统上使用这么小的栈可能会有些问题, 最小的可运行栈大小是624字节. 如果你想原模原样的照抄, 这些代码是可以在 &lt;a class="link" href="https://play.rust-lang.org/" target="_blank" rel="noopener"
>Rust Playground&lt;/a> 上运行的(但是由于我们后面编写的无限循环, 你可能需要等~30秒运行才能超时结束).&lt;/p>
&lt;/blockquote>
&lt;p>接下来让我们写一个结构体来表示我们的 &lt;code>CPU&lt;/code> 状态. 我们现在所需要关注的仅仅是保存栈指针的寄存器:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// main.rs
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#[derive(Debug, Default)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[repr(C)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ThreadContext&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rsp: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在后面的例子中我将使用我上面链接文档中被标记为 &lt;code>callee saved&lt;/code> 的所有寄存器. 那些是在 &lt;code>x86-64 ABI&lt;/code> 中描述的寄存器, 我们需要使用它们来保存上下文, 但是现在我们只需要其中一个来让 &lt;code>CPU&lt;/code> 跳转到我们的栈中.&lt;/p>
&lt;p>注意 &lt;code>#[repr(C)]&lt;/code>, 因为我们使用汇编的方式来访问我们的数据. &lt;code>Rust&lt;/code> 没有一个稳定的 &lt;code>ABI&lt;/code> 所以我们没有办法确保 &lt;code>rsp&lt;/code> 在我们的内存中以前8个字节表示. &lt;code>C&lt;/code> 有稳定的 &lt;code>ABI&lt;/code>, 这个属性就是告诉编译器该结构体使用 &lt;code>C&lt;/code> 的内存布局方式. 我们的结构体目前只有一个字段, 当然我们会在后面添加更多~&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// main.rs
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">hello&lt;/span>() -&amp;gt; &lt;span style="color:#f92672">!&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;I LOVE WAKING UP ON A NEW STACK!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">loop&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个简单的示例中我们仅仅是定义了一个打印一段话的函数, 然后无限循环.&lt;/p>
&lt;p>下一步是我们用来切换到我们的栈的内联汇编.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsafe&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">gt_switch&lt;/span>(new: &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> ThreadContext) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> llvm_asm!(&lt;span style="color:#e6db74">&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov 0x00($0), %rsp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> ret
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : &lt;span style="color:#e6db74">&amp;#34;r&amp;#34;&lt;/span>(new)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : &lt;span style="color:#e6db74">&amp;#34;alignstack&amp;#34;&lt;/span> &lt;span style="color:#75715e">// 不会在现在工作, 后面会用到.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们使用了一个小技巧. 我们在我们的新栈上写入我们想要运行的函数的地址, 然后我们把存储该地址第一个字节的地址传递给 &lt;code>rsp&lt;/code> 寄存器(我们设置为 &lt;code>new.rsp&lt;/code> 的地址将会指向我们栈的地址, 这个栈的地址指向上面的函数). 明白了吗?&lt;/p>
&lt;p>&lt;code>ret&lt;/code> 关键字将程序的控制权转给栈顶返回的地址. 因为我们把我们的地址 &lt;code>pushed&lt;/code> 到 &lt;code>%rsp&lt;/code> 寄存器中, &lt;code>CPU&lt;/code> 将会认为这个地址是当前正在运行的函数返回的地址, 所以当我们使用 &lt;code>ret&lt;/code> 指令时它将直接返回到我们自己的栈中(也就是new的地址).&lt;/p>
&lt;p>然后 &lt;code>CPU&lt;/code> 做的第一件事就是读取我们函数的地址并运行它.&lt;/p>
&lt;blockquote>
&lt;p>译者: 关于汇编这里, 新版本的 &lt;code>Rust&lt;/code> 使用的是 &lt;code>asm!&lt;/code> 宏, 模板语法也有些变化, &lt;code>llvm_asm!&lt;/code> 废弃了, 后续会更新为 &lt;code>asm!&lt;/code> 宏的版本&amp;hellip;大概.&lt;/p>
&lt;/blockquote>
&lt;h2 id="快速介绍-rust-的内联汇编宏">快速介绍 &lt;code>Rust&lt;/code> 的内联汇编宏&lt;/h2>
&lt;p>如果你以前没用过内联汇编你可能会觉得那些看上去像是火星文, 但是我们稍后会使用这个拓展版本来切换上下文, 所以现在我们将逐行解释我们做了什么.&lt;/p>
&lt;p>&lt;code>unsafe&lt;/code> 是一个关键字, 它让 &lt;code>Rust&lt;/code> 不能强制确保我们编写的函数的安全性. 因为我们直接操作 &lt;code>CPU&lt;/code>, 这绝对是不安全的.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">gt_switch&lt;/span>(new: &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> ThreadContext)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这里我们获取了一个指向 &lt;code>ThreadContext&lt;/code> 实例的指针, 从中我们只读取了一个字段.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>llvm_asm!()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是 &lt;code>Rust&lt;/code> 标准库中的 &lt;code>llvm_asm!&lt;/code> 宏. 它会检查我们的汇编语法, 如果遇到一些看起来不像是 &lt;code>AT&amp;amp;T&lt;/code> 方言的语法, 它将提供一个错误信息.&lt;/p>
&lt;p>宏首先接收的参数是一个汇编模板:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-assembly" data-lang="assembly">mov 0x00($0), %rsp
&lt;/code>&lt;/pre>&lt;p>这是一个简单的指令, 它将存储在 &lt;code>$0&lt;/code> 位置 的 &lt;code>0x00(16进制表示, 这里表示不偏移)&lt;/code> 偏移量的值移动到 &lt;code>rsp&lt;/code> 寄存器中. 因为 &lt;code>rsp&lt;/code> 寄存器保存一个指向栈中下一个值的指针, 我们有效地将我们提供的地址 &lt;code>push&lt;/code> 到当前的栈顶来覆盖原先存在的地址.&lt;/p>
&lt;p>你可能认为 &lt;code>$0&lt;/code> 看起来不是一个普通的汇编代码. 这是汇编模板的部分, 表示第一个参数的占位符. 这个参数从0, 1, 2&amp;hellip;计数, 首先是 &lt;code>output&lt;/code> 参数, 紧接着是 &lt;code>input&lt;/code> 参数. 我们在这里只使用了对应于 &lt;code>$0&lt;/code> 的输入参数.&lt;/p>
&lt;p>如果在汇编中碰到 &lt;code>$&lt;/code> 符号可能大部分时候表示一个立即数(常量整数)但是这是有依赖的(yeah, &lt;code>$&lt;/code> 在不同的方言或者是不同的架构如 &lt;code>x86&lt;/code> 与 &lt;code>x86-64&lt;/code> 之间都表示不同的意义).&lt;/p>
&lt;blockquote>
&lt;p>译者: 在 &lt;code>llvm_asm!&lt;/code> 宏中, 使用 &lt;code>:&lt;/code> 来分割参数, 所以第一个 &lt;code>:&lt;/code> 后面的是输出参数(我们没有用到), 第二个为输入参数&amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code class="language-assembly" data-lang="assembly">ret
&lt;/code>&lt;/pre>&lt;p>&lt;code>ret&lt;/code> 关键字命令 &lt;code>CPU&lt;/code> 弹出栈顶的内存位置并且无条件地跳转到该位置. 实际上我们劫持了 &lt;code>CPU&lt;/code> 让它返回到我们的栈中.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-assembly" data-lang="assembly">output
:
&lt;/code>&lt;/pre>&lt;p>内联 &lt;code>ASM&lt;/code> 和普通的 &lt;code>ASM&lt;/code> 有一点不同. 我们有四个额外的参数需要传递到汇编模板中. 第一个是输出参数, 我们在这里传递我们想要用作 &lt;code>Rust&lt;/code> 函数返回值的参数.&lt;/p>
&lt;p>举个例子:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(a: &lt;span style="color:#66d9ef">i32&lt;/span>, b: &lt;span style="color:#66d9ef">i32&lt;/span>) -&amp;gt; &lt;span style="color:#66d9ef">i32&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> c: &lt;span style="color:#66d9ef">i32&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> llvm_asm!(&lt;span style="color:#e6db74">&amp;#34;add $2, $0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : &lt;span style="color:#e6db74">&amp;#34;=r&amp;#34;&lt;/span>(c)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : &lt;span style="color:#e6db74">&amp;#34;0&amp;#34;&lt;/span>(a), &lt;span style="color:#e6db74">&amp;#34;r&amp;#34;&lt;/span>(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的输出参数为 &lt;code>c&lt;/code>, 最终结果会保存在变量 &lt;code>c&lt;/code> 中.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-assembly" data-lang="assembly">input
: &amp;#34;r&amp;#34;(new)
&lt;/code>&lt;/pre>&lt;p>第二个表示我们的输入参数, 在内联汇编中 &lt;code>r&lt;/code> 被称作约束. 你可以使用一些约束来有效地命令编译器能够决定将我们的输入放到哪里(在一个寄存器中作为值或者使用它作为一个内存地址). &lt;code>r&lt;/code> 意味着它将被放置在由编译器选择的通用寄存器中. 内联汇编的约束是一个很大的主题, 幸运的是我们只需要简单的了解.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-assembly" data-lang="assembly">clobber list
:
&lt;/code>&lt;/pre>&lt;p>下一个参数是 &lt;code>clobber&lt;/code> 列表, 可以放置我们不想让编译器接触的寄存器, 并且让编译器知道我们想要在自己的汇编代码中管理那些寄存器. 如果我们弹出栈的任何值, 我们需要让编译器知道哪些寄存器它不能随便使用, 那么就需要在这里指定. 由于我们返回了一个全新的栈所以在这里不需要它.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-assembly" data-lang="assembly">options
: &amp;#34;alignstack&amp;#34;
&lt;/code>&lt;/pre>&lt;p>最后一个参数是 &lt;code>options&lt;/code>. 这是 &lt;code>Rust&lt;/code> 特有的, 有三个选项可以设置: &amp;ldquo;alignstack&amp;rdquo;, &amp;ldquo;volatile&amp;rdquo;, &amp;ldquo;intel&amp;rdquo;. 我倾向你访问该 &lt;a class="link" href="https://doc.rust-lang.org/nightly/unstable-book/library-features/llvm-asm.html#options" target="_blank" rel="noopener"
>文档&lt;/a> 来获取解释. 值得注意的是我们需要 &amp;ldquo;alignstack&amp;rdquo; 来让我们的代码在 &lt;code>Windows&lt;/code> 上工作.&lt;/p>
&lt;h2 id="运行我们的例子">运行我们的例子&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> ctx &lt;span style="color:#f92672">=&lt;/span> ThreadContext::default();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> stack &lt;span style="color:#f92672">=&lt;/span> vec![&lt;span style="color:#ae81ff">0_&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>; SSIZE &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> stack_bottom &lt;span style="color:#f92672">=&lt;/span> stack.as_mut_ptr().offset(SSIZE);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> sb_aligned &lt;span style="color:#f92672">=&lt;/span> (stack_bottom &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#ae81ff">15&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std::ptr::write(sb_aligned.offset(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>, hello &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctx.rsp &lt;span style="color:#f92672">=&lt;/span> sb_aligned.offset(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gt_switch(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> ctx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这下我们确切的设计了我们自己的栈. &lt;code>hello&lt;/code> 是一个指针(一个函数指针)所以我们可以直接把它转成 &lt;code>u64&lt;/code>, 因为所有的指针在64位操作系统上是 &lt;code>u64&lt;/code>. 然后我们把这个指针写到我们的栈里.&lt;/p>
&lt;blockquote>
&lt;p>我们会在下一个章节更多的讨论这个栈, 但是现在有件需要我们知道的事是栈是向下增长的. 如果我们的栈从索引0开始, 结束于索引47. 那么32就是从堆栈末尾开始偏移16个字节的第一位.&lt;/p>
&lt;/blockquote>
&lt;p>请注意, 我们将指针写入到距离栈底部16个字节偏移的位置.&lt;/p>
&lt;blockquote>
&lt;p>这行做了什么 &lt;code>let sb_aligned = (stack_bottom as usize &amp;amp;! 15) as *mut u8&lt;/code>?&lt;/p>
&lt;p>我们申请了一个 &lt;code>Vec&amp;lt;u8&amp;gt;&lt;/code> 的内存, 但是没有任何保证我们得到的是16字节对齐的地址, 这行将地址四舍五入到最近的16字节对齐. 如果已经16字节对齐了那什么也不会做.&lt;/p>
&lt;/blockquote>
&lt;p>我们把指针强制转换成 &lt;code>u64&lt;/code> 而不是 &lt;code>u8&lt;/code>. 我们想要写入的是32,33,34,35,36,37,38,39这八个字节, 如果我们不做这个转换那么则仅仅是尝试把 &lt;code>u64&lt;/code> 的指针写入到32处, 这不是我们想要的.&lt;/p>
&lt;p>我们设置了 &lt;code>rsp&lt;/code> 为我们的栈索引32的位置, 我们不传递存储在那里的64位的值, 而是第一个字节的地址.&lt;/p>
&lt;p>当我们用 &lt;code>cargo run&lt;/code> 运行我们的代码:&lt;/p>
&lt;pre tabindex="0">&lt;code>Finished dev [unoptimized + debuginfo] target(s) in 0.58s
Running `target\debug\green_thread_start.exe`
I LOVE WAKING UP ON A NEW STACK!
&lt;/code>&lt;/pre>&lt;p>ok, 所以发生了什么? 我们在任何地方都没有调用 &lt;code>hello&lt;/code> 函数但是它确实运行了. 我们实际上让 &lt;code>CPU&lt;/code> 直接跳到我们的栈并且运行那里的代码. 我们实现了上下文切换的第一步.&lt;/p>
&lt;p>在下一个章节我们在实现我们的绿色线程前将会讲一下我们的栈. 我们已经讲了那么多基础知识了, 所以事情会很简单.&lt;/p>
&lt;h1 id="栈">栈&lt;/h1>
&lt;blockquote>
&lt;p>栈不过是一块连续的内存空间.&lt;/p>
&lt;/blockquote>
&lt;p>这一点很重要, 电脑只有内存, 没有所谓的 &amp;ldquo;栈&amp;rdquo; 内存和 &amp;ldquo;堆&amp;rdquo; 内存, 它们都是同一个内存的一部分.&lt;/p>
&lt;p>它们的不同是怎么访问和使用内存. 栈在连续的内存空间支持简单的 &lt;code>push/pop&lt;/code> 命令, 这使得它们用起来会很快. 堆则是由内存分配器根据需要而分配的, 可能分散在不同的位置.&lt;/p>
&lt;p>我们不会在这里探讨堆和栈的不同, 因为有许多文章都有讨论包括 &lt;a class="link" href="https://doc.rust-lang.org/stable/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap" target="_blank" rel="noopener"
>The Rust Programming Language&lt;/a> 的其中一章.&lt;/p>
&lt;h2 id="一个栈看起来长什么样子">一个栈看起来长什么样子&lt;/h2>
&lt;p>&lt;img src="/simplified_view_of_a_stack.png"
loading="lazy"
alt="simplified_view_of_a_stack"
>&lt;/p>
&lt;p>让我们从一个简化的栈视图开始. 一个64位 &lt;code>CPU&lt;/code> 每次读取8个字节, 尽管我们普通看到的栈是一长行的 &lt;code>u8&lt;/code>, 但我们传递指针的时候需要确保我们传递的是 &lt;code>0016&lt;/code>, &lt;code>0008&lt;/code> 或者 &lt;code>0000&lt;/code>.&lt;/p>
&lt;p>栈是向下增长的, 所以我们从顶部开始向下进行.&lt;/p>
&lt;p>当我们设置一个16字节对齐的栈指针, 我们需要确保把我们的栈指针放在16倍数的地址, 在上面的地址中, 唯一满足条件的地址是 &lt;code>0008&lt;/code> (记住栈是从顶部开始的).&lt;/p>
&lt;p>如果我们在上一章例子中主函数切换之前加入如下几行代码, 我们可以有效地打印我们的栈并查看它.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#66d9ef">in&lt;/span> (&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">..&lt;/span>SSIZE).rev() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;mem: {}, val: {}&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack_ptr.offset(i &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">isize&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>stack_ptr.offset(i &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">isize&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们得到的输出:&lt;/p>
&lt;pre tabindex="0">&lt;code>mem: 94846750517871, val: 0
mem: 94846750517870, val: 0
mem: 94846750517869, val: 0
mem: 94846750517868, val: 0
mem: 94846750517867, val: 0
mem: 94846750517866, val: 0
mem: 94846750517865, val: 0
mem: 94846750517864, val: 0
mem: 94846750517863, val: 0
mem: 94846750517862, val: 0
mem: 94846750517861, val: 86
mem: 94846750517860, val: 67
mem: 94846750517859, val: 56
mem: 94846750517858, val: 252
mem: 94846750517857, val: 205
mem: 94846750517856, val: 240
mem: 94846750517855, val: 0
mem: 94846750517854, val: 0
mem: 94846750517853, val: 0
mem: 94846750517852, val: 0
mem: 94846750517851, val: 0
mem: 94846750517850, val: 0
mem: 94846750517849, val: 0
mem: 94846750517848, val: 0
mem: 94846750517847, val: 0
mem: 94846750517846, val: 0
mem: 94846750517845, val: 0
mem: 94846750517844, val: 0
mem: 94846750517843, val: 0
mem: 94846750517842, val: 0
mem: 94846750517841, val: 0
mem: 94846750517840, val: 0
mem: 94846750517839, val: 0
mem: 94846750517838, val: 0
mem: 94846750517837, val: 0
mem: 94846750517836, val: 0
mem: 94846750517835, val: 0
mem: 94846750517834, val: 0
mem: 94846750517833, val: 0
mem: 94846750517832, val: 0
mem: 94846750517831, val: 0
mem: 94846750517830, val: 0
mem: 94846750517829, val: 0
mem: 94846750517828, val: 0
mem: 94846750517827, val: 0
mem: 94846750517826, val: 0
mem: 94846750517825, val: 0
mem: 94846750517824, val: 0
I LOVE WAKING UP ON A NEW STACK!
&lt;/code>&lt;/pre>&lt;p>我以 &lt;code>u64&lt;/code> 打印了内存地址所以如果你对16进制不是很熟悉的话那这个更容易解析点.&lt;/p>
&lt;p>第一件事就是注意到这仅仅是一段连续的内存, 从 &lt;code>94846750517824&lt;/code> 开始, &lt;code>94846750517871&lt;/code> 结束.&lt;/p>
&lt;p>地址 &lt;code>94846750517856&lt;/code> 到 &lt;code>94846750517863&lt;/code> 是我们感兴趣的一块. 第一个地址是我们栈指针的地址, 它的值我们写入到了 &lt;code>CPU&lt;/code> 的 &lt;code>%rsp&lt;/code> 寄存器中. 这个范围表示我们在切换上下文之前写入到栈的值.&lt;/p>
&lt;p>换句话说, 240,205,252,56,67,86,0,0 是我们写为&lt;code>u8&lt;/code> 的 &lt;code>hello()&lt;/code> 函数的指针.&lt;/p>
&lt;blockquote>
&lt;p>这里有一个有趣的附带说明, &lt;code>CPU&lt;/code> 将 &lt;code>u64&lt;/code> 作为 &lt;code>u8&lt;/code> 写入的顺序取决于它是用的大端法还是小端法. 如果你手动解析这些数字, 请务必记住这一点.&lt;/p>
&lt;/blockquote>
&lt;p>在我们写更加复杂的程序时我们非常小的48字节的栈很快就会用完了, 你明白的, 当我们运行在 &lt;code>Rust&lt;/code> 中编写的函数时, 代码将指示 &lt;code>CPU&lt;/code> 在我们的栈上 &lt;code>pop&lt;/code> 和 &lt;code>push&lt;/code> 值来运行我们的程序.&lt;/p>
&lt;h2 id="栈大小">栈大小&lt;/h2>
&lt;p>在大多数现代操作系统中启动一个进程时标准栈的大小通常是8MB, 但也是可以配置为别的. 对于大多数程序来说这已经够了但是要由程序员来确保使用的栈不会超出拥有的栈大小. 这是我们大多数程序员经历 &amp;ldquo;stack overflow&amp;rdquo; 的原因.&lt;/p>
&lt;p>然而, 当我们自己控制栈的时候我们能选择我们自己想要的大小. 首先, 8MB对于一个运行在 &lt;code>web&lt;/code> 服务的例子来说已经远远超出所需了, 所以我们可以减少栈大小来在一个机器上有上百万的绿色线程, 而用操作系统提供的栈则会很快地耗尽内存.&lt;/p>
&lt;h2 id="可增长栈">可增长栈&lt;/h2>
&lt;p>有一些实现使用的是可增长栈, 这允许我们为大多数任务分配足够用的一小部分内存给栈空间, 但是在用完后不会发生 &amp;ldquo;stack overflow&amp;rdquo;, 而是分配一个新的更大的栈并且把所有东西都移到这个新栈里, 在新栈里可以恢复程序的执行.&lt;/p>
&lt;p>&lt;code>GO&lt;/code> 就是这样的一个例子. 它从8KB的栈开始当超出后就会重新分配一个更大的栈. 就像编程中的每件事一样, 这也是需要一定的取舍, 所有的指针需要自己保证正确地更新, 这不是一个简单的任务. 如果你对 &lt;code>GO&lt;/code> 如何操作栈有兴趣(一个很好的例子在权衡和使用可增长栈上). 我建议你读这篇文章: &lt;a class="link" href="https://blog.cloudflare.com/how-stacks-are-handled-in-go/" target="_blank" rel="noopener"
>how-stacks-are-handled-in-go&lt;/a>.&lt;/p>
&lt;blockquote>
&lt;p>要说明一些重要的事: 我们使用了标准库中普通的 &lt;code>Vec&amp;lt;u8&amp;gt;&lt;/code> 来作为栈, 这很方便但是会有一些问题. 换句话说, 我们没法保证它在内存中的位置一直不变.&lt;/p>
&lt;p>就像你所想的, 如果栈移动到一个不同的地址空间, 那么我们的程序可能就会崩溃因为所有的指针就会失效. 很简单的 &lt;code>push&lt;/code> 操作可能会使 &lt;code>vec&lt;/code> 拓展到一个新的更大的内存空间, 然后其中的值会被移动到那里.&lt;/p>
&lt;/blockquote>
&lt;p>OK, 现在我们已经学习了栈长什么样子, 是如何工作的, 我们已经准备好去实现我们的绿色线程了. 你已经做完了艰难的工作所以我保证我们可以写更多的代码了.&lt;/p>
&lt;h2 id="如何设置栈">如何设置栈&lt;/h2>
&lt;p>&lt;code>Windows x64-86&lt;/code> 的栈设置与 &lt;code>x64-86 psABI&lt;/code> 的调用约定有一些不同. 我将在附录 &lt;a class="link" href="https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/supporting-windows" target="_blank" rel="noopener"
>Windows支持&lt;/a> 中更多的讲关于 &lt;code>Windows&lt;/code> 的栈. 不过有件重要的事要说, 如果像我们这样只是用简单不带参数的函数来设置堆栈, 那么它们不会有太多的不同.&lt;/p>
&lt;p>&lt;strong>psABI 栈布局长这样:&lt;/strong>&lt;/p>
&lt;p>&lt;img src="/bilde.png"
loading="lazy"
alt="Stack Frame with Base Pointer"
>&lt;/p>
&lt;p>如你所看到的 &lt;code>%rsp&lt;/code> 是我们的栈指针. 我们需要把栈指针放在从基地址开始16的倍数的地方. 返回的地址位于相邻的8个字节中, 其上还有一个存储内存参数的房间. 当我们想要做更复杂的事情的时候我们必须牢记这点.&lt;/p>
&lt;p>你会注意到我们通常把函数地址写入到 &lt;code>stack_ptr + SSIZE - 16&lt;/code> 而没有进行说明. 顺便说一下 &lt;code>SSIZE&lt;/code> 是栈的字节大小.&lt;/p>
&lt;p>这么说吧, 我们知道一个指针(在例子里是函数指针)的大小是8字节. 我们也知道我们需要把 &lt;code>rsp&lt;/code> 写入到16字节的边界中.&lt;/p>
&lt;p>我们除了把函数指针写入到 &lt;code>stack_ptr + SSIZE - 16&lt;/code> 以外没有其它的选择. 因为我们从低到高写入我们的地址:&lt;/p>
&lt;ul>
&lt;li>不能将它写入到 &lt;code>stack_ptr + SSIZE&lt;/code>(也是16字节的倍数) 因为这可能导致写入的字节超出我们分配的内存, 那是不被允许的(因为我们为了16字节对齐而进行了四舍五入).&lt;/li>
&lt;li>不能写入到 &lt;code>stack_ptr + SSIZE - 8&lt;/code>, 虽然它也是一个有效的内存空间, 但是它没有对齐16字节的边界.&lt;/li>
&lt;/ul>
&lt;p>由于这些原因因此 &lt;code>stack_ptr + SSIZE - 16&lt;/code> 是第一个合适的位置. 在我们的代码中, 我们写入了8个字节在位置: -16,-15,&amp;hellip;,-10,-9 从我们栈的高地址开始(这通常称为栈的底部, 因为栈是向下增长, 这可能有些令人困惑).&lt;/p>
&lt;h2 id="幕后花絮">幕后花絮&lt;/h2>
&lt;p>如果你足够好奇, 你可能会思考在我们切换栈之后发生了什么?&lt;/p>
&lt;p>答案是我们在 &lt;code>Rust&lt;/code> 写的代码编译为 &lt;code>CPU&lt;/code> 指令, 然后它接管并像使用其它栈一样使用我们的栈.&lt;/p>
&lt;p>然而不幸的是如果想证明这一点那我不得不把栈大小增加到1024字节来允许代码有足够的空间打印出栈本身. 所以我们不会在这打印它来证明这点.&lt;/p>
&lt;h2 id="看一眼栈">看一眼栈&lt;/h2>
&lt;p>我又做了一个我们代码例子的修改版本, 你可以打印内容到两个文本文件中, &lt;code>BEFORE.txt&lt;/code> 打印我们的在切换之前的栈, &lt;code>AFTER.txt&lt;/code> 打印切换后的栈. 然后你就可以自己看看栈是如何被我们的代码激活和使用.&lt;/p>
&lt;blockquote>
&lt;p>如果你发现里面有些你看不懂的东西, 放松, 我们会很快彻底的进行解释.&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#![feature(llvm_asm)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#![feature(naked_functions)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::io::Write;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> SSIZE: &lt;span style="color:#66d9ef">isize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1024&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> S_PTR: &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[derive(Debug, Default)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[repr(C)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ThreadContext&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rsp: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r15: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r14: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r13: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r12: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rbx: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rbp: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">print_stack&lt;/span>(filename: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> f &lt;span style="color:#f92672">=&lt;/span> std::fs::File::create(filename).unwrap();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#66d9ef">in&lt;/span> (&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">..&lt;/span>SSIZE).rev() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> writeln!(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;mem: {}, val: {}&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> S_PTR.offset(i &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">isize&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>S_PTR.offset(i &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">isize&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .expect(&lt;span style="color:#e6db74">&amp;#34;Error writing to file.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">hello&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;I LOVE WAKING UP ON A NEW STACK!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_stack(&lt;span style="color:#e6db74">&amp;#34;AFTER.txt&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">loop&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsafe&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">gt_switch&lt;/span>(new: &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> ThreadContext) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> llvm_asm!(&lt;span style="color:#e6db74">&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov 0x00($0), %rsp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> ret
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : &lt;span style="color:#e6db74">&amp;#34;r&amp;#34;&lt;/span>(new)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : &lt;span style="color:#e6db74">&amp;#34;alignstack&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> ctx &lt;span style="color:#f92672">=&lt;/span> ThreadContext::default();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> stack &lt;span style="color:#f92672">=&lt;/span> vec![&lt;span style="color:#ae81ff">0_&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>; SSIZE &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> stack_ptr &lt;span style="color:#f92672">=&lt;/span> stack.as_mut_ptr();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> S_PTR &lt;span style="color:#f92672">=&lt;/span> stack_ptr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std::ptr::write(stack_ptr.offset(SSIZE &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>, hello &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_stack(&lt;span style="color:#e6db74">&amp;#34;BEFORE.txt&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctx.rsp &lt;span style="color:#f92672">=&lt;/span> stack_ptr.offset(SSIZE &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gt_switch(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> ctx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="一个绿色线程的实现">一个绿色线程的实现&lt;/h1>
&lt;p>在开始之前, 我先说明我们编写的代码非常不安全并且也不是最佳实践, 我希望尽可能编写安全代码的同时不引入额外的复杂度, 所以我鼓励亲爱的读者们如果你们有更好的方案来让代码变得更加安全并且也不会太复杂的话, &lt;a class="link" href="https://github.com/cfsamson/example-greenthreads" target="_blank" rel="noopener"
>欢迎给我的仓库提PR&lt;/a>.&lt;/p>
&lt;h2 id="让我们开始吧">让我们开始吧&lt;/h2>
&lt;p>首先我们把 &lt;code>main.rs&lt;/code> 文件中的内容替换如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#![feature(llvm_asm)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#![feature(naked_functions)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::ptr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> DEFAULT_STACK_SIZE: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1024&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">1024&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> MAX_THREADS: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> RUNTIME: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们启用了两个特性, &lt;code>asm&lt;/code> 在之前有讲到, 接下来我们需要解释下 &lt;code>naked_functions&lt;/code> 特性.&lt;/p>
&lt;h1 id="naked_functions">naked_functions&lt;/h1>
&lt;p>当 &lt;code>Rust&lt;/code> 编译一个函数的时候, 可能会给每个函数添加开场白和后记, 而这可能会导致没有对齐栈以至于我们在切换上下文的时候出现问题. 在我们的第一个简单示例中可能没出现什么问题, 但是一旦我们需要再次切换到相同的栈, 就会遇到麻烦. 将函数标记为 &lt;code>#[naked]&lt;/code> 可以移除开场白和后记. 此属性主要用于内联汇编.&lt;/p>
&lt;blockquote>
&lt;p>如果你对该属性感兴趣, 想了解更多, 可以参照 &lt;a class="link" href="https://github.com/rust-lang/rfcs/blob/master/text/1201-naked-fns.md" target="_blank" rel="noopener"
>RFC #1201&lt;/a>.&lt;/p>
&lt;/blockquote>
&lt;p>我们将 &lt;code>DEFAULT_STACK_SIZE&lt;/code> 设置为2MB, &lt;code>MAX_THREADS&lt;/code> 设置为4, 这已经足够我们并且远超我们编写的绿色线程所需了.&lt;/p>
&lt;p>最后一个常量 &lt;code>RUNTIME&lt;/code> 是我们运行时的指针(是的我知道使用可变全局变量不是很好, 但是我们需要这样并且仅仅在运行时初始化的时候设置该变量).&lt;/p>
&lt;blockquote>
&lt;p>译者: &lt;code>Rust&lt;/code> 新特性const function是不是可以解决这个问题?&lt;/p>
&lt;/blockquote>
&lt;p>让我们开始充实我们的代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Runtime&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> threads: Vec&lt;span style="color:#f92672">&amp;lt;&lt;/span>Thread&lt;span style="color:#f92672">&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current: &lt;span style="color:#66d9ef">usize&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[derive(PartialEq, Eq, Debug)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">State&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Available,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Running,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Ready,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Thread&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id: &lt;span style="color:#66d9ef">usize&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack: Vec&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctx: &lt;span style="color:#a6e22e">ThreadContext&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: &lt;span style="color:#a6e22e">State&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[derive(Debug, Default)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[repr(C)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ThreadContext&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rsp: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r15: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r14: &lt;span style="color:#66d9ef">u64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r13&lt;/span>: &lt;span style="color:#66d9ef">u64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r12&lt;/span>: &lt;span style="color:#66d9ef">u64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rbx&lt;/span>: &lt;span style="color:#66d9ef">u64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rbp&lt;/span>: &lt;span style="color:#66d9ef">u64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Runtime&lt;/code> 将会成为我们主要的入口点. 基本上, 我们将会创建一个非常小的运行时来调度切换我们的线程. 这个运行时持有一个 &lt;code>Threads&lt;/code> 的数组和一个 &lt;code>current&lt;/code> 属性来表明当前运行的线程.&lt;/p>
&lt;p>&lt;code>Thread&lt;/code> 持有了一个线程应有的数据. 每个线程有一个 &lt;code>id&lt;/code> 来让我们分辨它们. &lt;code>stack&lt;/code> 和我们在第一个例子中看到的类似. &lt;code>ctx&lt;/code> 域是一个表示我们 &lt;code>CPU&lt;/code> 所需要恢复的数据在堆栈上位置的上下文, 这些数据要在调度的时候得以恢复. &lt;code>state&lt;/code> 表示我们线程的状态.&lt;/p>
&lt;p>&lt;code>State&lt;/code> 是一个用来表示我们线程状态的枚举:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Available&lt;/code> 意味着线程已经准备好被分配一个任务如果需要的话.&lt;/li>
&lt;li>&lt;code>Running&lt;/code> 意味着该线程已经运行了.&lt;/li>
&lt;li>&lt;code>Ready&lt;/code> 意味着该线程准备好继续向前并恢复执行.&lt;/li>
&lt;/ul>
&lt;p>&lt;code>ThreadContext&lt;/code> 持有着 &lt;code>CPU&lt;/code> 恢复在栈上执行所需的寄存器数据.&lt;/p>
&lt;blockquote>
&lt;p>如果你不记得寄存器了, 返回 &lt;a class="link" href="#%e8%83%8c%e6%99%af%e7%9f%a5%e8%af%86" >Background Information&lt;/a> 章节来阅读寄存器相关. 那里有一些在 &lt;code>x86-64&lt;/code> 架构上标记为 &lt;code>callee saved&lt;/code> 的寄存器.&lt;/p>
&lt;/blockquote>
&lt;p>让我们继续:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Thread {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">new&lt;/span>(id: &lt;span style="color:#66d9ef">usize&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">Self&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack: &lt;span style="color:#a6e22e">vec&lt;/span>&lt;span style="color:#f92672">!&lt;/span>[&lt;span style="color:#ae81ff">0_&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>; DEFAULT_STACK_SIZE],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctx: &lt;span style="color:#a6e22e">ThreadContext&lt;/span>::default(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: &lt;span style="color:#a6e22e">State&lt;/span>:&lt;span style="color:#a6e22e">Available&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这相当简单. 一个新的线程从 &lt;code>Available&lt;/code> 状态开始表明它已经准备好被分配一个任务.&lt;/p>
&lt;p>需要注意的点, 我们在这里分配栈. 这并不必要而且也不是资源使用的好方法, 我们应该在线程需要的时候分配而不是第一次使用 &lt;code>new&lt;/code> 时就分配. 然而这降低了我们这部分代码的复杂度, 这更加重要比起去关注如何给我们的栈分配内存.&lt;/p>
&lt;blockquote>
&lt;p>重要的一点, 一旦给栈分配了内存就不能再移动它! 不能使用 &lt;code>push()&lt;/code> 或其它可能触发 &lt;code>vector&lt;/code> 重分配内存的方法. 在该代码更好的版本中, 我们可以包装 &lt;code>vector&lt;/code> 并且仅公开我们认为可以安全使用的方法.&lt;/p>
&lt;p>值得一提的是, &lt;code>Vec&amp;lt;T&amp;gt;&lt;/code> 有一个 &lt;code>into_boxed_slice()&lt;/code> 方法, 该方法返回一个堆分配的切片 &lt;code>Box&amp;lt;T&amp;gt;&lt;/code>. 切片不能增长, 所以我们如果用它代替的话可以解决重分配问题.&lt;/p>
&lt;/blockquote>
&lt;h2 id="实现运行时">实现运行时&lt;/h2>
&lt;p>该部分中所有的代码都是 &lt;code>impl Runtime&lt;/code> 块中的, 这意味着它们都是 &lt;code>Runtime&lt;/code> 结构体的方法.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Runtime {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">new&lt;/span>() -&amp;gt; &lt;span style="color:#a6e22e">Self&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// This will be our base thread, which will be initialized in
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// the `running` state
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> base_thread &lt;span style="color:#f92672">=&lt;/span> Thread {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id: &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack: &lt;span style="color:#a6e22e">vec&lt;/span>&lt;span style="color:#f92672">!&lt;/span>[&lt;span style="color:#ae81ff">0_&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>; DEFAULT_STACK_SIZE],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctx: &lt;span style="color:#a6e22e">ThreadContext&lt;/span>::default(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: &lt;span style="color:#a6e22e">State&lt;/span>::Running,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> threads &lt;span style="color:#f92672">=&lt;/span> vec![base_thread];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> available_threads: Vec&lt;span style="color:#f92672">&amp;lt;&lt;/span>Thread&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">..&lt;/span>MAX_THREADS).map(&lt;span style="color:#f92672">|&lt;/span>i&lt;span style="color:#f92672">|&lt;/span> Thread::new(i)).collect();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> threads.append(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> available_threads);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Runtime {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> threads,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current: &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当我们实例化 &lt;code>Runtime&lt;/code> 的时候我们设置了一个基线程. 这个线程被设置为 &lt;code>Running&lt;/code> 状态并且确保在所有任务完成之前保持运行时持续地运行.&lt;/p>
&lt;p>然后我们实例化其它线程, 并将当前线程设置为0 , 这是我们的基线程.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">/// This is cheating a bit, but we need a pointer to our Runtime
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span> &lt;span style="color:#e6db74">/// stored so we can call yield on it even if we don&amp;#39;t have a
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span> &lt;span style="color:#e6db74">/// reference to it
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> r_ptr: &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> Runtime &lt;span style="color:#f92672">=&lt;/span> self;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RUNTIME &lt;span style="color:#f92672">=&lt;/span> r_ptr &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在我们需要这个, 就像我提到过的当我们遍历我们的常量的时候我们需要能够在后续调用 &lt;code>yield&lt;/code>, 它并不漂亮, 但是我们知道只要有任何线程 &lt;code>yield&lt;/code> 我们的运行时就会存活着, 只要我们不滥用它那就是安全的.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self) -&amp;gt; &lt;span style="color:#f92672">!&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> self.t_yield() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std::process::exit(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是我们开始运行时的地方, 它将持续调用 &lt;code>t_yield()&lt;/code> 直到返回 &lt;code>false&lt;/code>, 那时候意味着没有更多的任务需要再做了, 所以我们可以退出程序了.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">t_return&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> self.current &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.threads[self.current].state &lt;span style="color:#f92672">=&lt;/span> Stete::Available;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.t_yield();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是当我们线程运行完成后调用的返回函数. &lt;code>return&lt;/code> 是 &lt;code>rust&lt;/code> 中的保留字所以我们改为了 &lt;code>t_return()&lt;/code>. 注意我们线程的用户不能调用它, 当任务完成后我们在我们设置的栈中调用它.&lt;/p>
&lt;p>如果正在调用的线程是 &lt;code>base_thread&lt;/code> 那么将什么都不做. 我们的运行时将会在基线程中调用 &lt;code>yield&lt;/code>. 如果从一个分发的线程中调用了 &lt;code>t_return()&lt;/code> 我们可以知道这个线程已经完成任务了, 我们只会在 &lt;code>guard&lt;/code> (后续展示)函数中调用 &lt;code>t_return()&lt;/code>, 并且 &lt;code>guard&lt;/code>已经在栈顶了.&lt;/p>
&lt;p>我们设置状态为 &lt;code>Available&lt;/code> 让运行时知道这个线程已经准备好被分配一个新的任务然后立即调用 &lt;code>t_yield&lt;/code> 来调度要运行的新线程.&lt;/p>
&lt;p>Next: 我们的 &lt;code>yield&lt;/code> 函数:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">t_yield&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self) -&amp;gt; &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> pos &lt;span style="color:#f92672">=&lt;/span> self.current;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> self.threads[pos].state &lt;span style="color:#f92672">!=&lt;/span> State::Ready {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pos &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> pos &lt;span style="color:#f92672">==&lt;/span> self.threads.len() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pos &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> pos &lt;span style="color:#f92672">==&lt;/span> self.current {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> self.threads[self.current].state &lt;span style="color:#f92672">!=&lt;/span> State::Available {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.threads[self.current].state &lt;span style="color:#f92672">=&lt;/span> State::Ready;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.threads[pos].state &lt;span style="color:#f92672">=&lt;/span> State::Running;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> old_pos &lt;span style="color:#f92672">=&lt;/span> self.current;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.current &lt;span style="color:#f92672">=&lt;/span> pos;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> switch(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self.threads[old_pos].ctx, &lt;span style="color:#f92672">&amp;amp;&lt;/span>self.threads[pos].ctx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Prevents compiler from optimizing our code away on Windows.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> self.threads.len() &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是我们运行时的核心. 我们使用 &lt;code>t_yield()&lt;/code> 而不是 &lt;code>yield&lt;/code> 因为这是一个 &lt;code>Rust&lt;/code> 的保留字.&lt;/p>
&lt;p>我们遍历所有线程来查看是否有人处于 &lt;code>Ready&lt;/code> 状态, 这表明该线程已准备就绪可以继续进行.&lt;/p>
&lt;p>如果没有线程是就绪状态的, 我们就运行结束. 这是一个使用循环算法的简单调度器, 真正的调度程序可能具有更复杂的方式来决定下一步要执行的任务.&lt;/p>
&lt;blockquote>
&lt;p>这是定制给我们的粒子的非常幼稚的实现. 想想当我们的线程没有准备好继续(没有在准备状态) 并且在等待一个响应例如数据库.&lt;/p>
&lt;p>解决这个问题并不难, 比起在线程 &lt;code>Ready&lt;/code> 时直接运行我们的代码, 我们可以改为轮询它的状态. 举个例子, 如果真的准备好了它可以返回一个 &lt;code>IsReady&lt;/code> 或者等待一些其它操作完成那么就 &lt;code>Pending&lt;/code>. 在第二种情况, 我们可以将其保持在 &lt;code>Ready&lt;/code> 状态以便稍后再次轮询. 它听起来是不是有些熟悉? 如果你读过 &lt;a class="link" href="https://rust-lang-nursery.github.io/futures-api-docs/0.3.0-alpha.16/futures/task/enum.Poll.html#variant.Pending" target="_blank" rel="noopener"
>Futures&lt;/a> 如何在 &lt;code>Rust&lt;/code> 中工作, 我们将所有这些点组合串联起来.&lt;/p>
&lt;/blockquote>
&lt;p>如果我们发现有一个线程准备就绪, 那么我们就把当前线程的状态从 &lt;code>Running&lt;/code> 设置为 &lt;code>Ready&lt;/code> 以便后续继续运行它.&lt;/p>
&lt;p>然后我们调用 &lt;code>switch&lt;/code> 来保存当前线程的上下文, 然后将新的上下文加载到 &lt;code>CPU&lt;/code> 中. 这个新的上下文可以是一个新的任务, 也可能是恢复一个已有任务工作所需的上下文信息.&lt;/p>
&lt;p>最后一行只是我们阻止编译器优化代码的一种方法. 我在 &lt;code>Windows&lt;/code> 上会需要这行, 但在 &lt;code>Linux&lt;/code> 上不会, 而在基准测试的时候是一个常见问题. 因此我们使用 &lt;a class="link" href="https://doc.rust-lang.org/std/hint/fn.black_box.html" target="_blank" rel="noopener"
>std::hint::black_box&lt;/a> 来阻止编译器为了执行更快而跳过了我们需要执行的一些代码. 我使用了另外一种方法同样OK. 代码无论如何不会运行到这个地方.&lt;/p>
&lt;p>下一个是我们的 &lt;code>spawn()&lt;/code> 函数:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">spawn&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, f: &lt;span style="color:#a6e22e">fn&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> available &lt;span style="color:#f92672">=&lt;/span> self
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .threads
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .iter_mut()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .find(&lt;span style="color:#f92672">|&lt;/span>t&lt;span style="color:#f92672">|&lt;/span> t.state &lt;span style="color:#f92672">==&lt;/span> State::Available)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .expect(&lt;span style="color:#e6db74">&amp;#34;no available thread.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> available.stack.len();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s_ptr &lt;span style="color:#f92672">=&lt;/span> available.stack.as_mut_ptr().offset(size &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">isize&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s_ptr &lt;span style="color:#f92672">=&lt;/span> (s_ptr &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#ae81ff">15&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std::ptr::write(s_ptr.offset(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>, guard &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std::ptr::write(s_ptr.offset(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">24&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>, skip &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std::ptr::write(s_ptr.offset(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>, f &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> available.ctx.rsp &lt;span style="color:#f92672">=&lt;/span> s_ptr.offset(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> available.state &lt;span style="color:#f92672">=&lt;/span> State::Ready;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我认为 &lt;code>t_yield&lt;/code> 是逻辑上有趣的函数同时也是技术上最有趣的.&lt;/p>
&lt;p>这是我们设置我们的栈的地方就像我们在上一章节中讲述的那样, 需要确保我们的栈与 &lt;code>psABI&lt;/code> &lt;a class="link" href="#%e5%a6%82%e4%bd%95%e8%ae%be%e7%bd%ae%e6%a0%88" >栈布局&lt;/a> 类似.&lt;/p>
&lt;p>当我们 &lt;code>spawn&lt;/code> 一个新县城我们首先检查是否有线程是 &lt;code>available&lt;/code> 状态. 在这个场景如果我们超出了线程数就会 &lt;code>panic&lt;/code>, 虽然有一些更好的操作不过我们目前保持我们的例子.&lt;/p>
&lt;p>当我们找到一个 &lt;code>available&lt;/code> 线程我们获取它的栈长度和 &lt;code>u8&lt;/code> 字节数组的指针.&lt;/p>
&lt;p>在下一部分我们会使用一些 &lt;code>unsafe&lt;/code> 函数. 首先我们应该确保我们使用的内存块是16字节对齐的. 然后把 &lt;code>guard&lt;/code> 函数的地址写入栈顶, 这是在任务完成函数返回的时候调用的地方. 其次我们写入 &lt;code>skip&lt;/code> 函数的地址, 它只是用来填充 &lt;code>f&lt;/code> 和 &lt;code>guard&lt;/code> 之间的空隙来满足16字节对齐. 然后把 &lt;code>f&lt;/code> 地址写到16字节边界处.&lt;/p>
&lt;blockquote>
&lt;p>记住我们在 &lt;a class="link" href="#%e6%a0%88" >The Stack&lt;/a> 章节解释的栈是如何工作的. 我们需要让 &lt;code>f&lt;/code> 函数第一个运行, 所以我们设置基指针指向 &lt;code>f&lt;/code> 并且确保16字节对齐, 然后我们把 &lt;code>skip&lt;/code> 的地址压入, 最后是 &lt;code>guard&lt;/code>. 这样做可以确保我们遵守 &lt;code>ABI&lt;/code> 要求满足 &lt;code>guard&lt;/code> 是16字节对齐的.&lt;/p>
&lt;/blockquote>
&lt;p>最后我们将状态设置为 &lt;code>Ready&lt;/code> 这意味着我们有工作并且也准备好去做了. 记住, 这实际上取决于我们的调度器来启动该线程.&lt;/p>
&lt;p>我们现在完成了我们运行时的实现, 如果你掌握了这些知识, 那么你基本上了解绿色线程是如何工作的. 然而依然有一些细节部分需要实现.&lt;/p>
&lt;h2 id="guard-skip-and-switch-functions">Guard, skip and switch functions&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">guard&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> rt_ptr &lt;span style="color:#f92672">=&lt;/span> RUNTIME &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> RUNTIME;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#f92672">*&lt;/span>rt_ptr).t_return();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个函数表示着我们传进来的函数已经返回意味着我们的线程已经完成了运行它的任务, 所以我们解引用我们的 &lt;code>Runtime&lt;/code> 并且调用 &lt;code>t_return&lt;/code>. 当一个线程完成的时候我们可能需要做一些额外的工作但现在 &lt;code>t_return&lt;/code> 就够了. 这使得我们的线程 &lt;code>Available&lt;/code> (如果它不是我们的基线程) 并且 &lt;code>yield&lt;/code> 以让我们可以恢复其它线程的工作.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[naked]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">skip&lt;/span>() {}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 &lt;code>skip&lt;/code> 函数里什么也没做. 我们使用 &lt;code>#[naked]&lt;/code> 属性, 所以这个函数基本上只是编译为 &lt;code>ret&lt;/code> 命令. &lt;code>ret&lt;/code> 将会从栈中弹出下一个值并且跳到那个地址指向的任何命令. 在我们的例子中它是 &lt;code>guard&lt;/code> 函数. 就像你上一章节看到的那样, 这个函数为了确保我们遵从 &lt;code>ABI&lt;/code> 的要求.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">yield_thread&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> rt_ptr &lt;span style="color:#f92672">=&lt;/span> RUNTIME &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> RUNTIME;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#f92672">*&lt;/span>rt_ptr).t_yield();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这只是一个帮助函数为了我们可以在任何地方调用 &lt;code>yield&lt;/code>. 这很不安全, 如果我们的 &lt;code>Runtime&lt;/code> 还没有初始化完成或者运行时已经被释放, 它将会有一个 &lt;code>undefined behavior&lt;/code>. 然而我们仅仅是想让我们的示例正常运行, 安全性不是我们优先考虑的.&lt;/p>
&lt;p>我们很快到了最后一部分, 最后一个函数了. 如果你理解了前面的部分那你应该不需要注释也可以理解这个函数:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[naked]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[inline(never)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsafe&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">switch&lt;/span>(old: &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> ThreadContext, new: &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> ThreadContext) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> llvm_asm!(&lt;span style="color:#e6db74">&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov %rsp, 0x00($0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov %r15, 0x08($0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov %r14, 0x10($0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov %r13, 0x18($0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov %r12, 0x20($0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov %rbx, 0x28($0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov %rbp, 0x30($0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov 0x00($1), %rsp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov 0x08($1), %r15
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov 0x10($1), %r14
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov 0x18($1), %r13
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov 0x20($1), %r12
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov 0x28($1), %rbx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov 0x30($1), %rbp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> ret
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :&lt;span style="color:#e6db74">&amp;#34;r&amp;#34;&lt;/span>(old), &lt;span style="color:#e6db74">&amp;#34;r&amp;#34;&lt;/span>(new)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : &lt;span style="color:#e6db74">&amp;#34;volatile&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;alignstack&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>译者: 0x10是16进制, 为10进制的16, 所以上面的内联函数是每8个字节交换old和new.&lt;/p>
&lt;/blockquote>
&lt;p>这是我们的内联汇编, 就像你在第一个例子中记得的那样只是更复杂一点, 我们首先读取寄存器中的所有我们需要的值然后将所有寄存器中的值设置为 &lt;code>new&lt;/code> 线程中挂起执行时保存的值.&lt;/p>
&lt;p>本质上, 这是我们保存和恢复执行所需的全部工作.&lt;/p>
&lt;p>我们再一次看见了 &lt;code>#[naked]&lt;/code> 属性. 通常函数都是有开场白和尾声, 但是我们不想要那些因为我们用的都是汇编, 并且我们想要自己掌控一切. 如果我们不使用这个属性我们可能会在第二次切换回我们的栈的时候失败.&lt;/p>
&lt;blockquote>
&lt;p>更多的内联汇编的解释请参考&lt;a class="link" href="#%e4%b8%80%e4%b8%aa%e5%bb%ba%e7%ab%8b%e4%ba%8e%e5%8f%af%e7%bc%96%e8%af%91%e5%9f%ba%e7%a1%80%e4%b8%8a%e7%9a%84%e4%be%8b%e5%ad%90" >这一章节&lt;/a>的结尾部分. 如果这些看起来像火星文那么建议你返回读一下这部分.&lt;/p>
&lt;/blockquote>
&lt;p>有两件事情做的与我们的第一个例子不同.&lt;/p>
&lt;p>首先是 &lt;code>#[inline(never)]&lt;/code>, 这个属性阻止编译器内联这个函数, 我试了很多次, 如果我们不加这个属性那么在 &lt;code>--release&lt;/code> 模式编译的话会运行失败.&lt;/p>
&lt;p>&lt;code>&amp;quot;volatile&amp;quot;&lt;/code> 选项是另一个. 就像我先前警告的那样, 内联汇编有点啰嗦, 这表明了我们的汇编有副作用. 就是说当我们传入输入参数的时候我们需要确保编译器知道我们改变了传入的参数而不仅仅是读取它们.&lt;/p>
&lt;pre tabindex="0">&lt;code>0x00($1) # 0
0x08($1) # 8
0x10($1) # 16
0x18($1) # 24
&lt;/code>&lt;/pre>&lt;p>我之前有简单提到过, 但是我们再看一次. 这些都是 &lt;code>hex&lt;/code> 数字表明我们想要从内存指针偏移多少来读写. 我们每次仅仅偏移8个字节这与我们 &lt;code>ThreadContext&lt;/code> 结构体中的 &lt;code>u64&lt;/code> 属性是相同大小的.&lt;/p>
&lt;p>同样重要的一点需要说明的是 &lt;code>ThreadContext&lt;/code> 被 &lt;code>#[repr(C)]&lt;/code> 标记着, 所以我们知道数据在内存中表示的方法并且写入正确的字段. &lt;code>Rust ABI&lt;/code> 不保证我们的结构体的属性在内存中是按顺序表示的, 而 &lt;code>C-ABI&lt;/code> 有保证.&lt;/p>
&lt;h2 id="main函数">main函数&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> runtime &lt;span style="color:#f92672">=&lt;/span> Runtime::new();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> runtime.init();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> runtime.spawn(&lt;span style="color:#f92672">||&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;THREAD 1 STARTING&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">..&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;thread: {} counter: {}&amp;#34;&lt;/span>, id, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> yield_thread();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;THREAD 1 FINISHED&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> runtime.spawn(&lt;span style="color:#f92672">||&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;THREAD 2 STARTING&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">..&lt;/span>&lt;span style="color:#ae81ff">15&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;thread: {} counter: {}&amp;#34;&lt;/span>, id, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> yield_thread();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;THREAD 2 FINISHED&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> runtime.run();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>正如你看到的那样, 我们初始化运行时并且发放了两个线程, 一个从1计数到10, 在每次计数之间让出控制权/&lt;code>yield&lt;/code>, 而另一个计数到15. 我们可以使用 &lt;code>cargo run&lt;/code> 来运行我们的项目, 我们可以看到以下输出:&lt;/p>
&lt;pre tabindex="0">&lt;code>Finished dev [unoptimized + debuginfo] target(s) in 2.17s
Running `target/debug/green_threads`
THREAD 1 STARTING
thread: 1 counter: 0
THREAD 2 STARTING
thread: 2 counter: 0
thread: 1 counter: 1
thread: 2 counter: 1
thread: 1 counter: 2
thread: 2 counter: 2
thread: 1 counter: 3
thread: 2 counter: 3
thread: 1 counter: 4
thread: 2 counter: 4
thread: 1 counter: 5
thread: 2 counter: 5
thread: 1 counter: 6
thread: 2 counter: 6
thread: 1 counter: 7
thread: 2 counter: 7
thread: 1 counter: 8
thread: 2 counter: 8
thread: 1 counter: 9
thread: 2 counter: 9
THREAD 1 FINISHED.
thread: 2 counter: 10
thread: 2 counter: 11
thread: 2 counter: 12
thread: 2 counter: 13
thread: 2 counter: 14
THREAD 2 FINISHED.
&lt;/code>&lt;/pre>&lt;p>漂亮, 我们的线程是交替的, 因为我们在每个计数之间让出控制权直到线程1完成, 线程2在完成任务之前继续剩下的计数.&lt;/p>
&lt;h2 id="恭喜">恭喜&lt;/h2>
&lt;p>你现在已经实现了一个超级简单但是能运行的绿色线程例子. 这是我们必须经历的一段旅程, 如果你已经读了很久完全理解了这些, 现在你应该休息一会了. 谢谢阅读!&lt;/p>
&lt;h1 id="完成的200行代码">完成的200行代码&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#![feature(llvm_asm, naked_functions)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> DEFAULT_STACK_SIZE: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1024&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">1024&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> MAX_THREADS: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> RUNTIME: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Runtime&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> threads: Vec&lt;span style="color:#f92672">&amp;lt;&lt;/span>Thread&lt;span style="color:#f92672">&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current: &lt;span style="color:#66d9ef">usize&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[derive(PartialEq, Eq, Debug)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">State&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Available,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Running,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Ready,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Thread&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id: &lt;span style="color:#66d9ef">usize&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack: Vec&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctx: &lt;span style="color:#a6e22e">ThreadContext&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: &lt;span style="color:#a6e22e">State&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[derive(Debug, Default)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[repr(C)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ThreadContext&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rsp: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r15: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r14: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r13: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r12: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rbx: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rbp: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Thread {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">new&lt;/span>(id: &lt;span style="color:#66d9ef">usize&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">Self&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack: &lt;span style="color:#a6e22e">vec&lt;/span>&lt;span style="color:#f92672">!&lt;/span>[&lt;span style="color:#ae81ff">0_&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>; DEFAULT_STACK_SIZE],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctx: &lt;span style="color:#a6e22e">ThreadContext&lt;/span>::default(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: &lt;span style="color:#a6e22e">State&lt;/span>::Available,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Runtime {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">new&lt;/span>() -&amp;gt; &lt;span style="color:#a6e22e">Self&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> base_thread &lt;span style="color:#f92672">=&lt;/span> Thread {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id: &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack: &lt;span style="color:#a6e22e">vec&lt;/span>&lt;span style="color:#f92672">!&lt;/span>[&lt;span style="color:#ae81ff">0_&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>; DEFAULT_STACK_SIZE],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctx: &lt;span style="color:#a6e22e">ThreadContext&lt;/span>::default(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: &lt;span style="color:#a6e22e">State&lt;/span>::Running,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> threads &lt;span style="color:#f92672">=&lt;/span> vec![base_thread];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> available_threads: Vec&lt;span style="color:#f92672">&amp;lt;&lt;/span>Thread&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">..&lt;/span>MAX_THREADS).map(&lt;span style="color:#f92672">|&lt;/span>i&lt;span style="color:#f92672">|&lt;/span> Thread::new(i)).collect();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> threads.append(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> available_threads);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Runtime {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> threads,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current: &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> r_ptr: &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> Runtime &lt;span style="color:#f92672">=&lt;/span> self;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RUNTIME &lt;span style="color:#f92672">=&lt;/span> r_ptr &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self) -&amp;gt; &lt;span style="color:#f92672">!&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> self.t_yield() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std::process::exit(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">t_return&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> self.current &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.threads[self.current].state &lt;span style="color:#f92672">=&lt;/span> State::Available;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.t_yield();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">t_yield&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self) -&amp;gt; &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> pos &lt;span style="color:#f92672">=&lt;/span> self.current;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> self.threads[pos].state &lt;span style="color:#f92672">!=&lt;/span> State::Ready {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pos &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> pos &lt;span style="color:#f92672">==&lt;/span> self.threads.len() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pos &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> pos &lt;span style="color:#f92672">==&lt;/span> self.current {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> self.threads[self.current].state &lt;span style="color:#f92672">!=&lt;/span> State::Available {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.threads[self.current].state &lt;span style="color:#f92672">=&lt;/span> State::Ready;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.threads[pos].state &lt;span style="color:#f92672">=&lt;/span> State::Running;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> old_pos &lt;span style="color:#f92672">=&lt;/span> self.current;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.current &lt;span style="color:#f92672">=&lt;/span> pos;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> switch(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self.threads[old_pos].ctx, &lt;span style="color:#f92672">&amp;amp;&lt;/span>self.threads[pos].ctx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.threads.len() &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">spawn&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, f: &lt;span style="color:#a6e22e">fn&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> available &lt;span style="color:#f92672">=&lt;/span> self
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .threads
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .iter_mut()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .find(&lt;span style="color:#f92672">|&lt;/span>t&lt;span style="color:#f92672">|&lt;/span> t.state &lt;span style="color:#f92672">==&lt;/span> State::Available)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .expect(&lt;span style="color:#e6db74">&amp;#34;no available thread.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> available.stack.len();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s_ptr &lt;span style="color:#f92672">=&lt;/span> available.stack.as_mut_ptr().offset(size &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">isize&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s_ptr &lt;span style="color:#f92672">=&lt;/span> (s_ptr &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#ae81ff">15&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std::ptr::write(s_ptr.offset(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>, guard &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std::ptr::write(s_ptr.offset(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">24&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>, skip &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std::ptr::write(s_ptr.offset(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>, f &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> available.ctx.rsp &lt;span style="color:#f92672">=&lt;/span> s_ptr.offset(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> available.state &lt;span style="color:#f92672">=&lt;/span> State::Ready;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[naked]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">skip&lt;/span>() { }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">guard&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> rt_ptr &lt;span style="color:#f92672">=&lt;/span> RUNTIME &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> Runtime;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#f92672">*&lt;/span>rt_ptr).t_return();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">yield_thread&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> rt_ptr &lt;span style="color:#f92672">=&lt;/span> RUNTIME &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> Runtime;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#f92672">*&lt;/span>rt_ptr).t_yield();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[naked]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[inline(never)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsafe&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">switch&lt;/span>(old: &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> ThreadContext, new: &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> ThreadContext) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> llvm_asm!(&lt;span style="color:#e6db74">&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov %rsp, 0x00($0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov %r15, 0x08($0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov %r14, 0x10($0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov %r13, 0x18($0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov %r12, 0x20($0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov %rbx, 0x28($0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov %rbp, 0x30($0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov 0x00($1), %rsp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov 0x08($1), %r15
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov 0x10($1), %r14
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov 0x18($1), %r13
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov 0x20($1), %r12
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov 0x28($1), %rbx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> mov 0x30($1), %rbp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> ret
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :&lt;span style="color:#e6db74">&amp;#34;r&amp;#34;&lt;/span>(old), &lt;span style="color:#e6db74">&amp;#34;r&amp;#34;&lt;/span>(new)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : &lt;span style="color:#e6db74">&amp;#34;volatile&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;alignstack&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> runtime &lt;span style="color:#f92672">=&lt;/span> Runtime::new();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> runtime.init();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> runtime.spawn(&lt;span style="color:#f92672">||&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;THREAD 1 STARTING&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">..&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;thread: {} counter: {}&amp;#34;&lt;/span>, id, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> yield_thread();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;THREAD 1 FINISHED&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> runtime.spawn(&lt;span style="color:#f92672">||&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;THREAD 2 STARTING&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">..&lt;/span>&lt;span style="color:#ae81ff">15&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;thread: {} counter: {}&amp;#34;&lt;/span>, id, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> yield_thread();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;THREAD 2 FINISHED&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> runtime.run();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>译者: 下一个章节是对 &lt;code>Windows&lt;/code> 的额外支持, 有兴趣的可以自行&lt;a class="link" href="https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/supporting-windows" target="_blank" rel="noopener"
>阅读&lt;/a>.&lt;/p>
&lt;p>如果翻译有任何问题, 欢迎给我提 &lt;a class="link" href="https://github.com/tian-deng/tian-deng.github.io/issues" target="_blank" rel="noopener"
>issue&lt;/a>.&lt;/p>
&lt;/blockquote></description></item><item><title>优雅的Rust</title><link>/post/rust/elegent_rust/</link><pubDate>Tue, 15 Sep 2020 15:30:44 +0800</pubDate><guid>/post/rust/elegent_rust/</guid><description>&lt;img src="/post/rust/elegent_rust/cover.png" alt="Featured image of post 优雅的Rust" />&lt;p>小记自己为什么会学 &lt;code>Rust&lt;/code> . &lt;code>Rust&lt;/code> 有什么特性吸引到我了~&lt;/p>
&lt;hr>
&lt;p>如果说 &lt;code>C&lt;/code> 语言是具备高灵活性, 信任着开发者, 将一切交给开发者来解决的话.&lt;/p>
&lt;p>那么 &lt;code>Rust&lt;/code> 就是降低该灵活性, 毫不信任开发者, 将开发者的大部分错误都在编译期发掘出来, 强制要求开发者去了解可能存在的问题并解决掉它.&lt;/p>
&lt;p>&lt;code>C&lt;/code> 语言可能条条大路通罗马, &lt;code>Rust&lt;/code> 可能只有寥寥无几的道路.&lt;/p>
&lt;p>总之, &lt;code>Rust&lt;/code> 拔高了开发者的下限, 如果水平不够是连编译器都不会通过的, 更不要说 &lt;code>commit&lt;/code> 了.&lt;/p>
&lt;h1 id="优雅的rust">优雅的Rust&lt;/h1>
&lt;p>听说到 &lt;code>Rust&lt;/code> 最多的自然是所谓的内存安全. 那么什么是内存安全？ 内存安全体现在哪里呢？&lt;/p>
&lt;p>比如说这段 &lt;code>C语言&lt;/code> 代码.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> a[&lt;span style="color:#ae81ff">5&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a[&lt;span style="color:#ae81ff">6&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>, a[&lt;span style="color:#ae81ff">6&lt;/span>]);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段代码能正确输出 &lt;code>a[6]&lt;/code> 吗?&lt;/p>
&lt;p>答案是可以的, 虽然它很明显的内存越界了, 但内存越界似乎在 &lt;code>C&lt;/code> 里并不是什么&lt;code>大不了&lt;/code>的事, 编写的代码随便越界, 只不过导致的后果需要自己承担而已.&lt;/p>
&lt;p>当然现今大部分的高级语言对指针越界都会有很明确的编译错误, 所以仅这点来看并不能体现出 &lt;code>Rust&lt;/code> 的特点, 只不过是有了现代语言该有的东西——内存越界提示.&lt;/p>
&lt;p>那么有什么可以体现出 &lt;code>Rust&lt;/code> 独有特性的地方呢?&lt;/p>
&lt;p>参考这一段结构体.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> Node &lt;span style="color:#f92672">*&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> val;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}Node;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node &lt;span style="color:#f92672">*&lt;/span>head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node &lt;span style="color:#f92672">*&lt;/span>tail;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}LinkedList;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>push)(&lt;span style="color:#66d9ef">struct&lt;/span> LinkedList &lt;span style="color:#f92672">*&lt;/span>self, Node val);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>peek)(&lt;span style="color:#66d9ef">struct&lt;/span> LinkedList &lt;span style="color:#f92672">*&lt;/span>self);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>pop)(&lt;span style="color:#66d9ef">struct&lt;/span> LinkedList &lt;span style="color:#f92672">*&lt;/span>self);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}StackMethod;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是一个简单的数据结构栈, 在栈方法中定义了三个函数指针, 不需要关注 &lt;code>push&lt;/code> 方法, 来看看 &lt;code>peek&lt;/code> 方法.&lt;/p>
&lt;p>&lt;code>peek&lt;/code> 方法将栈中的尾结点返回, 和 &lt;code>pop&lt;/code> 方法的区别是它不会从链表中删除该节点. 但此时该方法的调用者拥有了该节点的所有权限, 如果调用者此时又释放了该地址指向的内存, 当再次调用 &lt;code>pop&lt;/code> 方法时, &lt;code>pop&lt;/code> 方法将返回一个已经释放了内存的结点指针, 此时如果访问该结点大概率会出现 &lt;code>Segementation fault&lt;/code>. 因为访问了一个没有分配的内存空间. &lt;code>Segementation fault&lt;/code> 大概是我写 &lt;code>C&lt;/code> 时候最讨厌的错误了.&lt;/p>
&lt;p>那么 &lt;code>Rust&lt;/code> 是如何解决的呢? 答案是&lt;code>所有权&lt;/code>.&lt;/p>
&lt;h2 id="所有权">所有权&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s1 &lt;span style="color:#f92672">=&lt;/span> String::from(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s2 &lt;span style="color:#f92672">=&lt;/span> s1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在将 &lt;code>s1&lt;/code> 赋值给 &lt;code>s2&lt;/code> 后, 此时 &lt;code>s1&lt;/code> 就已经是无效的了, 它的作用域仅到赋值给 &lt;code>s2&lt;/code> 之前为止.&lt;/p>
&lt;p>同样类似的.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">hello&lt;/span>(&lt;span style="color:#66d9ef">str&lt;/span>: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;{}&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">str&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>.to_string();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hello(s1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;{}&amp;#34;&lt;/span>, s1); &lt;span style="color:#75715e">// error
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段相等同的 &lt;code>C&lt;/code> 代码会有问题么?&lt;/p>
&lt;p>可能会有问题. 如果在 &lt;code>hello&lt;/code> 中释放了内存, 那么 &lt;code>main&lt;/code> 函数中后续对 &lt;code>s1&lt;/code> 的访问就会出现段错误. 就像这样:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">hello&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> str) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, str);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> free(str);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> s1[&lt;span style="color:#ae81ff">5&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#e6db74">&amp;#39;h&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;e&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;l&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;l&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o&amp;#39;&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hello(s1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, s1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 &lt;code>Rust&lt;/code> 中就完全避免了这种情况, 这样的代码在Rust中连编译都不会通过的.&lt;/p>
&lt;p>那么 &lt;code>main&lt;/code> 函数后续不能再用该变量了吗? 有两种方法可以解决该问题.&lt;/p>
&lt;p>可以将 &lt;code>hello&lt;/code> 函数的签名增加个返回值, 使用完变量后将其所有权返回给调用者. &lt;code>main&lt;/code> 函数也需要提供一个接收者接收该变量的所有, 该做法使用了 &lt;code>Rust&lt;/code> 变量覆盖的特性, 可以声明同名变量, 就跟 &lt;code>Javascript&lt;/code> 类似. 后续声明的同名变量会覆盖先前的.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">hello&lt;/span>(&lt;span style="color:#66d9ef">str&lt;/span>: String) -&amp;gt;String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;{}&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">str&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">str&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>.to_string();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s1 &lt;span style="color:#f92672">=&lt;/span> hello(s1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;{}&amp;#34;&lt;/span>, s1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一种是个很自然而且很容易想到并理解的做法( &lt;code>Rust&lt;/code> 中函数块最后一行且没有带分号的会被当做返回值, 所以可以省略掉 &lt;code>return&lt;/code> ). 还有另一种做法, 那就是引用.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">hello&lt;/span>(&lt;span style="color:#66d9ef">str&lt;/span>: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;{}&amp;#34;&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>.to_string();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hello(&lt;span style="color:#f92672">&amp;amp;&lt;/span>s1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;{}&amp;#34;&lt;/span>, s1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>&amp;amp;&lt;/code> 表示一个引用或引用类型, &lt;code>*&lt;/code> 则表现为消除 &lt;code>&amp;amp;&lt;/code>, 也就是解引用. 用法类似与 &lt;code>C&lt;/code> 中的指针. 而在 &lt;code>Rust&lt;/code> 中是会自动解引用的, 所以 &lt;code>hello&lt;/code> 函数也可以改为:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">hello&lt;/span>(&lt;span style="color:#66d9ef">str&lt;/span>: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>String){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;{}&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">str&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 &lt;code>C&lt;/code> 中可能存在的野指针问题在 &lt;code>Rust&lt;/code> 中也可以通过所有权系统来解决.&lt;/p>
&lt;blockquote>
&lt;p>野指针主要为未初始化或释放后未置空或操作超越变量作用域.&lt;/p>
&lt;/blockquote>
&lt;p>参照如下 &lt;code>C&lt;/code> 代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>p &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)malloc(&lt;span style="color:#ae81ff">4&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>p &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> free(p);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>q &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)malloc(&lt;span style="color:#ae81ff">4&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>q &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;q = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>q); &lt;span style="color:#75715e">//此处打印 q = 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">*&lt;/span>p &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;q = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>q); &lt;span style="color:#75715e">//此处打印 q = 4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>是不是很神奇. 那么为什么会出现这种现象?&lt;/p>
&lt;p>因为在 &lt;code>C&lt;/code> 中使用 &lt;code>malloc&lt;/code> 分配内存的时候, 会优先分配前次释放的内存, 所以两处调用 &lt;code>malloc&lt;/code> 所得到的地址是一样的. 在释放 &lt;code>p&lt;/code> 之后, 没有对 &lt;code>p&lt;/code> 进行赋空操作, 此时 &lt;code>p&lt;/code> 就成了一个野指针. 然后接着又分配了一个跟前序 &lt;code>p&lt;/code> 一样大小的内存空间, 此时 &lt;code>p&lt;/code> 和 &lt;code>q&lt;/code> 就是一样的了——指向相同的地址. 所以对 &lt;code>p&lt;/code> 指向的值进行的修改会反映在 &lt;code>q&lt;/code> 上. 虽然简单的在释放 &lt;code>p&lt;/code> 后给其赋值为 &lt;code>NULL&lt;/code> 就可以了, 但是如果有个人疏忽了呢? 毕竟人是不会永远不犯错的. 在 &lt;code>Rust&lt;/code> 中类似这样的代码是不可能通过的, 因为在释放 &lt;code>p&lt;/code> 的时候所有权已经转移给 &lt;code>free&lt;/code> 函数了, &lt;code>main&lt;/code>函数后续是不能再使用的.&lt;/p>
&lt;p>不管是学过 &lt;code>Java&lt;/code> 的还是学过 &lt;code>C&lt;/code> 的, 肯定都多多少少了解过关于引用传递和值传递, 有相当多的教学声明 &lt;code>Java&lt;/code> 中仅存在值传递.&lt;/p>
&lt;p>在 &lt;code>C&lt;/code> 语言中指针则类似于引用传递, 通过地址引用指向内存空间的值. 因为有地址所以可以修改其中的值并且被其它函数观察到. 传递引用有一个问题, 有时候我们并不想别人改变我们的值, 但又不得不声明为指针(比如说结构体的自引用), 同时又忘了给该参数声明为 &lt;code>const&lt;/code> , 这样就会有很多问题. 尤其在初学 &lt;code>C&lt;/code> 的时候, 几乎很少有人会用到 &lt;code>const&lt;/code> 关键词. 很多人是不晓得该关键词到底有多么重要的, 而 &lt;code>Rust&lt;/code> 就会强迫我们去学习, 了解不可变的重要性.&lt;/p>
&lt;p>那么很自然的就过渡到下一个阶段~&lt;/p>
&lt;h2 id="可变性与不可变性">可变性与不可变性&lt;/h2>
&lt;p>然而在 &lt;code>Rust&lt;/code> 中所有的变量如果不显式声明, 那就是不可修改的( &lt;code>unsafe&lt;/code> 是特例). 所以如果要传递一个可变引用, 就需要如下的声明:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">hello&lt;/span>(&lt;span style="color:#66d9ef">str&lt;/span>: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">mut&lt;/span> String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;{}&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">str&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">str&lt;/span>.push_str(&lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>); &lt;span style="color:#75715e">//3. 修改str的值.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> s1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>.to_string(); &lt;span style="color:#75715e">//1. 此处声明s1是可变的变量.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> hello(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> s1); &lt;span style="color:#75715e">//2. 传递一个可变引用给hello函数.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> println!(&lt;span style="color:#e6db74">&amp;#34;{}&amp;#34;&lt;/span>, s1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>显式声明 &lt;code>str&lt;/code> 是可变的, 否则对变量做的任何修改在编译期都是无法通过的. 这就避免了很多 &lt;code>Code&lt;/code> 时的隐性错误.&lt;/p>
&lt;p>&lt;code>Rust&lt;/code> 中关于该特性有几个关键点.&lt;/p>
&lt;ol>
&lt;li>变量可以有多个不可变引用.&lt;/li>
&lt;li>变量只能有一个可变引用.&lt;/li>
&lt;li>变量有可变引用的同时不能有不可变引用.&lt;/li>
&lt;/ol>
&lt;p>比如如下代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> s1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>.to_string();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>s1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hello(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> s1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;{}&amp;#34;&lt;/span>, s1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;{}&amp;#34;&lt;/span>, s2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编译时会报错&lt;/p>
&lt;blockquote>
&lt;p>error[E0502]: cannot borrow &lt;code>s1&lt;/code> as mutable because it is also borrowed as immutable&lt;/p>
&lt;/blockquote>
&lt;p>错误提示相当友好了, 不能将 &lt;code>s1&lt;/code> 作为可变引用因为它已经有一个不可变引用了. 为什么要这么设计?&lt;/p>
&lt;p>可以想象一下在 &lt;code>C&lt;/code> 中, 编写了一个返回指针的函数, 有多个不同调用方或许都对指向的值进行了修改, 某个调用方又如何知道该值是否是最初的函数所返回的呢? 还是因为各个调用方可能进行的修改后的结果. 解决方法肯定是有的, 比如说注意一下各个调用方的顺序之类的, 只是有时项目庞大而复杂, 是没法顾及到方方面面, 这时是需要有个 &amp;ldquo;人&amp;rdquo; 来提醒一下我们.&lt;/p>
&lt;p>因此, 可变引用与不可变引用直接是互斥的, 不可变引用之间也是互斥的, 它们不能同时存在.&lt;/p>
&lt;p>上面的代码调换一下位置就可以了.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> s1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>.to_string();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hello(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> s1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>s1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;{}&amp;#34;&lt;/span>, s1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;{}&amp;#34;&lt;/span>, s2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时在 &lt;code>s2&lt;/code> 声明的位置, &lt;code>s1&lt;/code> 的可变引用的作用域已经结束, 现在 &lt;code>s1&lt;/code> 是没有其它引用的, 所以可以拿到其的一个引用.&lt;/p>
&lt;hr>
&lt;p>在这里, 为了引入个下一话题, 我们不自然地回顾一下上一章节的野指针问题~&lt;/p>
&lt;p>类似的如下 &lt;code>C&lt;/code> 代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">dangle&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> a[&lt;span style="color:#ae81ff">3&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;abc&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>p &lt;span style="color:#f92672">=&lt;/span> dangle();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, p);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在函数结束的时候变量 &lt;code>a&lt;/code> 已经被销毁, 将该地址返回就会产生野指针.&lt;/p>
&lt;p>如何修正该代码?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">dangle&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;abc&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>p &lt;span style="color:#f92672">=&lt;/span> dangle();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, p);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样就可以了.这样所声明的变量 &lt;code>a&lt;/code> 实际上为字符串常量, 是不可变的, 存储在静态存储区. 由程序结束后操作系统回收该部分内存. 所以在函数结束后 &lt;code>a&lt;/code> 指向的值是不会被销毁的. 将该地址返回也是完全没有错误的.&lt;/p>
&lt;p>这些细枝末节在初学 &lt;code>C&lt;/code> 的时候是很难注意到的. 毕竟大多数大学生使用的教材还是谭浩强版, 用于应试是够了, 实际开发是远远不行的.&lt;/p>
&lt;p>如果在 &lt;code>Rust&lt;/code> 中写出这样的代码呢?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> reference_to_nothing &lt;span style="color:#f92672">=&lt;/span> dangle();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">dangle&lt;/span>() -&amp;gt; &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s &lt;span style="color:#f92672">=&lt;/span> String::from(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>首先说点题外话, 在 &lt;code>Rust&lt;/code> 中命名通常用蛇形命名法, 不像 &lt;code>Java&lt;/code> 中普遍的是大驼峰和小驼峰. 至于好看与否, 看眼缘吧~&lt;/p>
&lt;p>这里同样的编译是不能通过的.&lt;/p>
&lt;blockquote>
&lt;p>error[E0106]: missing lifetime specifier
&amp;ndash;&amp;gt; src\main.rs:5:16
|
5 | fn dangle() -&amp;gt; &amp;amp;String {
| ^ expected named lifetime parameter
|
= help: this function&amp;rsquo;s return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the &lt;code>'static&lt;/code> lifetime
|
5 | fn dangle() -&amp;gt; &amp;amp;&amp;lsquo;static String {
| ^^^^^^^^&lt;/p>
&lt;/blockquote>
&lt;p>可以说相当友好了, 编译器同时提示了错误是什么, 以及该如何解决它.&lt;/p>
&lt;p>该错误说明了该函数缺少生命周期指示符. 帮助说明了该函数返回的值包含了一个引用值, 但是这种类型是没有可以用来借用的, 需要考虑加上 &lt;code>'static&lt;/code> 生命周期, 这样就杜绝了返回局部变量引用的情况.&lt;/p>
&lt;p>这样就引入了下一个话题~&lt;/p>
&lt;h2 id="生命周期">生命周期&lt;/h2>
&lt;p>以下内容主要参考 &lt;a class="link" href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html" target="_blank" rel="noopener"
>The Rust Programming Language&lt;/a>&lt;/p>
&lt;p>生命周期只是一个标签, 语法是&lt;code>'&lt;/code>+字符串/字符. 比如 &lt;code>'a&lt;/code>, &lt;code>'b&lt;/code>. &lt;code>'static&lt;/code> 是一个特殊的生命周期, 表示静态存储, 类似于 &lt;code>Java&lt;/code> 和 &lt;code>C\C++&lt;/code> 中的 &lt;code>static&lt;/code>, 也就是一直存活到程序结束运行才会销毁.&lt;/p>
&lt;p>生命周期主要是为了避免悬垂引用(野指针), 在 &lt;code>Rust编译器&lt;/code> 中实现了一个借用检查器, 通过比较作用域来确保所有借用的有效性.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> r; &lt;span style="color:#75715e">// ---------+-- &amp;#39;a
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> { &lt;span style="color:#75715e">// |
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>; &lt;span style="color:#75715e">// -+-- &amp;#39;b |
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> r &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>x; &lt;span style="color:#75715e">// | |
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } &lt;span style="color:#75715e">// -+ |
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> println!(&lt;span style="color:#e6db74">&amp;#34;r: {}&amp;#34;&lt;/span>, r); &lt;span style="color:#75715e">// |
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>} &lt;span style="color:#75715e">// ---------+
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里 &lt;code>r&lt;/code> 的生命周期为 &lt;code>'a&lt;/code>, &lt;code>x&lt;/code> 的生命周期为 &lt;code>'b&lt;/code> , &lt;code>'b&lt;/code> 的范围小于 &lt;code>'a&lt;/code> 的范围, 由于 &lt;code>r&lt;/code> 引用了一个存活范围小于它的变量, 所以会编译失败.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>; &lt;span style="color:#75715e">// ----------+-- &amp;#39;b
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> r &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>x; &lt;span style="color:#75715e">// --+-- &amp;#39;a |
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> println!(&lt;span style="color:#e6db74">&amp;#34;r: {}&amp;#34;&lt;/span>, r); &lt;span style="color:#75715e">// | |
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// --+ |
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>} &lt;span style="color:#75715e">// ----------+
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>改为这样子, 因为 &lt;code>r&lt;/code> 的生命周期 &lt;code>'a&lt;/code> 小于 &lt;code>'b&lt;/code> , 这样就能保证在 &lt;code>r&lt;/code> 有效的时候 &lt;code>x&lt;/code> 总是有效的, 这样 &lt;code>r&lt;/code> 就不可能变成一个野指针.&lt;/p>
&lt;p>考虑这样一个函数:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">longest&lt;/span>(x: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span>, y: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span>) -&amp;gt; &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> x.len() &lt;span style="color:#f92672">&amp;gt;&lt;/span> y.len() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> string1 &lt;span style="color:#f92672">=&lt;/span> String::from(&lt;span style="color:#e6db74">&amp;#34;long string is long&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> string2 &lt;span style="color:#f92672">=&lt;/span> String::from(&lt;span style="color:#e6db74">&amp;#34;xyz&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> longest(string1.as_str(), string2.as_str());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;The longest string is {}&amp;#34;&lt;/span>, result);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>乍看之下没有什么问题对吧? 但是编译还是不通过.&lt;/p>
&lt;blockquote>
&lt;p>error[E0106]: missing lifetime specifier
&amp;ndash;&amp;gt; src\main.rs:1:33
|
1 | fn longest(x: &amp;amp;str, y: &amp;amp;str) -&amp;gt; &amp;amp;str {
| &amp;mdash;- &amp;mdash;- ^ expected named lifetime parameter
|
= help: this function&amp;rsquo;s return type contains a borrowed value, but the signature does not say whether it is borrowed from &lt;code>x&lt;/code> or &lt;code>y&lt;/code>
help: consider introducing a named lifetime parameter
|
1 | fn longest&amp;lt;&amp;lsquo;a&amp;gt;(x: &amp;amp;&amp;lsquo;a str, y: &amp;amp;&amp;lsquo;a str) -&amp;gt; &amp;amp;&amp;lsquo;a str {
| ^^^^ ^^^^^^^ ^^^^^^^ ^^^&lt;/p>
&lt;/blockquote>
&lt;p>根据报错提示, 我们修改函数签名为&lt;code>fn longest&amp;lt;'a&amp;gt;(x: &amp;amp;'a str, y: &amp;amp;'a str) -&amp;gt; &amp;amp;'a str&lt;/code> 这样这段代码就可以正确运行了. 生命周期在函数签名中的用法类似于泛型, 前面多个单引号而已. 然后在对应的参数上声明所需要的生命周期就可以了.&lt;/p>
&lt;p>这个函数签名表示告诉调用者 &lt;code>x&lt;/code> , &lt;code>y&lt;/code> , &lt;code>str&lt;/code> 这三个至少能存活的一样久, 否则就不能编译通过.&lt;/p>
&lt;p>我们修改下 &lt;code>main&lt;/code> 函数为如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> string1 &lt;span style="color:#f92672">=&lt;/span> String::from(&lt;span style="color:#e6db74">&amp;#34;long string is long&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> string2 &lt;span style="color:#f92672">=&lt;/span> String::from(&lt;span style="color:#e6db74">&amp;#34;xyz&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#f92672">=&lt;/span> longest(string1.as_str(), string2.as_str());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;The longest string is {}&amp;#34;&lt;/span>, result);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们将延长 &lt;code>result&lt;/code> 的生命周期, 并且将 &lt;code>println&lt;/code> 移动到块外面, 这样子编译是不通过的. 来看看编译错误信息:&lt;/p>
&lt;blockquote>
&lt;p>error[E0597]: &lt;code>string2&lt;/code> does not live long enough
&amp;ndash;&amp;gt; src\main.rs:14:44
|
14 | result = longest(string1.as_str(), string2.as_str());
| ^^^^^^^ borrowed value does not live long enough
15 | }
| - &lt;code>string2&lt;/code> dropped here while still borrowed
16 | println!(&amp;ldquo;The longest string is {}&amp;rdquo;, result);
| &amp;mdash;&amp;mdash; borrow later used here&lt;/p>
&lt;/blockquote>
&lt;p>提示我们 &lt;code>string2&lt;/code> 在 &lt;code>println&lt;/code> 前就被释放了. 如果像之前那样没有给函数签名加上生命周期的话, 编译器是不能知道函数返回的值到底能存活多久的, 生命周期表明了返回的值与参数的生命周期应该是一致的, 这里所谓的一致是指同样生命周期标签中最小的那个. 在正确的代码中, 三个参数分别对应的 &lt;code>string1&lt;/code>, &lt;code>string2&lt;/code>, &lt;code>result&lt;/code> 中, 最短的那个是 &lt;code>result&lt;/code> , 编译器能推断出在 &lt;code>result&lt;/code> 存活的范围它所引用的值是一直有效的.&lt;/p>
&lt;p>而在错误的代码中, &lt;code>string2&lt;/code> 是生命周期最短的那个, 所以编译器推断出 &lt;code>result&lt;/code> 只能在 &lt;code>string2&lt;/code> 存活的范围内使用, 一旦超出该范围, 就可以提示调用者需要修改代码.&lt;/p>
&lt;p>简单说下 &lt;code>Rust&lt;/code> 如何清理内存, 只要让它离开作用域就可以了, 离开作用域的时候会自动调用该类型的 &lt;code>drop&lt;/code> 方法, 而 &lt;code>drop&lt;/code> 一般都是由编译器提供默认实现的, 有时候默认实现不够高效才需要自己去实现. 我们不能调用变量的 &lt;code>drop&lt;/code> 方法, 那样就会有多次释放的问题, 如有需要可以调用标准库提供的 &lt;code>drop&lt;/code> 函数.&lt;/p>
&lt;p>标准库有提供一个 &lt;code>drop&lt;/code> 函数, 用来手动释放内存, 可以看看它的实现~&lt;/p>
&lt;blockquote>
&lt;p>core::mem
pub fn drop&lt;!-- raw HTML omitted -->(_x: T)
Disposes of a value.
This does so by calling the argument&amp;rsquo;s implementation of Drop.
This effectively does nothing for types which implement Copy, e.g. integers. Such values are copied and then moved into the function, so the value persists after this function call.
This function is not magic; it is literally defined as
pub fn drop&lt;!-- raw HTML omitted -->(_x: T) { }&lt;/p>
&lt;p>Because _x is moved into the function, it is automatically dropped before the function returns.&lt;/p>
&lt;/blockquote>
&lt;p>它的实现仅仅是一个空函数块, 将该变量的所有权转移到该函数块中, 在结束的时候调用该变量的 &lt;code>drop&lt;/code> 方法.&lt;/p>
&lt;hr>
&lt;p>上面似乎都是一些内存安全相关的特性, 感觉只体现出来 &lt;code>Rust&lt;/code> 编译器的强大, 接下来, 可以转下一个话题了, 简单介绍下 &lt;code>Rust&lt;/code> 的一些优雅的语法特性~&lt;/p>
&lt;h2 id="trait">Trait&lt;/h2>
&lt;p>&lt;code>Trait&lt;/code> 类似与 &lt;code>Java&lt;/code> 中的接口概念, 近年来一直以来都有组合大于继承的口号, &lt;code>Trait&lt;/code> 就是在 &lt;code>Rust&lt;/code> 中用来实现组合这一理念的.&lt;/p>
&lt;p>继承有时候用起来是真的不顺心. 继承吧, 好多用不到的东西, 不继承吧, 又有很多重复工作要做. &lt;code>Rust&lt;/code> 中干脆扔掉了继承.&lt;/p>
&lt;p>像前面讲到的实现 &lt;code>drop&lt;/code> 方法, 怎么为我们的类型实现 &lt;code>drop&lt;/code> 方法呢?&lt;/p>
&lt;p>&lt;code>Drop&lt;/code> 中只有一个方法, 它的签名为: &lt;code>fn drop(&amp;amp;mut self);&lt;/code> 所以我们就像实现接口一样实现该方法就可以了.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">MyVar&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> names: Vec&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Drop &lt;span style="color:#66d9ef">for&lt;/span> MyVar {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">drop&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>self.names;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;MyVar drops&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> _ &lt;span style="color:#f92672">=&lt;/span> MyVar {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> names: &lt;span style="color:#a6e22e">vec&lt;/span>&lt;span style="color:#f92672">!&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>.to_string(), &lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>.to_string()]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行后将打印出 &lt;code>MyVar drops&lt;/code> , 可以看出来在离开作用域后就自动调用了我们自定义的 &lt;code>drop&lt;/code> 方法.&lt;/p>
&lt;p>可以用 &lt;code>Trait&lt;/code> 配合泛型编写一个通用的 &lt;code>largest&lt;/code> 函数.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">largest&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T: PartialOrd &lt;span style="color:#f92672">+&lt;/span> Clone&lt;span style="color:#f92672">&amp;gt;&lt;/span>(list: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>[T]) -&amp;gt; &lt;span style="color:#a6e22e">T&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> largest &lt;span style="color:#f92672">=&lt;/span> list[&lt;span style="color:#ae81ff">0&lt;/span>].clone();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> item &lt;span style="color:#66d9ef">in&lt;/span> list.iter() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">*&lt;/span>item &lt;span style="color:#f92672">&amp;gt;&lt;/span> largest {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> largest &lt;span style="color:#f92672">=&lt;/span> item.clone();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> largest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> number_list &lt;span style="color:#f92672">=&lt;/span> vec![&lt;span style="color:#ae81ff">34&lt;/span>, &lt;span style="color:#ae81ff">50&lt;/span>, &lt;span style="color:#ae81ff">25&lt;/span>, &lt;span style="color:#ae81ff">100&lt;/span>, &lt;span style="color:#ae81ff">65&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> largest(&lt;span style="color:#f92672">&amp;amp;&lt;/span>number_list);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;The largest number is {}&amp;#34;&lt;/span>, result);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> char_list &lt;span style="color:#f92672">=&lt;/span> vec![&lt;span style="color:#e6db74">&amp;#39;y&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;m&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;q&amp;#39;&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> largest(&lt;span style="color:#f92672">&amp;amp;&lt;/span>char_list);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;The largest char is {}&amp;#34;&lt;/span>, result);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>PartialOrd&lt;/code> 是基于排序为目的而比较一个类型, 实现了该 &lt;code>Trait&lt;/code> 的类型就可以使用 &lt;code>&amp;gt;&lt;/code> , &lt;code>&amp;lt;=&lt;/code> , &lt;code>&amp;gt;&lt;/code> , &lt;code>&amp;gt;=&lt;/code> , 可以近似的看作 &lt;code>C++&lt;/code> 中的操作符重载.&lt;/p>
&lt;p>这里再简单说明一下 &lt;code>Copy&lt;/code> 和 &lt;code>Clone&lt;/code>.&lt;/p>
&lt;p>&lt;code>Clone&lt;/code> 就是所谓的 &lt;code>深拷贝&lt;/code> , 我们也可以用 &lt;code>Copy&lt;/code> , &lt;code>Copy&lt;/code> 是浅拷贝.&lt;/p>
&lt;p>&lt;code>Copy&lt;/code> 是简单的拷贝存储再栈上的位来赋值值, 比较高效, 是一个标记型 &lt;code>Trait&lt;/code> , 该 &lt;code>Trait&lt;/code> 的实现基准是: 如果一个类型内部的类型全部是 &lt;code>Copy&lt;/code> 的, 那么该类型也是 &lt;code>Copy&lt;/code> , 比如所有的基本类型. 而 &lt;code>Clone&lt;/code> 是深拷贝, 我们需要为必要的类型自己实现该 &lt;code>Trait&lt;/code> , 当调用一个 &lt;code>Clone&lt;/code> 的时候我们应该知道该操作可能会比较慢.&lt;/p>
&lt;p>我们也可以为 &lt;code>Triat&lt;/code> 实现 &lt;code>Trait&lt;/code> , 这用到了 &lt;code>Rust&lt;/code> 中的动态分发, 这里不详细说明, 只做介绍.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">trait&lt;/span> Animal {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self) -&amp;gt; String;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">trait&lt;/span> Bark {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">bark&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Dog&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Animal &lt;span style="color:#66d9ef">for&lt;/span> Dog {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self) -&amp;gt; String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Kitty&amp;#34;&lt;/span>.to_string()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Bark &lt;span style="color:#66d9ef">for&lt;/span> Box&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">dyn&lt;/span> Animal&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">bark&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;{} bark.&amp;#34;&lt;/span>, self.name());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> dog: Box&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">dyn&lt;/span> Animal&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Box::new(Dog);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dog.bark();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以用 &lt;code>Trait&lt;/code> 来组合成我们最终所需要的类型, 每个 &lt;code>Trait&lt;/code> 都是那么的小巧简洁~ 不像是继承, 继承有着严重的耦合, 并且显得不是那么精巧.&lt;/p>
&lt;hr>
&lt;p>之前我们有提到过 &lt;code>Rust&lt;/code> 中是没有空指针的, 那么我们如何表示一个可能存在的值呢?&lt;/p>
&lt;p>如果有人用过 &lt;code>JDK8&lt;/code> 中的 &lt;code>Optional&lt;/code> 的话, 那应该就很熟悉了~答案就是 &lt;code>Option&lt;/code>.&lt;/p>
&lt;p>&lt;code>Optional&lt;/code> 在 &lt;code>Java&lt;/code> 中出现的太晚了, 很多人对这个特性是不怎么了解的, 迁移起来也很麻烦, 普遍还是使用空指针和捕获空指针异常来处理.&lt;/p>
&lt;p>而在 &lt;code>Rust&lt;/code> 中 &lt;code>Option&lt;/code> 遍布了各个角落, &lt;code>Option&lt;/code> 只是一个简单的枚举, 所以我们直接说明下 &lt;code>Rust&lt;/code> 中使用枚举处理空指针和异常错误的方法.&lt;/p>
&lt;h2 id="枚举">枚举&lt;/h2>
&lt;h3 id="option">Option&lt;/h3>
&lt;p>&lt;code>Option&lt;/code> 只是一个简单的枚举类型, 但是在 &lt;code>Rust&lt;/code> 中枚举是很强大的.&lt;/p>
&lt;p>&lt;code>Option&lt;/code> 的签名是&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> Option&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> None,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Some(T),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>它是这么使用的:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> Option::Some(&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">match&lt;/span> x {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Some(x) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> println!(&lt;span style="color:#e6db74">&amp;#34;Val is: {}&amp;#34;&lt;/span>, x),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> None &lt;span style="color:#f92672">=&amp;gt;&lt;/span> println!(&lt;span style="color:#e6db74">&amp;#34;No val&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 &lt;code>Rust&lt;/code> 中对于枚举的所有类型都强制遍历处理, 当然也可以用 &lt;code>_&lt;/code> 来忽略掉不需要的部分, 所有我们不确定是否有值的地方都需要用 &lt;code>Option&lt;/code> 来表示.&lt;/p>
&lt;h3 id="result">Result&lt;/h3>
&lt;p>&lt;code>Rust&lt;/code> 中也是用枚举来处理异常错误.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::net::TcpStream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> tcp_stream &lt;span style="color:#f92672">=&lt;/span> TcpStream::connect(&lt;span style="color:#e6db74">&amp;#34;127.0.0.1:8000&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">match&lt;/span> tcp_stream {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Ok(_) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> println!(&lt;span style="color:#e6db74">&amp;#34;success&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Err(e) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> println!(&lt;span style="color:#e6db74">&amp;#34;{}&amp;#34;&lt;/span>, e),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不需要捕获异常, 要知道 &lt;code>Java&lt;/code> 中捕获异常是很耗费性能的, 使用枚举来处理空指针和异常错误是不是很优雅~&lt;/p>
&lt;p>除了使用模式匹配外, 我们还可以使用 &lt;code>if let&lt;/code> , 如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::net::TcpStream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> tcp_stream &lt;span style="color:#f92672">=&lt;/span> TcpStream::connect(&lt;span style="color:#e6db74">&amp;#34;127.0.0.1:8000&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> Ok(_) &lt;span style="color:#f92672">=&lt;/span> tcp_stream {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;success&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;error&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样类似的还有 &lt;code>while let&lt;/code> .&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>上述差不多说明了一些为什么我选择学 &lt;code>Rust&lt;/code> 的理由, 当然还有很多其它的, 我所述并不足以解释 &lt;code>Rust&lt;/code> 在最受程序员欢迎的语言调查中占据榜一.&lt;/p>
&lt;p>我在写 &lt;code>C&lt;/code> 代码的时候, 总会纠结该不该释放内存, 有没有野指针的可能. 也烦恼与标准库不够好用, 各平台头文件不够统一, 没法编写多平台通用的代码.&lt;/p>
&lt;p>同样的, 在写 &lt;code>Java&lt;/code> 的时候又会感觉有些啰嗦, 很多写法不够简洁.&lt;/p>
&lt;p>而 &lt;code>Rust&lt;/code> 的话, 标准库足够好用, 是否内存安全有编译器提醒, 而且写起来有很多语法糖比 &lt;code>Java&lt;/code> 要小巧很多, 也只有很小的运行时, 没有垃圾回收, 可以直接打包成二进制文件运行. 性能与 &lt;code>C&lt;/code> 是差不多的.&lt;/p>
&lt;p>不过说来我学 &lt;code>Rust&lt;/code> 还有一个原因是因为它够难, 而且没什么历史包袱, 比较有挑战. &lt;code>C++&lt;/code> 的历史包袱换个词也可以说是经验积累, 不过我个人觉得有些太过厚重, 有些难啃吧.&lt;/p>
&lt;p>本文浅尝辄止, 简单说明了一些 &lt;code>Rust&lt;/code> 的特性. 这些特性差不多都是众多程序员在编写 &lt;code>C/C++&lt;/code> 程序中总结出来的类似于最佳实践之类的东西. 所以本文也大量对比了 &lt;code>Rust&lt;/code> 和 &lt;code>C&lt;/code> , 并且学习 &lt;code>Rust&lt;/code> 也是离不开 &lt;code>C&lt;/code> 的, 其中存在了 &lt;code>unsafe&lt;/code> 这样的东西. 不了解 &lt;code>C&lt;/code> 的话是没法写 &lt;code>unsafe&lt;/code> 部分的, 当然这部分大部分程序员也不怎么会接触到.&lt;/p>
&lt;p>同时 &lt;code>Rust&lt;/code> 作为系统级语言, 与 &lt;code>C&lt;/code> 也有着非常友好的交互性, 很容易使用的 &lt;code>FFI&lt;/code> , 不管是为了从 &lt;code>C&lt;/code> 逐步切换到 &lt;code>Rust&lt;/code> , 还是为了牺牲点安全提高灵活性的目的而使用 &lt;code>FFI&lt;/code> , 这都算是一个亮点了. 毕竟 &lt;code>C&lt;/code> 在各个领域都算是不可或缺的基本编程语言了.&lt;/p></description></item></channel></rss>