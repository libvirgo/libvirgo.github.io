<!doctype html><html lang dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="逆变和协变看了忘忘了看, 这次学C#顺带查阅各处总结了下&amp;hellip;
协变
协变是指能够使用比原始指定的类型派生程度更大的类型.
例如Dog与Cat继承自Animal, 那么从Dog-&amp;gt;Animal就称为协变, 那么协变有什么作用呢?
// Animal.cs public abstract class Animal { } public class Dog : Animal { } // Main.cs public static void Main() { Dog dog = new Dog(); Animal animal = dog; List&amp;lt;Dog&amp;gt; dogs = new List&amp;lt;Dog&amp;gt;(); List&amp;lt;Animal&amp;gt; animals = dogs; // error } Dog继承自Animal, 所以Dog可以隐式的转化为Animal, 但是List与List之间没有继承关系, 所以无法隐式转换, 如果想要隐式转换需要如下代码:
List&amp;lt;Animal&amp;gt; animals = dogs.Select(d =&amp;gt; (Animal)d).ToList(); 将小狗列表中的小狗挨个显式转换为Animal.
所以C#提供了协变的语法糖, 也就是out, 意思是指该泛型可以作为输出返回. 也就是说可以用如下代码:
// Main.cs public static void Main() { Dog dog = new Dog(); Animal animal = dog; IEnumerable&amp;lt;Dog&amp;gt; dogs = new List&amp;lt;Dog&amp;gt;(); IEnumerable&amp;lt;Animal&amp;gt; animals = dogs; } // IEnumerable public interface IEnumerable&amp;lt;out T&amp;gt;: IEnumerable 因为T只能作为结果返回, 所以T不会被修改, 编译器可以帮我们进行强制转换."><title>逆变与协变</title><link rel=canonical href=/post/programming_language/covariance_and_contravariance/><link rel=stylesheet href=/scss/style.min.ac77dcf8b111b51da39a92990f431923f210f3876d85798a2125667f96dc33a4.css><meta property="og:title" content="逆变与协变"><meta property="og:description" content="逆变和协变看了忘忘了看, 这次学C#顺带查阅各处总结了下&amp;hellip;
协变
协变是指能够使用比原始指定的类型派生程度更大的类型.
例如Dog与Cat继承自Animal, 那么从Dog-&amp;gt;Animal就称为协变, 那么协变有什么作用呢?
// Animal.cs public abstract class Animal { } public class Dog : Animal { } // Main.cs public static void Main() { Dog dog = new Dog(); Animal animal = dog; List&amp;lt;Dog&amp;gt; dogs = new List&amp;lt;Dog&amp;gt;(); List&amp;lt;Animal&amp;gt; animals = dogs; // error } Dog继承自Animal, 所以Dog可以隐式的转化为Animal, 但是List与List之间没有继承关系, 所以无法隐式转换, 如果想要隐式转换需要如下代码:
List&amp;lt;Animal&amp;gt; animals = dogs.Select(d =&amp;gt; (Animal)d).ToList(); 将小狗列表中的小狗挨个显式转换为Animal.
所以C#提供了协变的语法糖, 也就是out, 意思是指该泛型可以作为输出返回. 也就是说可以用如下代码:
// Main.cs public static void Main() { Dog dog = new Dog(); Animal animal = dog; IEnumerable&amp;lt;Dog&amp;gt; dogs = new List&amp;lt;Dog&amp;gt;(); IEnumerable&amp;lt;Animal&amp;gt; animals = dogs; } // IEnumerable public interface IEnumerable&amp;lt;out T&amp;gt;: IEnumerable 因为T只能作为结果返回, 所以T不会被修改, 编译器可以帮我们进行强制转换."><meta property="og:url" content="/post/programming_language/covariance_and_contravariance/"><meta property="og:site_name" content><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="Concept"><meta property="article:tag" content="Note"><meta property="article:published_time" content="2021-05-01T00:50:44+08:00"><meta property="article:modified_time" content="2021-05-01T00:50:44+08:00"><meta name=twitter:title content="逆变与协变"><meta name=twitter:description content="逆变和协变看了忘忘了看, 这次学C#顺带查阅各处总结了下&amp;hellip;
协变
协变是指能够使用比原始指定的类型派生程度更大的类型.
例如Dog与Cat继承自Animal, 那么从Dog-&amp;gt;Animal就称为协变, 那么协变有什么作用呢?
// Animal.cs public abstract class Animal { } public class Dog : Animal { } // Main.cs public static void Main() { Dog dog = new Dog(); Animal animal = dog; List&amp;lt;Dog&amp;gt; dogs = new List&amp;lt;Dog&amp;gt;(); List&amp;lt;Animal&amp;gt; animals = dogs; // error } Dog继承自Animal, 所以Dog可以隐式的转化为Animal, 但是List与List之间没有继承关系, 所以无法隐式转换, 如果想要隐式转换需要如下代码:
List&amp;lt;Animal&amp;gt; animals = dogs.Select(d =&amp;gt; (Animal)d).ToList(); 将小狗列表中的小狗挨个显式转换为Animal.
所以C#提供了协变的语法糖, 也就是out, 意思是指该泛型可以作为输出返回. 也就是说可以用如下代码:
// Main.cs public static void Main() { Dog dog = new Dog(); Animal animal = dog; IEnumerable&amp;lt;Dog&amp;gt; dogs = new List&amp;lt;Dog&amp;gt;(); IEnumerable&amp;lt;Animal&amp;gt; animals = dogs; } // IEnumerable public interface IEnumerable&amp;lt;out T&amp;gt;: IEnumerable 因为T只能作为结果返回, 所以T不会被修改, 编译器可以帮我们进行强制转换."><link rel="shortcut icon" href=/favicon.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hubab1a6f26c99bd4005799835b3b49dcb_56897_300x0_resize_box_3.png width=300 height=321 class=site-logo loading=lazy alt=Avatar></a>
<span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/></a></h1><h2 class=site-description>Tech is and always will be political.</h2></div></header><ol class=menu id=main-menu><li><a href=/page/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About</span></a></li><li><a href=/page/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/page/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/post/programming_language/covariance_and_contravariance/>逆变与协变</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>May 01, 2021</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>2 minute read</time></div></footer></div></header><section class=article-content><blockquote><p>逆变和协变看了忘忘了看, 这次学C#顺带查阅各处总结了下&mldr;</p></blockquote><p><strong>协变</strong></p><p>协变是指能够使用比原始指定的类型派生程度更大的类型.</p><p>例如Dog与Cat继承自Animal, 那么从Dog->Animal就称为协变, 那么协变有什么作用呢?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=c1>// Animal.cs</span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>abstract</span> <span class=k>class</span> <span class=nc>Animal</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>class</span> <span class=nc>Dog</span> <span class=p>:</span> <span class=n>Animal</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=c1>// Main.cs</span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Dog</span> <span class=n>dog</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Dog</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Animal</span> <span class=n>animal</span> <span class=p>=</span> <span class=n>dog</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=p>&lt;</span><span class=n>Dog</span><span class=p>&gt;</span> <span class=n>dogs</span> <span class=p>=</span> <span class=k>new</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Dog</span><span class=p>&gt;();</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=p>&lt;</span><span class=n>Animal</span><span class=p>&gt;</span> <span class=n>animals</span> <span class=p>=</span> <span class=n>dogs</span><span class=p>;</span> <span class=c1>// error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Dog继承自Animal, 所以Dog可以隐式的转化为Animal, 但是List<dog>与List<animal>之间没有继承关系, 所以无法隐式转换, 如果想要隐式转换需要如下代码:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=n>List</span><span class=p>&lt;</span><span class=n>Animal</span><span class=p>&gt;</span> <span class=n>animals</span> <span class=p>=</span> <span class=n>dogs</span><span class=p>.</span><span class=n>Select</span><span class=p>(</span><span class=n>d</span> <span class=p>=&gt;</span> <span class=p>(</span><span class=n>Animal</span><span class=p>)</span><span class=n>d</span><span class=p>).</span><span class=n>ToList</span><span class=p>();</span>
</span></span></code></pre></div><p>将小狗列表中的小狗挨个显式转换为Animal.</p><p>所以C#提供了协变的语法糖, 也就是out, 意思是指该泛型可以作为输出返回.
也就是说可以用如下代码:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=c1>// Main.cs </span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>()</span> 
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=n>Dog</span> <span class=n>dog</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Dog</span><span class=p>();</span> 
</span></span><span class=line><span class=cl>    <span class=n>Animal</span> <span class=n>animal</span> <span class=p>=</span> <span class=n>dog</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=n>IEnumerable</span><span class=p>&lt;</span><span class=n>Dog</span><span class=p>&gt;</span> <span class=n>dogs</span> <span class=p>=</span> <span class=k>new</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Dog</span><span class=p>&gt;();</span>
</span></span><span class=line><span class=cl>    <span class=n>IEnumerable</span><span class=p>&lt;</span><span class=n>Animal</span><span class=p>&gt;</span> <span class=n>animals</span> <span class=p>=</span> <span class=n>dogs</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// IEnumerable</span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>interface</span> <span class=nc>IEnumerable</span><span class=p>&lt;</span><span class=k>out</span> <span class=n>T</span><span class=p>&gt;:</span> <span class=n>IEnumerable</span>
</span></span></code></pre></div><p>因为T只能作为结果返回, 所以T不会被修改, 编译器可以帮我们进行强制转换.
但实际上out只是上面强制转换的一个语法糖而已, 实际上反编译的代码依然进行的是强制类型转换.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=n>IEnumerable</span><span class=p>&lt;</span><span class=n>Animal</span><span class=p>&gt;</span> <span class=n>animals</span> <span class=p>=</span> <span class=p>(</span><span class=n>IEnumerable</span><span class=p>&lt;</span><span class=n>Animal</span><span class=p>&gt;)</span> <span class=n>dogs</span><span class=p>;</span>
</span></span></code></pre></div><p>至于为什么只能作为结果返回而不能作为输入呢?
我们假设:</p><ul><li>A ≼ B 意味着 A 是 B 的子类型.</li><li>A → B 指的是以 A 为参数类型, 以 B 为返回值类型的函数类型.</li><li>x : A 意味着 x 的类型为 A.
假设我有如下三种类型:</li></ul><pre tabindex=0><code>Greyhound ≼ Dog ≼ Animal
</code></pre><p>问题: 以下哪种类型是 Dog → Dog 的子类型呢？</p><ol><li>Greyhound → Greyhound</li><li>Greyhound → Animal</li><li>Animal → Animal</li><li>Animal → Greyhound</li></ol><p>我们假设 f 是一个以 Dog → Dog 为参数的函数, 那么可以这样假设: f : (Dog → Dog) → String</p><p>那么容易回答上述问题:</p><ol><li>不是, 因为传入的类型可能是狗的其它自类型但不是灰狗, 这样也是符合函数签名的, 但是答案1就不符合了.</li><li>同上</li><li>不是, 因为有可能 f 在调用完参数之后让它的返回值(Animal)狗叫, 但是并非所有的动物都会狗叫, 所以同样存在符合函数签名但不是答案4的结果.</li><li>是的, 所有的Dog都是Animal, 所以传进去的任何Dog都是符合的, 而所有的Greyhoud都是狗, 也都可以狗叫.</li></ol><p>这样就可以得到我们最初的答案了&mdash;为什么只能作为结果返回而不能作为参数输入, 因为所有的Dog都是Animal, 但是如果作为参数的话, 那么不是所有的Animal都是Dog, 就有可能往IEnumerable<dog>里传一个Cat, 但这又是符合IEnumerable<animal>签名的, 所以是不行的.</p><p>而由上面的例子也可以得到, 与协变相反的就是逆变, 也就是超类可以作为泛型参数而不能作为输出结果, 简单的公式为:
(Animal → Greyhound) ≼ (Dog → Dog)</p><p>解释为: 我们允许一个函数类型中, 返回值类型是协变的, 而参数类型是逆变的. 返回值类型是协变的, 意思是 A ≼ B 就意味着 (T → A) ≼ (T → B) . 参数类型是逆变的, 意思是 A ≼ B 就意味着 (B → T) ≼ (A → T)  A 和 B 的位置颠倒过来了, 通俗点协变就是返回值可以是超类, 而逆变则是参数可以是子类.</p></section><footer class=article-footer><section class=article-tags><a href=/tags/concept/>Concept</a>
<a href=/tags/note/>Note</a></section></footer></article><footer class=site-footer><section class=copyright>&copy;
2022</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.13.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>