<!doctype html><html lang dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="小记自己为什么会学 Rust . Rust 有什么特性吸引到我了~
如果说 C 语言是具备高灵活性, 信任着开发者, 将一切交给开发者来解决的话.
那么 Rust 就是降低该灵活性, 毫不信任开发者, 将开发者的大部分错误都在编译期发掘出来, 强制要求开发者去了解可能存在的问题并解决掉它.
C 语言可能条条大路通罗马, Rust 可能只有寥寥无几的道路.
总之, Rust 拔高了开发者的下限, 如果水平不够是连编译器都不会通过的, 更不要说 commit 了.
优雅的Rust 听说到 Rust 最多的自然是所谓的内存安全. 那么什么是内存安全？ 内存安全体现在哪里呢？
比如说这段 C语言 代码.
int a[5]; a[6] = 6; printf(&amp;#34;%d&amp;#34;, a[6]); 这段代码能正确输出 a[6] 吗?
答案是可以的, 虽然它很明显的内存越界了, 但内存越界似乎在 C 里并不是什么大不了的事, 编写的代码随便越界, 只不过导致的后果需要自己承担而已.
当然现今大部分的高级语言对指针越界都会有很明确的编译错误, 所以仅这点来看并不能体现出 Rust 的特点, 只不过是有了现代语言该有的东西——内存越界提示.
那么有什么可以体现出 Rust 独有特性的地方呢?
参考这一段结构体.
typedef struct { struct Node *next; int val; }Node; typedef struct { Node *head; Node *tail; int size; }LinkedList; struct { void (*push)(struct LinkedList *self, Node val); Node *(*peek)(struct LinkedList *self); Node *(*pop)(struct LinkedList *self); }StackMethod; 这是一个简单的数据结构栈, 在栈方法中定义了三个函数指针, 不需要关注 push 方法, 来看看 peek 方法."><title>优雅的Rust</title><link rel=canonical href=/post/rust/elegent_rust/><link rel=stylesheet href=/scss/style.min.8191399262444ab68b72a18c97392f5349be20a1615d77445be51e974c144cff.css><meta property="og:title" content="优雅的Rust"><meta property="og:description" content="小记自己为什么会学 Rust . Rust 有什么特性吸引到我了~
如果说 C 语言是具备高灵活性, 信任着开发者, 将一切交给开发者来解决的话.
那么 Rust 就是降低该灵活性, 毫不信任开发者, 将开发者的大部分错误都在编译期发掘出来, 强制要求开发者去了解可能存在的问题并解决掉它.
C 语言可能条条大路通罗马, Rust 可能只有寥寥无几的道路.
总之, Rust 拔高了开发者的下限, 如果水平不够是连编译器都不会通过的, 更不要说 commit 了.
优雅的Rust 听说到 Rust 最多的自然是所谓的内存安全. 那么什么是内存安全？ 内存安全体现在哪里呢？
比如说这段 C语言 代码.
int a[5]; a[6] = 6; printf(&amp;#34;%d&amp;#34;, a[6]); 这段代码能正确输出 a[6] 吗?
答案是可以的, 虽然它很明显的内存越界了, 但内存越界似乎在 C 里并不是什么大不了的事, 编写的代码随便越界, 只不过导致的后果需要自己承担而已.
当然现今大部分的高级语言对指针越界都会有很明确的编译错误, 所以仅这点来看并不能体现出 Rust 的特点, 只不过是有了现代语言该有的东西——内存越界提示.
那么有什么可以体现出 Rust 独有特性的地方呢?
参考这一段结构体.
typedef struct { struct Node *next; int val; }Node; typedef struct { Node *head; Node *tail; int size; }LinkedList; struct { void (*push)(struct LinkedList *self, Node val); Node *(*peek)(struct LinkedList *self); Node *(*pop)(struct LinkedList *self); }StackMethod; 这是一个简单的数据结构栈, 在栈方法中定义了三个函数指针, 不需要关注 push 方法, 来看看 peek 方法."><meta property="og:url" content="/post/rust/elegent_rust/"><meta property="og:site_name" content="Rabbit hole"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="Basic"><meta property="article:tag" content="Rust"><meta property="article:published_time" content="2020-09-15T15:30:44+08:00"><meta property="article:modified_time" content="2020-09-15T15:30:44+08:00"><meta property="og:image" content="/post/rust/elegent_rust/cover.png"><meta name=twitter:title content="优雅的Rust"><meta name=twitter:description content="小记自己为什么会学 Rust . Rust 有什么特性吸引到我了~
如果说 C 语言是具备高灵活性, 信任着开发者, 将一切交给开发者来解决的话.
那么 Rust 就是降低该灵活性, 毫不信任开发者, 将开发者的大部分错误都在编译期发掘出来, 强制要求开发者去了解可能存在的问题并解决掉它.
C 语言可能条条大路通罗马, Rust 可能只有寥寥无几的道路.
总之, Rust 拔高了开发者的下限, 如果水平不够是连编译器都不会通过的, 更不要说 commit 了.
优雅的Rust 听说到 Rust 最多的自然是所谓的内存安全. 那么什么是内存安全？ 内存安全体现在哪里呢？
比如说这段 C语言 代码.
int a[5]; a[6] = 6; printf(&amp;#34;%d&amp;#34;, a[6]); 这段代码能正确输出 a[6] 吗?
答案是可以的, 虽然它很明显的内存越界了, 但内存越界似乎在 C 里并不是什么大不了的事, 编写的代码随便越界, 只不过导致的后果需要自己承担而已.
当然现今大部分的高级语言对指针越界都会有很明确的编译错误, 所以仅这点来看并不能体现出 Rust 的特点, 只不过是有了现代语言该有的东西——内存越界提示.
那么有什么可以体现出 Rust 独有特性的地方呢?
参考这一段结构体.
typedef struct { struct Node *next; int val; }Node; typedef struct { Node *head; Node *tail; int size; }LinkedList; struct { void (*push)(struct LinkedList *self, Node val); Node *(*peek)(struct LinkedList *self); Node *(*pop)(struct LinkedList *self); }StackMethod; 这是一个简单的数据结构栈, 在栈方法中定义了三个函数指针, 不需要关注 push 方法, 来看看 peek 方法."><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/post/rust/elegent_rust/cover.png"><link rel="shortcut icon" href=/favicon.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hubab1a6f26c99bd4005799835b3b49dcb_56897_300x0_resize_box_3.png width=300 height=321 class=site-logo loading=lazy alt=Avatar></a>
<span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>Rabbit hole</a></h1><h2 class=site-description>Tech is and always will be political.</h2></div></header><ol class=social-menu><li><a href=https://github.com/libvirgo/ target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/page/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About</span></a></li><li><a href=/page/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/page/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#优雅的rust>优雅的Rust</a><ol><li><a href=#所有权>所有权</a></li><li><a href=#可变性与不可变性>可变性与不可变性</a></li><li><a href=#生命周期>生命周期</a></li><li><a href=#trait>Trait</a></li><li><a href=#枚举>枚举</a><ol><li><a href=#option>Option</a></li><li><a href=#result>Result</a></li></ol></li><li><a href=#summary>Summary</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/post/rust/elegent_rust/><img src=/post/rust/elegent_rust/cover_hu99bb65b34be40363fd484c863e327c7b_227902_800x0_resize_box_3.png srcset="/post/rust/elegent_rust/cover_hu99bb65b34be40363fd484c863e327c7b_227902_800x0_resize_box_3.png 800w, /post/rust/elegent_rust/cover_hu99bb65b34be40363fd484c863e327c7b_227902_1600x0_resize_box_3.png 1600w" width=800 height=476 loading=lazy alt="Featured image of post 优雅的Rust"></a></div><div class=article-details><header class=article-category><a href=/categories/rust/>Rust</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/rust/elegent_rust/>优雅的Rust</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Sep 15, 2020</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>9 minute read</time></div></footer></div></header><section class=article-content><p>小记自己为什么会学 <code>Rust</code> . <code>Rust</code> 有什么特性吸引到我了~</p><hr><p>如果说 <code>C</code> 语言是具备高灵活性, 信任着开发者, 将一切交给开发者来解决的话.</p><p>那么 <code>Rust</code> 就是降低该灵活性, 毫不信任开发者, 将开发者的大部分错误都在编译期发掘出来, 强制要求开发者去了解可能存在的问题并解决掉它.</p><p><code>C</code> 语言可能条条大路通罗马, <code>Rust</code> 可能只有寥寥无几的道路.</p><p>总之, <code>Rust</code> 拔高了开发者的下限, 如果水平不够是连编译器都不会通过的, 更不要说 <code>commit</code> 了.</p><h1 id=优雅的rust>优雅的Rust</h1><p>听说到 <code>Rust</code> 最多的自然是所谓的内存安全. 那么什么是内存安全？ 内存安全体现在哪里呢？</p><p>比如说这段 <code>C语言</code> 代码.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>[</span><span class=mi>5</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=p>[</span><span class=mi>6</span><span class=p>]</span> <span class=o>=</span> <span class=mi>6</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>[</span><span class=mi>6</span><span class=p>]);</span>
</span></span></code></pre></div><p>这段代码能正确输出 <code>a[6]</code> 吗?</p><p>答案是可以的, 虽然它很明显的内存越界了, 但内存越界似乎在 <code>C</code> 里并不是什么<code>大不了</code>的事, 编写的代码随便越界, 只不过导致的后果需要自己承担而已.</p><p>当然现今大部分的高级语言对指针越界都会有很明确的编译错误, 所以仅这点来看并不能体现出 <code>Rust</code> 的特点, 只不过是有了现代语言该有的东西——内存越界提示.</p><p>那么有什么可以体现出 <code>Rust</code> 独有特性的地方呢?</p><p>参考这一段结构体.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>Node</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>Node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=n>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>LinkedList</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>push</span><span class=p>)(</span><span class=k>struct</span> <span class=n>LinkedList</span> <span class=o>*</span><span class=n>self</span><span class=p>,</span> <span class=n>Node</span> <span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>peek</span><span class=p>)(</span><span class=k>struct</span> <span class=n>LinkedList</span> <span class=o>*</span><span class=n>self</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>pop</span><span class=p>)(</span><span class=k>struct</span> <span class=n>LinkedList</span> <span class=o>*</span><span class=n>self</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>StackMethod</span><span class=p>;</span>
</span></span></code></pre></div><p>这是一个简单的数据结构栈, 在栈方法中定义了三个函数指针, 不需要关注 <code>push</code> 方法, 来看看 <code>peek</code> 方法.</p><p><code>peek</code> 方法将栈中的尾结点返回, 和 <code>pop</code> 方法的区别是它不会从链表中删除该节点. 但此时该方法的调用者拥有了该节点的所有权限, 如果调用者此时又释放了该地址指向的内存, 当再次调用 <code>pop</code> 方法时, <code>pop</code> 方法将返回一个已经释放了内存的结点指针, 此时如果访问该结点大概率会出现 <code>Segementation fault</code>. 因为访问了一个没有分配的内存空间. <code>Segementation fault</code> 大概是我写 <code>C</code> 时候最讨厌的错误了.</p><p>那么 <code>Rust</code> 是如何解决的呢? 答案是<code>所有权</code>.</p><h2 id=所有权>所有权</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在将 <code>s1</code> 赋值给 <code>s2</code> 后, 此时 <code>s1</code> 就已经是无效的了, 它的作用域仅到赋值给 <code>s2</code> 之前为止.</p><p>同样类似的.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>hello</span><span class=p>(</span><span class=kt>str</span>: <span class=nb>String</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=kt>str</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;hello&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>hello</span><span class=p>(</span><span class=n>s1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s1</span><span class=p>);</span><span class=w>  </span><span class=c1>// error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>这段相等同的 <code>C</code> 代码会有问题么?</p><p>可能会有问题. 如果在 <code>hello</code> 中释放了内存, 那么 <code>main</code> 函数中后续对 <code>s1</code> 的访问就会出现段错误. 就像这样:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>hello</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span> <span class=n>str</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>s1</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=sc>&#39;h&#39;</span><span class=p>,</span> <span class=sc>&#39;e&#39;</span><span class=p>,</span> <span class=sc>&#39;l&#39;</span><span class=p>,</span> <span class=sc>&#39;l&#39;</span><span class=p>,</span> <span class=sc>&#39;o&#39;</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=nf>hello</span><span class=p>(</span><span class=n>s1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>s1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在 <code>Rust</code> 中就完全避免了这种情况, 这样的代码在Rust中连编译都不会通过的.</p><p>那么 <code>main</code> 函数后续不能再用该变量了吗? 有两种方法可以解决该问题.</p><p>可以将 <code>hello</code> 函数的签名增加个返回值, 使用完变量后将其所有权返回给调用者. <code>main</code> 函数也需要提供一个接收者接收该变量的所有, 该做法使用了 <code>Rust</code> 变量覆盖的特性, 可以声明同名变量, 就跟 <code>Javascript</code> 类似. 后续声明的同名变量会覆盖先前的.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>hello</span><span class=p>(</span><span class=kt>str</span>: <span class=nb>String</span><span class=p>)</span><span class=w> </span>-&gt;<span class=nb>String</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>println</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=kt>str</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>str</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;hello&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>hello</span><span class=p>(</span><span class=n>s1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>第一种是个很自然而且很容易想到并理解的做法( <code>Rust</code> 中函数块最后一行且没有带分号的会被当做返回值, 所以可以省略掉 <code>return</code> ). 还有另一种做法, 那就是引用.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>hello</span><span class=p>(</span><span class=kt>str</span>: <span class=kp>&amp;</span><span class=nb>String</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=kt>str</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;hello&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>hello</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>使用 <code>&</code> 表示一个引用或引用类型, <code>*</code> 则表现为消除 <code>&</code>, 也就是解引用. 用法类似与 <code>C</code> 中的指针. 而在 <code>Rust</code> 中是会自动解引用的, 所以 <code>hello</code> 函数也可以改为:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>hello</span><span class=p>(</span><span class=kt>str</span>: <span class=kp>&amp;</span><span class=nb>String</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=kt>str</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在 <code>C</code> 中可能存在的野指针问题在 <code>Rust</code> 中也可以通过所有权系统来解决.</p><blockquote><p>野指针主要为未初始化或释放后未置空或操作超越变量作用域.</p></blockquote><p>参照如下 <code>C</code> 代码:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>q</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>q</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;q = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=n>q</span><span class=p>);</span>  <span class=c1>//此处打印 q = 2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;q = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=n>q</span><span class=p>);</span>  <span class=c1>//此处打印 q = 4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>是不是很神奇. 那么为什么会出现这种现象?</p><p>因为在 <code>C</code> 中使用 <code>malloc</code> 分配内存的时候, 会优先分配前次释放的内存, 所以两处调用 <code>malloc</code> 所得到的地址是一样的. 在释放 <code>p</code> 之后, 没有对 <code>p</code> 进行赋空操作, 此时 <code>p</code> 就成了一个野指针. 然后接着又分配了一个跟前序 <code>p</code> 一样大小的内存空间, 此时 <code>p</code> 和 <code>q</code> 就是一样的了——指向相同的地址. 所以对 <code>p</code> 指向的值进行的修改会反映在 <code>q</code> 上. 虽然简单的在释放 <code>p</code> 后给其赋值为 <code>NULL</code> 就可以了, 但是如果有个人疏忽了呢? 毕竟人是不会永远不犯错的. 在 <code>Rust</code> 中类似这样的代码是不可能通过的, 因为在释放 <code>p</code> 的时候所有权已经转移给 <code>free</code> 函数了, <code>main</code>函数后续是不能再使用的.</p><p>不管是学过 <code>Java</code> 的还是学过 <code>C</code> 的, 肯定都多多少少了解过关于引用传递和值传递, 有相当多的教学声明 <code>Java</code> 中仅存在值传递.</p><p>在 <code>C</code> 语言中指针则类似于引用传递, 通过地址引用指向内存空间的值. 因为有地址所以可以修改其中的值并且被其它函数观察到. 传递引用有一个问题, 有时候我们并不想别人改变我们的值, 但又不得不声明为指针(比如说结构体的自引用), 同时又忘了给该参数声明为 <code>const</code> , 这样就会有很多问题. 尤其在初学 <code>C</code> 的时候, 几乎很少有人会用到 <code>const</code> 关键词. 很多人是不晓得该关键词到底有多么重要的, 而 <code>Rust</code> 就会强迫我们去学习, 了解不可变的重要性.</p><p>那么很自然的就过渡到下一个阶段~</p><h2 id=可变性与不可变性>可变性与不可变性</h2><p>然而在 <code>Rust</code> 中所有的变量如果不显式声明, 那就是不可修改的( <code>unsafe</code> 是特例). 所以如果要传递一个可变引用, 就需要如下的声明:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>hello</span><span class=p>(</span><span class=kt>str</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=nb>String</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=kt>str</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>str</span><span class=p>.</span><span class=n>push_str</span><span class=p>(</span><span class=s>&#34;world&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>//3. 修改str的值.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;hello&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>();</span><span class=w> </span><span class=c1>//1. 此处声明s1是可变的变量.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>hello</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>s1</span><span class=p>);</span><span class=w>  </span><span class=c1>//2. 传递一个可变引用给hello函数.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>显式声明 <code>str</code> 是可变的, 否则对变量做的任何修改在编译期都是无法通过的. 这就避免了很多 <code>Code</code> 时的隐性错误.</p><p><code>Rust</code> 中关于该特性有几个关键点.</p><ol><li>变量可以有多个不可变引用.</li><li>变量只能有一个可变引用.</li><li>变量有可变引用的同时不能有不可变引用.</li></ol><p>比如如下代码:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;hello&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>s1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>hello</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>s1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>编译时会报错</p><blockquote><p>error[E0502]: cannot borrow <code>s1</code> as mutable because it is also borrowed as immutable</p></blockquote><p>错误提示相当友好了, 不能将 <code>s1</code> 作为可变引用因为它已经有一个不可变引用了. 为什么要这么设计?</p><p>可以想象一下在 <code>C</code> 中, 编写了一个返回指针的函数, 有多个不同调用方或许都对指向的值进行了修改, 某个调用方又如何知道该值是否是最初的函数所返回的呢? 还是因为各个调用方可能进行的修改后的结果. 解决方法肯定是有的, 比如说注意一下各个调用方的顺序之类的, 只是有时项目庞大而复杂, 是没法顾及到方方面面, 这时是需要有个 &ldquo;人&rdquo; 来提醒一下我们.</p><p>因此, 可变引用与不可变引用直接是互斥的, 不可变引用之间也是互斥的, 它们不能同时存在.</p><p>上面的代码调换一下位置就可以了.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;hello&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>hello</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>s1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>s1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>此时在 <code>s2</code> 声明的位置, <code>s1</code> 的可变引用的作用域已经结束, 现在 <code>s1</code> 是没有其它引用的, 所以可以拿到其的一个引用.</p><hr><p>在这里, 为了引入个下一话题, 我们不自然地回顾一下上一章节的野指针问题~</p><p>类似的如下 <code>C</code> 代码:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>char</span> <span class=o>*</span><span class=nf>dangle</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>a</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=s>&#34;abc&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>dangle</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在函数结束的时候变量 <code>a</code> 已经被销毁, 将该地址返回就会产生野指针.</p><p>如何修正该代码?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>char</span> <span class=o>*</span><span class=nf>dangle</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>a</span> <span class=o>=</span> <span class=s>&#34;abc&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>dangle</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这样就可以了.这样所声明的变量 <code>a</code> 实际上为字符串常量, 是不可变的, 存储在静态存储区. 由程序结束后操作系统回收该部分内存. 所以在函数结束后 <code>a</code> 指向的值是不会被销毁的. 将该地址返回也是完全没有错误的.</p><p>这些细枝末节在初学 <code>C</code> 的时候是很难注意到的. 毕竟大多数大学生使用的教材还是谭浩强版, 用于应试是够了, 实际开发是远远不行的.</p><p>如果在 <code>Rust</code> 中写出这样的代码呢?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>reference_to_nothing</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>dangle</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>dangle</span><span class=p>()</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nb>String</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>&amp;</span><span class=n>s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>首先说点题外话, 在 <code>Rust</code> 中命名通常用蛇形命名法, 不像 <code>Java</code> 中普遍的是大驼峰和小驼峰. 至于好看与否, 看眼缘吧~</p><p>这里同样的编译是不能通过的.</p><blockquote><p>error[E0106]: missing lifetime specifier
&ndash;> src\main.rs:5:16
|
5 | fn dangle() -> &String {
| ^ expected named lifetime parameter
|
= help: this function&rsquo;s return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the <code>'static</code> lifetime
|
5 | fn dangle() -> &&lsquo;static String {
| ^^^^^^^^</p></blockquote><p>可以说相当友好了, 编译器同时提示了错误是什么, 以及该如何解决它.</p><p>该错误说明了该函数缺少生命周期指示符. 帮助说明了该函数返回的值包含了一个引用值, 但是这种类型是没有可以用来借用的, 需要考虑加上 <code>'static</code> 生命周期, 这样就杜绝了返回局部变量引用的情况.</p><p>这样就引入了下一个话题~</p><h2 id=生命周期>生命周期</h2><p>以下内容主要参考 <a class=link href=https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html target=_blank rel=noopener>The Rust Programming Language</a></p><p>生命周期只是一个标签, 语法是<code>'</code>+字符串/字符. 比如 <code>'a</code>, <code>'b</code>. <code>'static</code> 是一个特殊的生命周期, 表示静态存储, 类似于 <code>Java</code> 和 <code>C\C++</code> 中的 <code>static</code>, 也就是一直存活到程序结束运行才会销毁.</p><p>生命周期主要是为了避免悬垂引用(野指针), 在 <code>Rust编译器</code> 中实现了一个借用检查器, 通过比较作用域来确保所有借用的有效性.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>r</span><span class=p>;</span><span class=w>                </span><span class=c1>// ---------+-- &#39;a
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>{</span><span class=w>                     </span><span class=c1>//          |
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>        </span><span class=c1>// -+-- &#39;b  |
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>x</span><span class=p>;</span><span class=w>           </span><span class=c1>//  |       |
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>                     </span><span class=c1>// -+       |
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;r: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>r</span><span class=p>);</span><span class=w> </span><span class=c1>//          |
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>                         </span><span class=c1>// ---------+  
</span></span></span></code></pre></div><p>这里 <code>r</code> 的生命周期为 <code>'a</code>, <code>x</code> 的生命周期为 <code>'b</code> , <code>'b</code> 的范围小于 <code>'a</code> 的范围, 由于 <code>r</code> 引用了一个存活范围小于它的变量, 所以会编译失败.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>            </span><span class=c1>// ----------+-- &#39;b
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>x</span><span class=p>;</span><span class=w>           </span><span class=c1>// --+-- &#39;a  |
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;r: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>r</span><span class=p>);</span><span class=w> </span><span class=c1>//   |       |
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                          </span><span class=c1>// --+       |
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>                         </span><span class=c1>// ----------+
</span></span></span></code></pre></div><p>改为这样子, 因为 <code>r</code> 的生命周期 <code>'a</code> 小于 <code>'b</code> , 这样就能保证在 <code>r</code> 有效的时候 <code>x</code> 总是有效的, 这样 <code>r</code> 就不可能变成一个野指针.</p><p>考虑这样一个函数:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>longest</span><span class=p>(</span><span class=n>x</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>str</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>x</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>y</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>x</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>y</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>string1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;long string is long&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>string2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;xyz&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>longest</span><span class=p>(</span><span class=n>string1</span><span class=p>.</span><span class=n>as_str</span><span class=p>(),</span><span class=w> </span><span class=n>string2</span><span class=p>.</span><span class=n>as_str</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;The longest string is {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>result</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>乍看之下没有什么问题对吧? 但是编译还是不通过.</p><blockquote><p>error[E0106]: missing lifetime specifier
&ndash;> src\main.rs:1:33
|
1 | fn longest(x: &str, y: &str) -> &str {
| &mdash;- &mdash;- ^ expected named lifetime parameter
|
= help: this function&rsquo;s return type contains a borrowed value, but the signature does not say whether it is borrowed from <code>x</code> or <code>y</code>
help: consider introducing a named lifetime parameter
|
1 | fn longest&lt;&lsquo;a>(x: &&lsquo;a str, y: &&lsquo;a str) -> &&lsquo;a str {
| ^^^^ ^^^^^^^ ^^^^^^^ ^^^</p></blockquote><p>根据报错提示, 我们修改函数签名为<code>fn longest&lt;'a>(x: &'a str, y: &'a str) -> &'a str</code> 这样这段代码就可以正确运行了. 生命周期在函数签名中的用法类似于泛型, 前面多个单引号而已. 然后在对应的参数上声明所需要的生命周期就可以了.</p><p>这个函数签名表示告诉调用者 <code>x</code> , <code>y</code> , <code>str</code> 这三个至少能存活的一样久, 否则就不能编译通过.</p><p>我们修改下 <code>main</code> 函数为如下:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>string1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;long string is long&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>string2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;xyz&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>longest</span><span class=p>(</span><span class=n>string1</span><span class=p>.</span><span class=n>as_str</span><span class=p>(),</span><span class=w> </span><span class=n>string2</span><span class=p>.</span><span class=n>as_str</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;The longest string is {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>result</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>我们将延长 <code>result</code> 的生命周期, 并且将 <code>println</code> 移动到块外面, 这样子编译是不通过的. 来看看编译错误信息:</p><blockquote><p>error[E0597]: <code>string2</code> does not live long enough
&ndash;> src\main.rs:14:44
|
14 | result = longest(string1.as_str(), string2.as_str());
| ^^^^^^^ borrowed value does not live long enough
15 | }
| - <code>string2</code> dropped here while still borrowed
16 | println!(&ldquo;The longest string is {}&rdquo;, result);
| &mdash;&mdash; borrow later used here</p></blockquote><p>提示我们 <code>string2</code> 在 <code>println</code> 前就被释放了. 如果像之前那样没有给函数签名加上生命周期的话, 编译器是不能知道函数返回的值到底能存活多久的, 生命周期表明了返回的值与参数的生命周期应该是一致的, 这里所谓的一致是指同样生命周期标签中最小的那个. 在正确的代码中, 三个参数分别对应的 <code>string1</code>, <code>string2</code>, <code>result</code> 中, 最短的那个是 <code>result</code> , 编译器能推断出在 <code>result</code> 存活的范围它所引用的值是一直有效的.</p><p>而在错误的代码中, <code>string2</code> 是生命周期最短的那个, 所以编译器推断出 <code>result</code> 只能在 <code>string2</code> 存活的范围内使用, 一旦超出该范围, 就可以提示调用者需要修改代码.</p><p>简单说下 <code>Rust</code> 如何清理内存, 只要让它离开作用域就可以了, 离开作用域的时候会自动调用该类型的 <code>drop</code> 方法, 而 <code>drop</code> 一般都是由编译器提供默认实现的, 有时候默认实现不够高效才需要自己去实现. 我们不能调用变量的 <code>drop</code> 方法, 那样就会有多次释放的问题, 如有需要可以调用标准库提供的 <code>drop</code> 函数.</p><p>标准库有提供一个 <code>drop</code> 函数, 用来手动释放内存, 可以看看它的实现~</p><blockquote><p>core::mem
pub fn drop<t>(_x: T)
Disposes of a value.
This does so by calling the argument&rsquo;s implementation of Drop.
This effectively does nothing for types which implement Copy, e.g. integers. Such values are copied and then moved into the function, so the value persists after this function call.
This function is not magic; it is literally defined as
pub fn drop<t>(_x: T) { }</p><p>Because _x is moved into the function, it is automatically dropped before the function returns.</p></blockquote><p>它的实现仅仅是一个空函数块, 将该变量的所有权转移到该函数块中, 在结束的时候调用该变量的 <code>drop</code> 方法.</p><hr><p>上面似乎都是一些内存安全相关的特性, 感觉只体现出来 <code>Rust</code> 编译器的强大, 接下来, 可以转下一个话题了, 简单介绍下 <code>Rust</code> 的一些优雅的语法特性~</p><h2 id=trait>Trait</h2><p><code>Trait</code> 类似与 <code>Java</code> 中的接口概念, 近年来一直以来都有组合大于继承的口号, <code>Trait</code> 就是在 <code>Rust</code> 中用来实现组合这一理念的.</p><p>继承有时候用起来是真的不顺心. 继承吧, 好多用不到的东西, 不继承吧, 又有很多重复工作要做. <code>Rust</code> 中干脆扔掉了继承.</p><p>像前面讲到的实现 <code>drop</code> 方法, 怎么为我们的类型实现 <code>drop</code> 方法呢?</p><p><code>Drop</code> 中只有一个方法, 它的签名为: <code>fn drop(&mut self);</code> 所以我们就像实现接口一样实现该方法就可以了.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>MyVar</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>names</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=nb>Drop</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>MyVar</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>drop</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=n>names</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;MyVar drops&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>MyVar</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>names</span>: <span class=nc>vec</span><span class=o>!</span><span class=p>[</span><span class=s>&#34;hello&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w> </span><span class=s>&#34;world&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>()]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>运行后将打印出 <code>MyVar drops</code> , 可以看出来在离开作用域后就自动调用了我们自定义的 <code>drop</code> 方法.</p><p>可以用 <code>Trait</code> 配合泛型编写一个通用的 <code>largest</code> 函数.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>largest</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nb>PartialOrd</span> <span class=o>+</span><span class=w> </span><span class=nb>Clone</span><span class=o>&gt;</span><span class=p>(</span><span class=n>list</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=n>T</span><span class=p>])</span><span class=w> </span>-&gt; <span class=nc>T</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>largest</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>list</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>clone</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>list</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=o>*</span><span class=n>item</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>largest</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>largest</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>item</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>largest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>number_list</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=mi>34</span><span class=p>,</span><span class=w> </span><span class=mi>50</span><span class=p>,</span><span class=w> </span><span class=mi>25</span><span class=p>,</span><span class=w> </span><span class=mi>100</span><span class=p>,</span><span class=w> </span><span class=mi>65</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>largest</span><span class=p>(</span><span class=o>&amp;</span><span class=n>number_list</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;The largest number is {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>result</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>char_list</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=sc>&#39;y&#39;</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;m&#39;</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;a&#39;</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;q&#39;</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>largest</span><span class=p>(</span><span class=o>&amp;</span><span class=n>char_list</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;The largest char is {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>result</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><code>PartialOrd</code> 是基于排序为目的而比较一个类型, 实现了该 <code>Trait</code> 的类型就可以使用 <code>></code> , <code>&lt;=</code> , <code>></code> , <code>>=</code> , 可以近似的看作 <code>C++</code> 中的操作符重载.</p><p>这里再简单说明一下 <code>Copy</code> 和 <code>Clone</code>.</p><p><code>Clone</code> 就是所谓的 <code>深拷贝</code> , 我们也可以用 <code>Copy</code> , <code>Copy</code> 是浅拷贝.</p><p><code>Copy</code> 是简单的拷贝存储再栈上的位来赋值值, 比较高效, 是一个标记型 <code>Trait</code> , 该 <code>Trait</code> 的实现基准是: 如果一个类型内部的类型全部是 <code>Copy</code> 的, 那么该类型也是 <code>Copy</code> , 比如所有的基本类型. 而 <code>Clone</code> 是深拷贝, 我们需要为必要的类型自己实现该 <code>Trait</code> , 当调用一个 <code>Clone</code> 的时候我们应该知道该操作可能会比较慢.</p><p>我们也可以为 <code>Triat</code> 实现 <code>Trait</code> , 这用到了 <code>Rust</code> 中的动态分发, 这里不详细说明, 只做介绍.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>Animal</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>name</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>String</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>trait</span><span class=w> </span><span class=n>Bark</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>bark</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Dog</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Animal</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Dog</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>name</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>String</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=s>&#34;Kitty&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Bark</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>Animal</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>bark</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{} bark.&#34;</span><span class=p>,</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>name</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>dog</span>: <span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>Animal</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>Dog</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>dog</span><span class=p>.</span><span class=n>bark</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>我们可以用 <code>Trait</code> 来组合成我们最终所需要的类型, 每个 <code>Trait</code> 都是那么的小巧简洁~ 不像是继承, 继承有着严重的耦合, 并且显得不是那么精巧.</p><hr><p>之前我们有提到过 <code>Rust</code> 中是没有空指针的, 那么我们如何表示一个可能存在的值呢?</p><p>如果有人用过 <code>JDK8</code> 中的 <code>Optional</code> 的话, 那应该就很熟悉了~答案就是 <code>Option</code>.</p><p><code>Optional</code> 在 <code>Java</code> 中出现的太晚了, 很多人对这个特性是不怎么了解的, 迁移起来也很麻烦, 普遍还是使用空指针和捕获空指针异常来处理.</p><p>而在 <code>Rust</code> 中 <code>Option</code> 遍布了各个角落, <code>Option</code> 只是一个简单的枚举, 所以我们直接说明下 <code>Rust</code> 中使用枚举处理空指针和异常错误的方法.</p><h2 id=枚举>枚举</h2><h3 id=option>Option</h3><p><code>Option</code> 只是一个简单的枚举类型, 但是在 <code>Rust</code> 中枚举是很强大的.</p><p><code>Option</code> 的签名是</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nb>Option</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>None</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Some</span><span class=p>(</span><span class=n>T</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>它是这么使用的:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Option</span>::<span class=nb>Some</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Val is: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;No val&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在 <code>Rust</code> 中对于枚举的所有类型都强制遍历处理, 当然也可以用 <code>_</code> 来忽略掉不需要的部分, 所有我们不确定是否有值的地方都需要用 <code>Option</code> 来表示.</p><h3 id=result>Result</h3><p><code>Rust</code> 中也是用枚举来处理异常错误.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>net</span>::<span class=n>TcpStream</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>tcp_stream</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TcpStream</span>::<span class=n>connect</span><span class=p>(</span><span class=s>&#34;127.0.0.1:8000&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>tcp_stream</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Ok</span><span class=p>(</span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;success&#34;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Err</span><span class=p>(</span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>e</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>不需要捕获异常, 要知道 <code>Java</code> 中捕获异常是很耗费性能的, 使用枚举来处理空指针和异常错误是不是很优雅~</p><p>除了使用模式匹配外, 我们还可以使用 <code>if let</code> , 如下:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>net</span>::<span class=n>TcpStream</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>tcp_stream</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TcpStream</span>::<span class=n>connect</span><span class=p>(</span><span class=s>&#34;127.0.0.1:8000&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tcp_stream</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;success&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;error&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>同样类似的还有 <code>while let</code> .</p><h2 id=summary>Summary</h2><p>上述差不多说明了一些为什么我选择学 <code>Rust</code> 的理由, 当然还有很多其它的, 我所述并不足以解释 <code>Rust</code> 在最受程序员欢迎的语言调查中占据榜一.</p><p>我在写 <code>C</code> 代码的时候, 总会纠结该不该释放内存, 有没有野指针的可能. 也烦恼与标准库不够好用, 各平台头文件不够统一, 没法编写多平台通用的代码.</p><p>同样的, 在写 <code>Java</code> 的时候又会感觉有些啰嗦, 很多写法不够简洁.</p><p>而 <code>Rust</code> 的话, 标准库足够好用, 是否内存安全有编译器提醒, 而且写起来有很多语法糖比 <code>Java</code> 要小巧很多, 也只有很小的运行时, 没有垃圾回收, 可以直接打包成二进制文件运行. 性能与 <code>C</code> 是差不多的.</p><p>不过说来我学 <code>Rust</code> 还有一个原因是因为它够难, 而且没什么历史包袱, 比较有挑战. <code>C++</code> 的历史包袱换个词也可以说是经验积累, 不过我个人觉得有些太过厚重, 有些难啃吧.</p><p>本文浅尝辄止, 简单说明了一些 <code>Rust</code> 的特性. 这些特性差不多都是众多程序员在编写 <code>C/C++</code> 程序中总结出来的类似于最佳实践之类的东西. 所以本文也大量对比了 <code>Rust</code> 和 <code>C</code> , 并且学习 <code>Rust</code> 也是离不开 <code>C</code> 的, 其中存在了 <code>unsafe</code> 这样的东西. 不了解 <code>C</code> 的话是没法写 <code>unsafe</code> 部分的, 当然这部分大部分程序员也不怎么会接触到.</p><p>同时 <code>Rust</code> 作为系统级语言, 与 <code>C</code> 也有着非常友好的交互性, 很容易使用的 <code>FFI</code> , 不管是为了从 <code>C</code> 逐步切换到 <code>Rust</code> , 还是为了牺牲点安全提高灵活性的目的而使用 <code>FFI</code> , 这都算是一个亮点了. 毕竟 <code>C</code> 在各个领域都算是不可或缺的基本编程语言了.</p></section><footer class=article-footer><section class=article-tags><a href=/tags/basic/>Basic</a>
<a href=/tags/rust/>Rust</a></section></footer></article><footer class=site-footer><section class=copyright>&copy;
2022 Rabbit hole</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>