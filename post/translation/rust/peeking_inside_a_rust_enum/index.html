<!doctype html><html lang dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="本译文译自 Peeking inside a Rust enum
前言 在我最近 Rust Q&amp;amp;A twitch 频道里, 有些人提出了一个看起来简单的问题: 为什么 small string 类型, 像 SmartString or SmolStr 和 String 有着一样的大小, 但是 small vec 类型, 像 SmallVec 却要比 Vec 大?
我知道我使用了简单作为形容词, 但是事实上要了解这个问题, 我们需要一些背景知识
译者: 亿点点&amp;hellip;
这个问题到底是什么? 我最近谈到 Rust small string crates.
被这些 crates 导出的类型可以避免多次内存分配, 并且降低内存使用量. 让我们看一个 smartstring 的代码作为例子.
use smartstring::{Compact, SmartString}; use std::mem::size_of_val; fn main() { let smart = SmartString::&amp;lt;Compact&amp;gt;::from(&amp;#34;hello world&amp;#34;); dbg!(size_of_val(&amp;amp;smart)); let stand = String::from(&amp;#34;hello world&amp;#34;); dbg!"><title>深入Rust枚举</title><link rel=canonical href=/post/translation/rust/peeking_inside_a_rust_enum/><link rel=stylesheet href=/scss/style.min.ac77dcf8b111b51da39a92990f431923f210f3876d85798a2125667f96dc33a4.css><meta property="og:title" content="深入Rust枚举"><meta property="og:description" content="本译文译自 Peeking inside a Rust enum
前言 在我最近 Rust Q&amp;amp;A twitch 频道里, 有些人提出了一个看起来简单的问题: 为什么 small string 类型, 像 SmartString or SmolStr 和 String 有着一样的大小, 但是 small vec 类型, 像 SmallVec 却要比 Vec 大?
我知道我使用了简单作为形容词, 但是事实上要了解这个问题, 我们需要一些背景知识
译者: 亿点点&amp;hellip;
这个问题到底是什么? 我最近谈到 Rust small string crates.
被这些 crates 导出的类型可以避免多次内存分配, 并且降低内存使用量. 让我们看一个 smartstring 的代码作为例子.
use smartstring::{Compact, SmartString}; use std::mem::size_of_val; fn main() { let smart = SmartString::&amp;lt;Compact&amp;gt;::from(&amp;#34;hello world&amp;#34;); dbg!(size_of_val(&amp;amp;smart)); let stand = String::from(&amp;#34;hello world&amp;#34;); dbg!"><meta property="og:url" content="/post/translation/rust/peeking_inside_a_rust_enum/"><meta property="og:site_name" content><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="Translation"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Enum"><meta property="article:published_time" content="2021-01-13T11:00:00+08:00"><meta property="article:modified_time" content="2021-01-13T15:00:00+08:00"><meta property="og:image" content="/post/translation/rust/peeking_inside_a_rust_enum/cover.png"><meta name=twitter:title content="深入Rust枚举"><meta name=twitter:description content="本译文译自 Peeking inside a Rust enum
前言 在我最近 Rust Q&amp;amp;A twitch 频道里, 有些人提出了一个看起来简单的问题: 为什么 small string 类型, 像 SmartString or SmolStr 和 String 有着一样的大小, 但是 small vec 类型, 像 SmallVec 却要比 Vec 大?
我知道我使用了简单作为形容词, 但是事实上要了解这个问题, 我们需要一些背景知识
译者: 亿点点&amp;hellip;
这个问题到底是什么? 我最近谈到 Rust small string crates.
被这些 crates 导出的类型可以避免多次内存分配, 并且降低内存使用量. 让我们看一个 smartstring 的代码作为例子.
use smartstring::{Compact, SmartString}; use std::mem::size_of_val; fn main() { let smart = SmartString::&amp;lt;Compact&amp;gt;::from(&amp;#34;hello world&amp;#34;); dbg!(size_of_val(&amp;amp;smart)); let stand = String::from(&amp;#34;hello world&amp;#34;); dbg!"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/post/translation/rust/peeking_inside_a_rust_enum/cover.png"><link rel="shortcut icon" href=/favicon.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hubab1a6f26c99bd4005799835b3b49dcb_56897_300x0_resize_box_3.png width=300 height=321 class=site-logo loading=lazy alt=Avatar></a>
<span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/></a></h1><h2 class=site-description>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</h2></div></header><ol class=menu id=main-menu><li><a href=/page/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About</span></a></li><li><a href=/page/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/page/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/post/translation/rust/peeking_inside_a_rust_enum/><img src=/post/translation/rust/peeking_inside_a_rust_enum/cover_huf0a0302560a2de312014d03b723c5fe2_142416_800x0_resize_box_3.png srcset="/post/translation/rust/peeking_inside_a_rust_enum/cover_huf0a0302560a2de312014d03b723c5fe2_142416_800x0_resize_box_3.png 800w, /post/translation/rust/peeking_inside_a_rust_enum/cover_huf0a0302560a2de312014d03b723c5fe2_142416_1600x0_resize_box_3.png 1600w" width=800 height=435 loading=lazy alt="Featured image of post 深入Rust枚举"></a></div><div class=article-details><header class=article-category><a href=/categories/rust/>Rust</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/translation/rust/peeking_inside_a_rust_enum/>深入Rust枚举</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Jan 13, 2021</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>23 minute read</time></div></footer></div></header><section class=article-content><blockquote><p>本译文译自 <a class=link href=https://fasterthanli.me/articles/peeking-inside-a-rust-enum target=_blank rel=noopener>Peeking inside a Rust enum</a></p></blockquote><hr><h1 id=前言>前言</h1><p>在我最近 <code>Rust Q&A</code> <code>twitch</code> 频道里, 有些人提出了一个看起来简单的问题: 为什么 <code>small string</code> 类型, 像 <code>SmartString</code> or <code>SmolStr</code> 和 <code>String</code> 有着一样的大小, 但是 <code>small vec</code> 类型, 像 <code>SmallVec</code> 却要比 <code>Vec</code> 大?</p><p>我知道我使用了简单作为形容词, 但是事实上要了解这个问题, 我们需要一些背景知识</p><blockquote><p>译者: 亿点点&mldr;</p></blockquote><h2 id=这个问题到底是什么>这个问题到底是什么?</h2><p>我最近谈到 <code>Rust</code> <a class=link href=https://fasterthanli.me/articles/small-strings-in-rust target=_blank rel=noopener>small string crates</a>.</p><p>被这些 <code>crates</code> 导出的类型可以避免多次内存分配, 并且降低内存使用量. 让我们看一个 <a class=link href=https://lib.rs/crates/smartstring target=_blank rel=noopener>smartstring</a> 的代码作为例子.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> smartstring::{Compact, SmartString};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::mem::size_of_val;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> smart <span style=color:#f92672>=</span> SmartString::<span style=color:#f92672>&lt;</span>Compact<span style=color:#f92672>&gt;</span>::from(<span style=color:#e6db74>&#34;hello world&#34;</span>);
</span></span><span style=display:flex><span>    dbg!(size_of_val(<span style=color:#f92672>&amp;</span>smart));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stand <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello world&#34;</span>);
</span></span><span style=display:flex><span>    dbg!(size_of_val(<span style=color:#f92672>&amp;</span>stand));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:6<span style=color:#f92672>]</span> size_of_val<span style=color:#f92672>(</span>&amp;smart<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>24</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:9<span style=color:#f92672>]</span> size_of_val<span style=color:#f92672>(</span>&amp;stand<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>24</span>
</span></span></code></pre></div><p>正如你看到的, 同样也是最初的问题描述的那样, 这两个类型的大小是相同的.</p><p>是的, 这当然不是一个完整的故事, 在这个特别的例子中, <code>smart</code> 以 <code>inline</code> 的方式存储它的值(在栈上), 而标准库将值存储在堆上:</p><p>如果我们想知道每个类型到底总共使用了多少内存, 我们可以这样做:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>let</span> smart <span style=color:#f92672>=</span> SmartString::<span style=color:#f92672>&lt;</span>Compact<span style=color:#f92672>&gt;</span>::from(<span style=color:#e6db74>&#34;hello world&#34;</span>);
</span></span><span style=display:flex><span>    dbg!(size_of_val(<span style=color:#f92672>&amp;</span>smart));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stand <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello world&#34;</span>);
</span></span><span style=display:flex><span>    dbg!(size_of_val(<span style=color:#f92672>&amp;</span>stand) <span style=color:#f92672>+</span> stand.capacity());
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:6<span style=color:#f92672>]</span> size_of_val<span style=color:#f92672>(</span>&amp;smart<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>24</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:9<span style=color:#f92672>]</span> size_of_val<span style=color:#f92672>(</span>&amp;stand<span style=color:#f92672>)</span> + stand.capacity<span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>35</span>
</span></span></code></pre></div><p>典型的, 在 <code>Linux 64-bit</code> 系统中栈和堆在虚拟地址中的空间相差很远, 这意味着我们如果打印字符串的元数据的地址和内容的地址, 我们就可以看到:</p><ul><li><code>SmartString</code> 的元数据和内容在相邻的位置.</li><li><code>String</code> 的元数据和内容相距很远.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> smartstring::{Compact, SmartString};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> smart <span style=color:#f92672>=</span> SmartString::<span style=color:#f92672>&lt;</span>Compact<span style=color:#f92672>&gt;</span>::from(<span style=color:#e6db74>&#34;hello world&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> smart_meta <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>smart <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> _;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> smart_data <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>smart.as_bytes()[<span style=color:#ae81ff>0</span>] <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> _;
</span></span><span style=display:flex><span>    dbg!((smart_meta, smart_data));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stand <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello world&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stand_meta <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>stand <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> _;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stand_data <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>stand.as_bytes()[<span style=color:#ae81ff>0</span>] <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> _;
</span></span><span style=display:flex><span>    dbg!((stand_meta, stand_data));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:7<span style=color:#f92672>]</span> <span style=color:#f92672>(</span>smart_meta, smart_data<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>    0x00007ffce4cf4728,
</span></span><span style=display:flex><span>    0x00007ffce4cf4729,
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:12<span style=color:#f92672>]</span> <span style=color:#f92672>(</span>stand_meta, stand_data<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>    0x00007ffce4cf47f8,
</span></span><span style=display:flex><span>    0x0000555f87686a60,
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span></code></pre></div><p>不! 只有在小于24字节的时候是存储在栈上的, 就和 <code>String</code> 一样. 我们用稍微长一点的字符串来看看.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> smartstring::{Compact, SmartString};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Turns out you can blame your tools *and* be a good craftsperson. Who knew?&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> smart <span style=color:#f92672>=</span> SmartString::<span style=color:#f92672>&lt;</span>Compact<span style=color:#f92672>&gt;</span>::from(input);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> smart_meta <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>smart <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> _;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> smart_data <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>smart.as_bytes()[<span style=color:#ae81ff>0</span>] <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> _;
</span></span><span style=display:flex><span>    dbg!((smart_meta, smart_data));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stand <span style=color:#f92672>=</span> String::from(input);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stand_meta <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>stand <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> _;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stand_data <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>stand.as_bytes()[<span style=color:#ae81ff>0</span>] <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> _;
</span></span><span style=display:flex><span>    dbg!((stand_meta, stand_data));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:9<span style=color:#f92672>]</span> <span style=color:#f92672>(</span>smart_meta, smart_data<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>    0x00007ffd460d0268,
</span></span><span style=display:flex><span>    0x0000555f4636ca30,
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:14<span style=color:#f92672>]</span> <span style=color:#f92672>(</span>stand_meta, stand_data<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>    0x00007ffd460d0338,
</span></span><span style=display:flex><span>    0x0000555f4636cac0,
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span></code></pre></div><p>&mldr;然后我们就可以看到这两个类型的内容现在都放在堆上了.</p><h2 id=一个单词-多种意义>一个单词, 多种意义</h2><p>如果你有着 <code>C/C++/Java/C#</code> 的语言背景, 一个 <code>enum</code> 仅仅意味着一个 <code>Integer</code> 类型, 只是它的值有着自己的意义.</p><p>让我们看一个 <code>C</code> 的例子:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> Drink {
</span></span><span style=display:flex><span>    Water,
</span></span><span style=display:flex><span>    Soda,
</span></span><span style=display:flex><span>    Juice,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>enum</span> Drink dri <span style=color:#f92672>=</span> Soda;
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;dri = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, dri);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;sizeof(dri) = %ld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#66d9ef>sizeof</span>(dri));
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;sizeof(int) = %ld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里, 我们声明了一个枚举类型 <code>enum Drink</code>, 有三个变体, 不过仅仅是从0开始的数字, 所以我们有 <code>Water = 0</code>, <code>Soda = 1</code>, <code>Juice = 2</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ clang -Wall main.c -o main <span style=color:#f92672>&amp;&amp;</span> ./main
</span></span><span style=display:flex><span>dri <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>sizeof<span style=color:#f92672>(</span>dri<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>sizeof<span style=color:#f92672>(</span>int<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
</span></span></code></pre></div><p>然而我不是很喜欢这个代码, 我不想要额外的限定词, 并且想要我的变体有着自己的命名空间, 但在 <code>C</code> 里面我们需要自己做这些事:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// this could also be done in two separate declarations
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> Drink {
</span></span><span style=display:flex><span>    Drink_Water,
</span></span><span style=display:flex><span>    Drink_Soda,
</span></span><span style=display:flex><span>    Drink_Juice,
</span></span><span style=display:flex><span>} Drink;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Drink dri <span style=color:#f92672>=</span> Drink_Soda;
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;dri = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, dri);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;sizeof(dri) = %ld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#66d9ef>sizeof</span>(dri));
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;sizeof(int) = %ld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Ahhh, 好多了. 但是这里仍然有其它的东西我不是特别喜欢, 像是 <code>C</code> 的 <code>switch</code>. 下面的代码是错误的:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> Drink {
</span></span><span style=display:flex><span>    Drink_Water,
</span></span><span style=display:flex><span>    Drink_Soda,
</span></span><span style=display:flex><span>    Drink_Juice,
</span></span><span style=display:flex><span>} Drink;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print_drink</span>(Drink dri) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (dri) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> Drink_Water:
</span></span><span style=display:flex><span>            printf(<span style=color:#e6db74>&#34;It&#39;s water!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> Drink_Soda:
</span></span><span style=display:flex><span>            printf(<span style=color:#e6db74>&#34;It&#39;s soda!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> Drink_Juice:
</span></span><span style=display:flex><span>            printf(<span style=color:#e6db74>&#34;It&#39;s juice!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    print_drink(Drink_Soda);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>正确的代码是在每个 <code>case</code> 语句的结尾都使用 <code>break</code>. 这是刚起步的开发人员很早就应该了解的事情之一.</p><p>即使我们修复了 <code>switch</code> 的问题, 还有件我不喜欢 <code>C</code> 枚举的事情, 那就是没什么可以阻止我传递一个无意义的值:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> Drink {
</span></span><span style=display:flex><span>    Drink_Water,
</span></span><span style=display:flex><span>    Drink_Soda,
</span></span><span style=display:flex><span>    Drink_Juice,
</span></span><span style=display:flex><span>} Drink;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print_drink</span>(Drink dri) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (dri) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> Drink_Water:
</span></span><span style=display:flex><span>            printf(<span style=color:#e6db74>&#34;It&#39;s water!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> Drink_Soda:
</span></span><span style=display:flex><span>            printf(<span style=color:#e6db74>&#34;It&#39;s soda!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> Drink_Juice:
</span></span><span style=display:flex><span>            printf(<span style=color:#e6db74>&#34;It&#39;s juice!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    print_drink(<span style=color:#ae81ff>47</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ clang -Wall main.c -o main <span style=color:#f92672>&amp;&amp;</span> ./main
</span></span></code></pre></div><p>现在, 如果我们看看 <code>Rust</code> 的枚举&mldr; 这是个完全不同的事情.</p><p>让我们尽量写一个相同的程序.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::mem::size_of_val;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Drink</span> {
</span></span><span style=display:flex><span>    Water,
</span></span><span style=display:flex><span>    Soda,
</span></span><span style=display:flex><span>    Juice,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> dri <span style=color:#f92672>=</span> Drink::Water;
</span></span><span style=display:flex><span>    dbg!(size_of_val(<span style=color:#f92672>&amp;</span>dri));
</span></span><span style=display:flex><span>    dbg!(dri <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span>warning: variant is never constructed: <span style=color:#e6db74>`</span>Soda<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span> --&gt; src/main.rs:5:5
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span><span style=color:#ae81ff>5</span> |     Soda,
</span></span><span style=display:flex><span>  |     ^^^^
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span>  <span style=color:#f92672>=</span> note: <span style=color:#e6db74>`</span><span style=color:#75715e>#[warn(dead_code)]` on by default</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>warning: variant is never constructed: <span style=color:#e6db74>`</span>Juice<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span> --&gt; src/main.rs:6:5
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span><span style=color:#ae81ff>6</span> |     Juice,
</span></span><span style=display:flex><span>  |     ^^^^^
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>warning: <span style=color:#ae81ff>2</span> warnings emitted
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:11<span style=color:#f92672>]</span> size_of_val<span style=color:#f92672>(</span>&amp;dri<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:12<span style=color:#f92672>]</span> dri as u32 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>那么我们明显地得到了什么好处呢?</p><p>对的, 但那并不是全部! 编译器警告我们有没有使用的变体, 并且我们可以简单地给这个枚举派生一个 <code>Debug</code> trait 的实现:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Drink</span> {
</span></span><span style=display:flex><span>    Water,
</span></span><span style=display:flex><span>    Soda,
</span></span><span style=display:flex><span>    Juice,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    print_drink(<span style=color:#f92672>&amp;</span>Drink::Water);
</span></span><span style=display:flex><span>    print_drink(<span style=color:#f92672>&amp;</span>Drink::Juice);
</span></span><span style=display:flex><span>    print_drink(<span style=color:#f92672>&amp;</span>Drink::Soda);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_drink</span>(dri: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Drink</span>) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;{:?}&#34;</span>, dri);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span>Water
</span></span><span style=display:flex><span>Juice
</span></span><span style=display:flex><span>Soda
</span></span></code></pre></div><p>&mldr;并且假如我们不那么做, 我们也能使用 <code>match</code> 而不是 <code>switch</code>, <code>match</code> 会检查是否匹配了枚举的所有变体, 举个例子, 下面的代码不能通过编译:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_drink</span>(dri: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Drink</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> dri {
</span></span><span style=display:flex><span>        Drink::Water <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;it&#39;s water!&#34;</span>),
</span></span><span style=display:flex><span>        Drink::Soda <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;it&#39;s soda!&#34;</span>),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span>error<span style=color:#f92672>[</span>E0004<span style=color:#f92672>]</span>: non-exhaustive patterns: <span style=color:#e6db74>`</span>&amp;Juice<span style=color:#e6db74>`</span> not covered
</span></span><span style=display:flex><span>  --&gt; src/main.rs:15:11
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>  | / enum Drink <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>  | |     Water,
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>  | |     Soda,
</span></span><span style=display:flex><span><span style=color:#ae81ff>5</span>  | |     Juice,
</span></span><span style=display:flex><span>   | |     ----- not covered
</span></span><span style=display:flex><span><span style=color:#ae81ff>6</span>  | | <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>   | |_- <span style=color:#e6db74>`</span>Drink<span style=color:#e6db74>`</span> defined here
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#ae81ff>15</span> |       match dri <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>   |             ^^^ pattern <span style=color:#e6db74>`</span>&amp;Juice<span style=color:#e6db74>`</span> not covered
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>   <span style=color:#f92672>=</span> help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
</span></span><span style=display:flex><span>   <span style=color:#f92672>=</span> note: the matched value is of type <span style=color:#e6db74>`</span>&amp;Drink<span style=color:#e6db74>`</span>
</span></span></code></pre></div><p>编译器给出了两种可能的方法来修复这个问题, 或是添加一个通配符:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_drink</span>(dri: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Drink</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> dri {
</span></span><span style=display:flex><span>        Drink::Water <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;it&#39;s water!&#34;</span>),
</span></span><span style=display:flex><span>        Drink::Soda <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;it&#39;s soda!&#34;</span>),
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;it&#39;s something we don&#39;t know about!&#34;</span>),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>或者是覆盖到所有的情况:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_drink</span>(dri: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Drink</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> dri {
</span></span><span style=display:flex><span>        Drink::Water <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;it&#39;s water!&#34;</span>),
</span></span><span style=display:flex><span>        Drink::Soda <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;it&#39;s soda!&#34;</span>),
</span></span><span style=display:flex><span>        Drink::Juice <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;it&#39;s juice!&#34;</span>),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>讲到 <code>match</code>, 它也是一个表达式, 所以我们也可以这么做:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_drink</span>(dri: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Drink</span>) {
</span></span><span style=display:flex><span>    println!(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;{}&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> dri {
</span></span><span style=display:flex><span>            Drink::Water <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;it&#39;s water!&#34;</span>,
</span></span><span style=display:flex><span>            Drink::Soda <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;it&#39;s soda!&#34;</span>,
</span></span><span style=display:flex><span>            Drink::Juice <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;it&#39;s juice!&#34;</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>尽管就我个人而言, 我可能更倾向于这样写:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_drink</span>(dri: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Drink</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> dri {
</span></span><span style=display:flex><span>        Drink::Water <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;water&#34;</span>,
</span></span><span style=display:flex><span>        Drink::Soda <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;soda&#34;</span>,
</span></span><span style=display:flex><span>        Drink::Juice <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;juice&#34;</span>,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;it&#39;s {}!&#34;</span>, name)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>让我们想想, 我们还抱怨了 <code>C</code> 枚举的什么地方?</p><p>对! 让我们试试:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    print_drink(<span style=color:#f92672>&amp;</span>Drink::Water);
</span></span><span style=display:flex><span>    print_drink(<span style=color:#f92672>&amp;</span>Drink::Juice);
</span></span><span style=display:flex><span>    print_drink(<span style=color:#f92672>&amp;</span>Drink::Soda);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> val: <span style=color:#a6e22e>Drink</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span> <span style=color:#66d9ef>as</span> Drink;
</span></span><span style=display:flex><span>    print_drink(<span style=color:#f92672>&amp;</span>val);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span>error<span style=color:#f92672>[</span>E0605<span style=color:#f92672>]</span>: non-primitive cast: <span style=color:#e6db74>`</span>i32<span style=color:#e6db74>`</span> as <span style=color:#e6db74>`</span>Drink<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>  --&gt; src/main.rs:13:22
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span><span style=color:#ae81ff>13</span> |     let val: Drink <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span> as Drink;
</span></span><span style=display:flex><span>   |                      ^^^^^^^^^^
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>   <span style=color:#f92672>=</span> note: an <span style=color:#e6db74>`</span>as<span style=color:#e6db74>`</span> expression can only be used to convert between primitive types. Consider using the <span style=color:#e6db74>`</span>From<span style=color:#e6db74>`</span> traitt
</span></span></code></pre></div><p>Ah, 这看起来并不能工作! 然而在某些情形中我们可能需要这么做, 我们可以解析一个二进制格式, 并且已经确保检查这个数字类型的值在这个枚举中是有意义的 - 那么我们可以使用 <code>transmute</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[allow(dead_code)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Drink</span> {
</span></span><span style=display:flex><span>    Water,
</span></span><span style=display:flex><span>    Soda,
</span></span><span style=display:flex><span>    Juice,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> juice_from_binary_format <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> val: <span style=color:#a6e22e>Drink</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { std::mem::transmute(juice_from_binary_format <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>) };
</span></span><span style=display:flex><span>    print_drink(<span style=color:#f92672>&amp;</span>val);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_drink</span>(dri: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Drink</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> dri {
</span></span><span style=display:flex><span>        Drink::Water <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;water&#34;</span>,
</span></span><span style=display:flex><span>        Drink::Soda <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;soda&#34;</span>,
</span></span><span style=display:flex><span>        Drink::Juice <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;juice&#34;</span>,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;it&#39;s {}!&#34;</span>, name)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span>it<span style=color:#ae81ff>\&#39;</span>s juice!
</span></span></code></pre></div><p>当前, 通常我们希望给这个不安全操作提供一个安全的接口:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::convert::{TryFrom, TryInto};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[allow(dead_code)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Drink</span> {
</span></span><span style=display:flex><span>    Water,
</span></span><span style=display:flex><span>    Soda,
</span></span><span style=display:flex><span>    Juice,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> TryFrom<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Drink {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Error</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;&#39;</span>static <span style=color:#66d9ef>str</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_from</span>(x: <span style=color:#66d9ef>i32</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Self, Self::Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> x {
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>=&gt;</span> Ok(<span style=color:#66d9ef>unsafe</span> { std::mem::transmute(x <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>) }),
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> Err(<span style=color:#e6db74>&#34;invalid Drink value&#34;</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> juice_from_binary_format: <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> val: <span style=color:#a6e22e>Drink</span> <span style=color:#f92672>=</span> juice_from_binary_format.try_into().unwrap();
</span></span><span style=display:flex><span>    print_drink(<span style=color:#f92672>&amp;</span>val);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> invalid_value: <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> val: <span style=color:#a6e22e>Drink</span> <span style=color:#f92672>=</span> invalid_value.try_into().unwrap();
</span></span><span style=display:flex><span>    print_drink(<span style=color:#f92672>&amp;</span>val);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span>it<span style=color:#ae81ff>\&#39;</span>s juice!
</span></span><span style=display:flex><span>thread <span style=color:#e6db74>&#39;main&#39;</span> panicked at <span style=color:#e6db74>&#39;called `Result::unwrap()` on an `Err` value: &#34;invalid Drink value&#34;&#39;</span>, src/main.rs:27:22
</span></span><span style=display:flex><span>note: run with <span style=color:#e6db74>`</span>RUST_BACKTRACE<span style=color:#f92672>=</span>1<span style=color:#e6db74>`</span> environment variable to display a backtrace
</span></span></code></pre></div><p>并且我们的快乐还并不止步于此.</p><p>还记得我们之前打印我们的枚举大小么? 让我们来 <a class=link href=https://en.wikipedia.org/wiki/Memory_refresh target=_blank rel=noopener>refresh out memory</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::mem::size_of;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[allow(dead_code)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Drink</span> {
</span></span><span style=display:flex><span>    Water,
</span></span><span style=display:flex><span>    Soda,
</span></span><span style=display:flex><span>    Juice,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    dbg!(size_of::<span style=color:#f92672>&lt;</span>Drink<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:11<span style=color:#f92672>]</span> size_of::&lt;Drink&gt;<span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>单位是字节, 所以这里显示我们的枚举只有一个字节.</p><p>让我们与 <code>C</code> 的对比下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> Drink {
</span></span><span style=display:flex><span>    Drink_Water,
</span></span><span style=display:flex><span>    Drink_Soda,
</span></span><span style=display:flex><span>    Drink_Juice,
</span></span><span style=display:flex><span>} Drink;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;sizeof(Drink) = %ld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#66d9ef>sizeof</span>(Drink));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ clang -Wall main.c -o main <span style=color:#f92672>&amp;&amp;</span> ./main
</span></span><span style=display:flex><span>sizeof<span style=color:#f92672>(</span>Drink<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
</span></span></code></pre></div><p>这里枚举有足足4个字节, 所以我们可以近似地说 <code>Rust</code> 的枚举是 <code>u8</code>, <code>C</code> 枚举是 <code>u32</code>.</p><p>如果 <code>Rust</code> 的枚举超过256个变体呢?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::mem::size_of;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[allow(dead_code)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Drink</span> {
</span></span><span style=display:flex><span>    Variant0,
</span></span><span style=display:flex><span>    Variant1,
</span></span><span style=display:flex><span>    Variant2,
</span></span><span style=display:flex><span>    Variant3,
</span></span><span style=display:flex><span>    Variant4,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// (etc.)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Variant252,
</span></span><span style=display:flex><span>    Variant253,
</span></span><span style=display:flex><span>    Variant254,
</span></span><span style=display:flex><span>    Variant255,
</span></span><span style=display:flex><span>    Variant256,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    dbg!(size_of::<span style=color:#f92672>&lt;</span>Drink<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>译者: <a class=link href=https://en.wikipedia.org/wiki/Off-by-one_error#Fencepost_error target=_blank rel=noopener>counting the fences, when you should be counting the posts.</a></p></blockquote><p>不管怎样, 我们先看看现在的枚举大小?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:265<span style=color:#f92672>]</span> size_of::&lt;Drink&gt;<span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>2个字节! 看起来又像是 <code>u16</code>.</p><p>当然看起来像并不是一个专业术语 - 专业术语应该是 &ldquo;representation&rdquo;. 一个 <code>Rust</code> 枚举是对特定整数类型的抽象.</p><p>让我们看看我们原来的 <code>Drink</code>:</p><p>概念上, <code>Drink</code> 只有三个有意义的值, 但是它的表现是一个 <code>u8</code>, 能持有256个不同的值. 这就是你为什么总是能把 <code>Drink</code> 转为 <code>u8</code>, 但是把 <code>u8</code> 转为 <code>Drink</code> 却是一个容易出错的操作.</p><p>对的! 潜在的 <code>Drink</code> 作为一个 <code>u8</code> 应该总是为0, 1或者2, 这被称为不变体(invariant). 如果我们破坏了这个不变体, 我们的代码就不是那么健壮了.</p><p>在 <code>Rust</code>, 破坏不变体需要使用 <code>unsafe</code> 代码:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::mem::transmute;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[allow(dead_code)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Drink</span> {
</span></span><span style=display:flex><span>    Water,
</span></span><span style=display:flex><span>    Soda,
</span></span><span style=display:flex><span>    Juice,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// woops! that&#39;s unsound.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> d: <span style=color:#a6e22e>Drink</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { transmute(<span style=color:#ae81ff>15_</span><span style=color:#66d9ef>u8</span>) };
</span></span><span style=display:flex><span>    dbg!(<span style=color:#f92672>&amp;</span>d);
</span></span><span style=display:flex><span>    dbg!(d <span style=color:#f92672>==</span> Drink::Juice);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:14<span style=color:#f92672>]</span> &amp;d <span style=color:#f92672>=</span> Juice
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:15<span style=color:#f92672>]</span> d <span style=color:#f92672>==</span> Drink::Juice <span style=color:#f92672>=</span> false
</span></span></code></pre></div><p>问题的关键在于不是所有的事情都可以交由计算机去做(意味着需要你自己去做), 可以使用 <code>Rust</code> 的模型检查. 因为种种原因, 你仍然需要 <code>unsafe</code> 代码.</p><p>这并不意味有着两种 <code>Rust</code>, 仅仅意味着不同的风险以及不同的可信任等级.</p><p>如果你相信 <code>Rust</code> 核心团队可以根除标准库中的不健全之处, 那么你甚至就可以让团队中的初级人员在此基础上编写受 <code>Rust</code> 安全保证的 <code>safe code</code>.</p><h2 id=rust枚举不止于此>Rust枚举不止于此</h2><p>Cool bear早先说 <code>SmartString</code> 有着买一送一的处理字符串的方式. Cool bear是对的!</p><p>让我们来自己做一个 <code>two-for-one</code> 的处理方式:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>UserID</span> {
</span></span><span style=display:flex><span>    Number(<span style=color:#66d9ef>u64</span>),
</span></span><span style=display:flex><span>    Text(String),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>UserID</code> 是一个聚合类型, 一个 <code>UserID</code> 的值可以是一个 <code>UserID::Number</code> 变体, 或是一个 <code>UserID::Text</code> 变体.如果我们想对它的内容做些操作, 我们需要用模式匹配:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_user_id</span>(id: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>UserID</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> id {
</span></span><span style=display:flex><span>        UserID::Number(n) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;user id number {}&#34;</span>, n);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        UserID::Text(s) <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;user id {}&#34;</span>, s),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>希望你对这个用法很熟悉, 我们在不久前刚提到过这个用法.</p><p>让我们进行一次打印操作:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    print_user_id(<span style=color:#f92672>&amp;</span>UserID::Number(<span style=color:#ae81ff>79</span>));
</span></span><span style=display:flex><span>    print_user_id(<span style=color:#f92672>&amp;</span>UserID::Text(<span style=color:#e6db74>&#34;fh99a73gbh8&#34;</span>.into()));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span>user id number <span style=color:#ae81ff>79</span>
</span></span><span style=display:flex><span>user id fh99a73gbh8
</span></span></code></pre></div><p>我们在这文章之前看到过另一个聚合类型, 然后我们实现 <code>TryInto</code>, 我们会返回 <code>Result&lt;T, E></code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> TryFrom<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Drink {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Error</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;&#39;</span>static <span style=color:#66d9ef>str</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_from</span>(x: <span style=color:#66d9ef>i32</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Self, Self::Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// omitted
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Result</code> 值是一个枚举, 它实际是这样定义的:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> Result<span style=color:#f92672>&lt;</span>T, E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Contains the success value
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    Ok(T),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Contains the error value
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    Err(E),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>让我们返回看我们的 <code>UserID</code> 枚举:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>UserID</span> {
</span></span><span style=display:flex><span>    Number(<span style=color:#66d9ef>u64</span>),
</span></span><span style=display:flex><span>    Text(String),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>它的大小是多少呢? 如果我们尝试在 <code>C</code> 里模拟实现一个 <code>Rust</code> 的枚举, 它将会看起来如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdint.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> UserIDKind {
</span></span><span style=display:flex><span>    UserIDKind_Number,
</span></span><span style=display:flex><span>    UserIDKind_Text,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> UserID {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>enum</span> UserIDKind kind;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint64_t</span> number;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>text;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>尽管我们只需要两个变体, 但我们需要三个属性, 以让我们知道我们现在处理的是哪一个变体.</p><p>举个例子, 在 <code>print_user_id</code>, 我们应该使用 <code>switch</code> 来处理我们使用的是 <code>Number</code> 变体还是 <code>Text</code> 变体:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print_user_id</span>(<span style=color:#66d9ef>struct</span> UserID<span style=color:#f92672>*</span> id) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (id<span style=color:#f92672>-&gt;</span>kind) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> UserIDKind_Number:
</span></span><span style=display:flex><span>            printf(<span style=color:#e6db74>&#34;user id number %lu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, id<span style=color:#f92672>-&gt;</span>number);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> UserIDKind_Text:
</span></span><span style=display:flex><span>            printf(<span style=color:#e6db74>&#34;user id %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, id<span style=color:#f92672>-&gt;</span>text);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>并且当我们初始化 <code>UserID</code> 结构体的时候, 我们仅需要初始化我们需要的属性, 并且设置它的 <code>kind</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> UserID a <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        .kind <span style=color:#f92672>=</span> UserIDKind_Number,
</span></span><span style=display:flex><span>        .number <span style=color:#f92672>=</span> <span style=color:#ae81ff>79</span>,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    print_user_id(<span style=color:#f92672>&amp;</span>a);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> UserID b <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        .kind <span style=color:#f92672>=</span> UserIDKind_Text,
</span></span><span style=display:flex><span>        .text <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;fh99a73gbh8&#34;</span>,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    print_user_id(<span style=color:#f92672>&amp;</span>b);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这是可以工作的:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ clang -Wall main.c -o main <span style=color:#f92672>&amp;&amp;</span> ./main
</span></span><span style=display:flex><span>user id number <span style=color:#ae81ff>79</span>
</span></span><span style=display:flex><span>user id fh99a73gbh8
</span></span></code></pre></div><p>但这并不理想, 这并没有像 <code>Rust</code> 那样的安全保证, 我们无法阻止你创建一个 <code>Text</code> 而 <code>kind</code> 是一个 <code>Number</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> UserID woops <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        .kind <span style=color:#f92672>=</span> UserIDKind_Number,
</span></span><span style=display:flex><span>        .text <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;woops&#34;</span>,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    print_user_id(<span style=color:#f92672>&amp;</span>woops);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ clang -Wall main.c -o main <span style=color:#f92672>&amp;&amp;</span> ./main
</span></span><span style=display:flex><span>user id number <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>我们实现了一个不完善的抽象 - 我们可以直接访问它的底层表示, 并且以不合理的方式操作它.</p><p>举个例子, 如果我们的 <code>UserID</code> 是使用 <code>malloc</code> 在堆上分配的并且也没有清零, 那会发生什么?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> UserID <span style=color:#f92672>*</span>woops <span style=color:#f92672>=</span> malloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> UserID));
</span></span><span style=display:flex><span>    woops<span style=color:#f92672>-&gt;</span>kind <span style=color:#f92672>=</span> UserIDKind_Text;
</span></span><span style=display:flex><span>    woops<span style=color:#f92672>-&gt;</span>number <span style=color:#f92672>=</span> <span style=color:#ae81ff>79</span>;
</span></span><span style=display:flex><span>    print_user_id(woops);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在debug模式编译下, 它不会很糟糕:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ clang -Wall main.c -o main <span style=color:#f92672>&amp;&amp;</span> ./main
</span></span><span style=display:flex><span>user id <span style=color:#f92672>(</span>null<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>然而在release模式编译下, 随着优化的打开, 将会发生很有趣的现象:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ clang -O3 -Wall main.c -o main <span style=color:#f92672>&amp;&amp;</span> ./main
</span></span><span style=display:flex><span>user id <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>$ clang -O3 -Wall main.c -o main <span style=color:#f92672>&amp;&amp;</span> ./main
</span></span><span style=display:flex><span>user id 
</span></span><span style=display:flex><span>$ clang -O3 -Wall main.c -o main <span style=color:#f92672>&amp;&amp;</span> ./main
</span></span><span style=display:flex><span>user id m
</span></span></code></pre></div><p>从哪里来的? 谁知道呢. 但是它没有导致段错误 - 这意味着它从程序的其他部分读取数据. 在一个大型程序中, 那可能是用户的隐私数据, 而这个漏洞就可能被用来窃取隐私数据.</p><p>不过这并不是一篇讲 <code>C</code> 有多危险的文章,</p><p>&mldr;emmm, 让我们看看还有什么不好的地方.</p><p>首先让我们看看我们 <code>struct UserID</code> 的大小:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ clang -Wall main.c -o main <span style=color:#f92672>&amp;&amp;</span> ./main
</span></span><span style=display:flex><span>sizeof<span style=color:#f92672>(</span>struct UserID<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>24</span>
</span></span></code></pre></div><p>24字节. 这只是一个结构体, 所以我们可以自己计算出来:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;sizeof(struct UserID) = %ld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> UserID));
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%ld + %ld + %ld = %ld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>enum</span> UserIDKind), <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>uint64_t</span>), <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>enum</span> UserIDKind) <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>uint64_t</span>) <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ clang -Wall main.c -o main <span style=color:#f92672>&amp;&amp;</span> ./main
</span></span><span style=display:flex><span>sizeof<span style=color:#f92672>(</span>struct UserID<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>24</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span> + <span style=color:#ae81ff>8</span> + 8 <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>
</span></span></code></pre></div><p>Oh, woops. 我们哪里做错了?</p><p>淡定, 这是因为在 <code>kind</code> 和 <code>number</code> 之间有 <code>padding</code>, 以使我们的属性是64位对齐的(后面会详细说明).</p><p>这就是为什么我们的 <code>UserID</code> 结构体是3*8=24个字节.</p><p>当前, 我们可以命令编译器不要做对齐, 然后在计算一次:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>__attribute__</span>((packed)) UserID {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>enum</span> UserIDKind kind;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint64_t</span> number;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>text;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ clang -Wall main.c -o main <span style=color:#f92672>&amp;&amp;</span> ./main
</span></span><span style=display:flex><span>sizeof<span style=color:#f92672>(</span>struct UserID<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span> + <span style=color:#ae81ff>8</span> + 8 <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>
</span></span></code></pre></div><p>现在让我们看看 <code>Rust</code> 中 <code>UserID</code> 枚举的大小:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::mem::size_of;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[allow(dead_code)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>UserID</span> {
</span></span><span style=display:flex><span>    Number(<span style=color:#66d9ef>u64</span>),
</span></span><span style=display:flex><span>    Text(String),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    dbg!(size_of::<span style=color:#f92672>&lt;</span>UserID<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:10<span style=color:#f92672>]</span> size_of::&lt;UserID&gt;<span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>32</span>
</span></span></code></pre></div><p>Oh, uh, 这太大了. 太大了. 我不认为 <code>Rust</code> 的 <code>String</code> 类型只是一个单纯的指向空字符结尾的指针(c-style). 我认为 <a class=link href=https://fasterthanli.me/articles/working-with-strings-in-rust target=_blank rel=noopener>it&rsquo;s a little more involved</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::{mem::size_of, os::raw::c_char};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[allow(dead_code)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>UserID</span> {
</span></span><span style=display:flex><span>    Number(<span style=color:#66d9ef>u64</span>),
</span></span><span style=display:flex><span>    Text(<span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> c_char),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    dbg!(size_of::<span style=color:#f92672>&lt;</span>UserID<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:10<span style=color:#f92672>]</span> size_of::&lt;UserID&gt;<span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>
</span></span></code></pre></div><p>Ok, 这看起来合理多了. 并且比 <code>C</code> 版本要小很多. 这里是为什么呢?</p><p>首先, 这里必须有一个等同于上面写的 <code>C</code> 语言的 <code>kind</code> 一样作用的东西. 在 <code>Rust</code> 中, 它叫做 <code>discriminant</code>(判别符). 这是一个 &ldquo;tagged unions&rdquo; 中的 &ldquo;tag&rdquo;.</p><p>&mldr;&mldr;我猜它应该是通过重叠 <code>*const c_char</code> 和 <code>u64</code> 来节省空间, 因为它们只能有一个是有效的, 不能同时存在: 这也是为什么称他们为 &ldquo;disjoint union&rdquo;.</p><p>所以总共只有16个字节.</p><p>我们能做相同的事情在 <code>C</code> 里面吗? 这当然可以! <code>union</code> 关键字就是起着类似作用的. 这就像是一个结构体, 只是所有内容的内存地址是重叠的, 它的大小是它内部最大的那一个 (或多或少依然是需要考虑对齐的).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> UserID {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>enum</span> UserIDKind kind;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint64_t</span> number;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>text;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;sizeof(struct UserID) = %ld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> UserID));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ clang -Wall main.c -o main <span style=color:#f92672>&amp;&amp;</span> ./main
</span></span><span style=display:flex><span>sizeof<span style=color:#f92672>(</span>struct UserID<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>
</span></span></code></pre></div><p>我们得到了与 <code>Rust</code> 相同的结果.</p><p>进一步的, 我们可以把 <code>UserIDKind</code> 改成一个 <code>uint8_t</code>(在64位计算机, <code>clang 10</code>作为编译器的情况下它是4个字节):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> UserID {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> kind;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint64_t</span> number;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>text;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ clang -Wall main.c -o main <span style=color:#f92672>&amp;&amp;</span> ./main
</span></span><span style=display:flex><span>sizeof<span style=color:#f92672>(</span>struct UserID<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> 16;
</span></span></code></pre></div><p>Mhhhh好像没发生什么变化&mldr;</p><p>对的, 让我们再次 <code>packing</code> 我们的结构体:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>__attribute__</span>((packed)) UserID {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> kind;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint64_t</span> number;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>text;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ clang -Wall main.c -o main <span style=color:#f92672>&amp;&amp;</span> ./main
</span></span><span style=display:flex><span>sizeof<span style=color:#f92672>(</span>struct UserID<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>
</span></span></code></pre></div><p>只有9个字节了! 现在它压缩了.</p><p>我们可以在 <code>Rust</code> 中做类似的事情吗? <code>Rust</code> 默认是以属性做适应性对齐的, 如果我们有一个 <code>u8</code> and <code>u64</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span> {
</span></span><span style=display:flex><span>    bar: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>    baz: <span style=color:#66d9ef>u64</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    dbg!(size_of::<span style=color:#f92672>&lt;</span>Foo<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr;它增长到了16个字节</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:16<span style=color:#f92672>]</span> size_of::&lt;Foo&gt;<span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>
</span></span></code></pre></div><p>但是, 像 <code>C</code> 一样, 如果我们友好地要求, <code>Rust</code> 也可以 <code>pack</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[repr(packed)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span> {
</span></span><span style=display:flex><span>    bar: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>    baz: <span style=color:#66d9ef>u64</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:17<span style=color:#f92672>]</span> size_of::&lt;Foo&gt;<span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>
</span></span></code></pre></div><p>但是如果在枚举上呢?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[repr(packed)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>UserID</span> {
</span></span><span style=display:flex><span>    Number(<span style=color:#66d9ef>u64</span>),
</span></span><span style=display:flex><span>    Text(<span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> c_char),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span>error<span style=color:#f92672>[</span>E0517<span style=color:#f92672>]</span>: attribute should be applied to struct or union
</span></span><span style=display:flex><span> --&gt; src/main.rs:4:8
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span> |   <span style=color:#75715e>#[repr(packed)]</span>
</span></span><span style=display:flex><span>  |          ^^^^^^
</span></span><span style=display:flex><span><span style=color:#ae81ff>5</span> | / enum UserID <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>6</span> | |     Number<span style=color:#f92672>(</span>u64<span style=color:#f92672>)</span>,
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span> | |     Text<span style=color:#f92672>(</span>*const c_char<span style=color:#f92672>)</span>,
</span></span><span style=display:flex><span><span style=color:#ae81ff>8</span> | | <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  | |_- not a struct or union
</span></span></code></pre></div><p>我们不能 <code>pack</code>. 这之前已经 <a class=link href=https://github.com/rust-lang/rust/issues/42547 target=_blank rel=noopener>讨论</a> 过了, 也有 <a class=link href=https://github.com/rust-lang/rfcs/issues/1230 target=_blank rel=noopener>讨论其它奇异的枚举布局优化的方案</a>, 但是现在, 还不能那么做.</p><p>然而显然, <code>smartstring</code> 就是那么做的.</p><p>当一个 <code>SmartString</code> 存在堆里的时候(这是一个 <code>boxed</code> 变体), 它是24字节, 就像 <code>String</code> 一样.</p><p>但是如果我们尝试做一个我们自己的 <code>smartstring</code>, 使用 <code>Rust</code> 的枚举, 我们甚至无法接近它的大小:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::mem::size_of;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[allow(dead_code)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>SmartString</span> {
</span></span><span style=display:flex><span>    Boxed(String),
</span></span><span style=display:flex><span>    Inline([<span style=color:#66d9ef>u8</span>; <span style=color:#ae81ff>24</span>]),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    dbg!(size_of::<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>    dbg!(size_of::<span style=color:#f92672>&lt;</span>[<span style=color:#66d9ef>u8</span>; <span style=color:#ae81ff>24</span>]<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>    dbg!(size_of::<span style=color:#f92672>&lt;</span>SmartString<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:10<span style=color:#f92672>]</span> size_of::&lt;String&gt;<span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>24</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:11<span style=color:#f92672>]</span> size_of::&lt;<span style=color:#f92672>[</span>u8; 24<span style=color:#f92672>]</span>&gt;<span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>24</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:12<span style=color:#f92672>]</span> size_of::&lt;SmartString&gt;<span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>32</span>
</span></span></code></pre></div><p>这里有件事是我们可以做的, 既然 <code>Rust</code> 不允许我们打包它的枚举, 那我们就做一个自己的枚举.</p><h2 id=写一个自己的枚举>写一个自己的枚举</h2><p>首先, 我们不能使用 <a class=link href=https://doc.rust-lang.org/reference/items/unions.html target=_blank rel=noopener>Rust unions</a>, 因为它只支持 <code>Copy</code> 和非 <code>Drop</code> 类型.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::mem::size_of;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[allow(dead_code)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[repr(packed)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SmartString</span> {
</span></span><span style=display:flex><span>    discriminant: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>    data: [<span style=color:#66d9ef>u8</span>; <span style=color:#ae81ff>24</span>],
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    dbg!(size_of::<span style=color:#f92672>&lt;</span>SmartString<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:11<span style=color:#f92672>]</span> size_of::&lt;SmartString&gt;<span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>25</span>
</span></span></code></pre></div><p>看! 25个字节. 这是我们目前最好的预想了.</p><p>但是实际上还没做任何事 - 我们只是存了25个字节在结构体里.</p><p>我们需要想出一个方法来保存我们的变体:</p><ul><li>boxed: a String</li><li>inline: some utf-8 bytes, and I guess a length?</li></ul><p>在 &ldquo;inline&rdquo; 变体时我们不能存大于24个字节的内容, 所以我们可以使用一个 <code>u8</code> 来表示长度, 实际像下面所示:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Inline</span> {
</span></span><span style=display:flex><span>    len: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>    data: [<span style=color:#66d9ef>u8</span>; <span style=color:#ae81ff>23</span>],
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后, 为了确保我们这几个类型实际上有着相同的大小, 我们使用 <a class=link href=https://lib.rs/crates/static_assertions target=_blank rel=noopener>static_assertions</a> crate:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> static_assertions::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::mem::size_of;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[allow(dead_code)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[repr(packed)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SmartString</span> {
</span></span><span style=display:flex><span>    discriminant: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>    data: [<span style=color:#66d9ef>u8</span>; <span style=color:#ae81ff>24</span>],
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[allow(dead_code)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Inline</span> {
</span></span><span style=display:flex><span>    len: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>    data: [<span style=color:#66d9ef>u8</span>; <span style=color:#ae81ff>23</span>],
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert_eq_size<span style=color:#f92672>!</span>(String, Inline);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    dbg!(size_of::<span style=color:#f92672>&lt;</span>SmartString<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo check
</span></span><span style=display:flex><span>    Finished dev <span style=color:#f92672>[</span>unoptimized + debuginfo<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 0.00s
</span></span></code></pre></div><p>Good, 要确保足够傻瓜, 因为我们将要写很多 <code>unsafe</code> 代码, 我们甚至能按照 <code>String</code> 的大小来定义我们的 <code>Inline</code>, 这个 &ldquo;crate&rdquo; 就可以帮忙检查我们的 <code>Inline</code> 和 <code>String</code> 大小相同.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> static_assertions::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::mem::size_of;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> VARIANT_SIZE: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> std::mem::size_of::<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[allow(dead_code)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[repr(packed)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SmartString</span> {
</span></span><span style=display:flex><span>    discriminant: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>    data: [<span style=color:#66d9ef>u8</span>; VARIANT_SIZE],
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[allow(dead_code)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Inline</span> {
</span></span><span style=display:flex><span>    len: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>    data: [<span style=color:#66d9ef>u8</span>; VARIANT_SIZE <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert_eq_size<span style=color:#f92672>!</span>(String, Inline);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    dbg!(size_of::<span style=color:#f92672>&lt;</span>SmartString<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Okay, 现在让我们实现我们的手动枚举. 首先让它能够被构建.</p><p>我们仅使用了 <code>[u8; VARIANT_SIZE]</code> 来保留 <code>VARIANT_SIZE</code> 字节 - 如果我们真的想要往里面存一点东西, 我们将会用一个 <code>*mut</code> 指针指向它, 然后把它转型为我们所需要的:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> SmartString {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new_boxed</span>(s: String) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self::new(<span style=color:#ae81ff>0</span>, s)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new_inline</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self::new(
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>            Inline {
</span></span><span style=display:flex><span>                len: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>                data: Default::default(),
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(discriminant: <span style=color:#66d9ef>u8</span>, data: <span style=color:#a6e22e>T</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> res <span style=color:#f92672>=</span> Self {
</span></span><span style=display:flex><span>            discriminant,
</span></span><span style=display:flex><span>            data: Default::default(),
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> ptr: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> T <span style=color:#f92672>=</span> res.data.as_mut_ptr().cast();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsafe</span> { ptr.write_unaligned(data) };
</span></span><span style=display:flex><span>        res
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们现在可以在我们的 <code>SmartString</code> 构建这两种变体:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> boxed <span style=color:#f92672>=</span> SmartString::new_boxed(<span style=color:#e6db74>&#34;This is a longer string, would not fit inline&#34;</span>.into());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> inline <span style=color:#f92672>=</span> SmartString::new_inline();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>除此之外我们目前也不能对它做其它事情了.</p><p>让我们把它变得有用点, 例如, 从它获取一个 <code>&str</code> 切片:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> AsRef<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> SmartString {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>as_ref</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self.discriminant {
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>0</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> s: <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> ManuallyDrop<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> self.data.as_ptr().cast();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> tmp <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { s.read_unaligned() };
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>unsafe</span> { <span style=color:#f92672>&amp;*</span>(tmp.as_ref() <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>str</span>) }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>1</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> s: <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> Inline <span style=color:#f92672>=</span> self.data.as_ptr().cast();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> slice <span style=color:#f92672>=</span> std::slice::from_raw_parts((<span style=color:#f92672>*</span>s).data.as_ptr(), (<span style=color:#f92672>*</span>s).len <span style=color:#66d9ef>as</span> _);
</span></span><span style=display:flex><span>                    std::<span style=color:#66d9ef>str</span>::from_utf8_unchecked(slice)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> unreachable!(),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>还记得我之前说过的我们应该如何努力审查不安全代码以确保不会违反不变体, 在这里就比较适用. 我们使用了更安全的变体, <code>unreachable</code>, 但是如果我想冒险的话, 我会考虑使用 <a class=link href=https://doc.rust-lang.org/std/hint/fn.unreachable_unchecked.html target=_blank rel=noopener>unreachable_unchecked</a>.</p><blockquote><p>译者: 审查指: 在这里我们把 <code>discriminant</code> 当作一个枚举或者说不变体 <code>match</code> 了, 因为它的值只有可能是0或者1以表示内容是 <code>inline</code> or <code>boxed</code>, 但是可能会有前文像 <code>C</code> 那样在开发过程中传递了非法的值而导致错误, 所以使用 <code>unreachable!</code> 宏来确保不会有这种情况出现, 在编译期就可以友好地提示开发者, 以使代码更加安全.</p></blockquote><p>现在我们有了一个 <code>AsRef</code> 实现, 我们可以打印出它的实际内容了 - 而不需要在意实际上它的变体是什么(<code>Inline</code> or <code>Boxoed</code>).</p><p>方便起见, 我们实现 <code>Display</code> 和 <code>Debug</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::fmt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> fmt::Display <span style=color:#66d9ef>for</span> SmartString {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fmt</span>(<span style=color:#f92672>&amp;</span>self, f: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> fmt::Formatter<span style=color:#f92672>&lt;&#39;</span>_<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>fmt</span>::Result {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span> <span style=color:#f92672>=</span> self.as_ref();
</span></span><span style=display:flex><span>        fmt::Display::fmt(s, f)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> fmt::Debug <span style=color:#66d9ef>for</span> SmartString {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fmt</span>(<span style=color:#f92672>&amp;</span>self, f: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> fmt::Formatter<span style=color:#f92672>&lt;&#39;</span>_<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>fmt</span>::Result {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span> <span style=color:#f92672>=</span> self.as_ref();
</span></span><span style=display:flex><span>        fmt::Debug::fmt(s, f)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> boxed <span style=color:#f92672>=</span> SmartString::new_boxed(<span style=color:#e6db74>&#34;This is a longer string, would not fit inline&#34;</span>.into());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> inline <span style=color:#f92672>=</span> SmartString::new_inline();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    dbg!(boxed, inline);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:84<span style=color:#f92672>]</span> boxed <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;This is a longer string, would not fit inline&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:84<span style=color:#f92672>]</span> inline <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span></code></pre></div><p>我们还有很多事情没做 - 我们不能改变我们的 <code>SmartString</code>, 但是 <code>smartstring</code> 是允许的. 我们也不能降级我们的 <code>boxed</code> 为 <code>inline</code>, 我们也不能把 <code>inline</code> 提升为 <code>boxed</code> 以防它存太多东西了.</p><p>虽然, 但目前有更紧迫的事情要做.</p><p>请允许我缓缓道来.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s: String <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;this is just some text&#34;</span>.into();
</span></span><span style=display:flex><span>    dbg!(s);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo build --quiet --release <span style=color:#f92672>&amp;&amp;</span> valgrind --tool<span style=color:#f92672>=</span>memcheck ./target/release/enumpeek
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173592<span style=color:#f92672>==</span> Memcheck, a memory error detector
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173592<span style=color:#f92672>==</span> Copyright <span style=color:#f92672>(</span>C<span style=color:#f92672>)</span> 2002-2017, and GNU GPL<span style=color:#ae81ff>\&#39;</span>d, by Julian Seward et al.
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173592<span style=color:#f92672>==</span> Using Valgrind-3.16.1 and LibVEX; rerun with -h <span style=color:#66d9ef>for</span> copyright info
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173592<span style=color:#f92672>==</span> Command: ./target/release/enumpeek
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173592<span style=color:#f92672>==</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:82<span style=color:#f92672>]</span> s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;this is just some text&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173592<span style=color:#f92672>==</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173592<span style=color:#f92672>==</span> HEAP SUMMARY:
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173592<span style=color:#f92672>==</span>     in use at exit: <span style=color:#ae81ff>0</span> bytes in <span style=color:#ae81ff>0</span> blocks
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173592<span style=color:#f92672>==</span>   total heap usage: <span style=color:#ae81ff>15</span> allocs, <span style=color:#ae81ff>15</span> frees, 2,335 bytes allocated
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173592<span style=color:#f92672>==</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173592<span style=color:#f92672>==</span> All heap blocks were freed -- no leaks are possible
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173592<span style=color:#f92672>==</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173592<span style=color:#f92672>==</span> For lists of detected and suppressed errors, rerun with: -s
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173592<span style=color:#f92672>==</span> ERROR SUMMARY: <span style=color:#ae81ff>0</span> errors from <span style=color:#ae81ff>0</span> contexts <span style=color:#f92672>(</span>suppressed: <span style=color:#ae81ff>0</span> from 0<span style=color:#f92672>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s: <span style=color:#a6e22e>SmartString</span> <span style=color:#f92672>=</span> SmartString::new_boxed(<span style=color:#e6db74>&#34;this is just some text&#34;</span>.into());
</span></span><span style=display:flex><span>    dbg!(s);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo build --quiet --release <span style=color:#f92672>&amp;&amp;</span> valgrind --tool<span style=color:#f92672>=</span>memcheck ./target/release/enumpeek
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span> Memcheck, a memory error detector
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span> Copyright <span style=color:#f92672>(</span>C<span style=color:#f92672>)</span> 2002-2017, and GNU GPL<span style=color:#ae81ff>\&#39;</span>d, by Julian Seward et al.
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span> Using Valgrind-3.16.1 and LibVEX; rerun with -h <span style=color:#66d9ef>for</span> copyright info
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span> Command: ./target/release/enumpeek
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:82<span style=color:#f92672>]</span> s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;this is just some text&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span> HEAP SUMMARY:
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span>     in use at exit: <span style=color:#ae81ff>22</span> bytes in <span style=color:#ae81ff>1</span> blocks
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span>   total heap usage: <span style=color:#ae81ff>15</span> allocs, <span style=color:#ae81ff>14</span> frees, 2,335 bytes allocated
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span> LEAK SUMMARY:
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span>    definitely lost: <span style=color:#ae81ff>22</span> bytes in <span style=color:#ae81ff>1</span> blocks
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span>    indirectly lost: <span style=color:#ae81ff>0</span> bytes in <span style=color:#ae81ff>0</span> blocks
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span>      possibly lost: <span style=color:#ae81ff>0</span> bytes in <span style=color:#ae81ff>0</span> blocks
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span>    still reachable: <span style=color:#ae81ff>0</span> bytes in <span style=color:#ae81ff>0</span> blocks
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span>         suppressed: <span style=color:#ae81ff>0</span> bytes in <span style=color:#ae81ff>0</span> blocks
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span> Rerun with --leak-check<span style=color:#f92672>=</span>full to see details of leaked memory
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span> For lists of detected and suppressed errors, rerun with: -s
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>173779<span style=color:#f92672>==</span> ERROR SUMMARY: <span style=color:#ae81ff>0</span> errors from <span style=color:#ae81ff>0</span> contexts <span style=color:#f92672>(</span>suppressed: <span style=color:#ae81ff>0</span> from 0<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>我们发生了内存泄漏!</p><p><code>String</code> 只是一个单纯的结构体, 但它在堆中有自己的内存分配. 在我们的 <code>SmartString::new_boxed</code> 中, 我们拿了 <code>String</code> 的所有权, 并且它有着在堆中相关联的内存我们不曾释放.</p><p>编译器不知道释放我们保存在 <code>SmartString</code> 以 <code>boxed</code> 形式存放的 <code>String</code>, 因为它不知道我们拿的是什么类型 - 它只知道我们用了24个字节, 这24个字节可能放着任何东西.</p><p>如果我们知道这个类型, 事实上确实, 只是个 <code>String</code>, 并且它们需要被 <code>dropped</code>, 我们需要告诉编译器.</p><p>下面是我们做 <code>Drop</code> 的第一次痛苦经历:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Drop <span style=color:#66d9ef>for</span> SmartString {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>drop</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self.discriminant {
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>0</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> s: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> String <span style=color:#f92672>=</span> self.data.as_mut_ptr().cast();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> b: String <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { <span style=color:#f92672>*</span>s };
</span></span><span style=display:flex><span>                drop(b);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>1</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// etc.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            }
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> unreachable!(),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span>error<span style=color:#f92672>[</span>E0507<span style=color:#f92672>]</span>: cannot move out of <span style=color:#e6db74>`</span>*s<span style=color:#e6db74>`</span> which is behind a raw pointer
</span></span><span style=display:flex><span>  --&gt; src/main.rs:46:42
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span><span style=color:#ae81ff>46</span> |                 let b: String <span style=color:#f92672>=</span> unsafe <span style=color:#f92672>{</span> *s <span style=color:#f92672>}</span>;
</span></span><span style=display:flex><span>   |                                          ^^
</span></span><span style=display:flex><span>   |                                          |
</span></span><span style=display:flex><span>   |                                          move occurs because <span style=color:#e6db74>`</span>*s<span style=color:#e6db74>`</span> has type <span style=color:#e6db74>`</span>std::string::String<span style=color:#e6db74>`</span>, which does not implement the <span style=color:#e6db74>`</span>Copy<span style=color:#e6db74>`</span> trait
</span></span><span style=display:flex><span>   |                                          help: consider borrowing here: <span style=color:#e6db74>`</span>&amp;*s<span style=color:#e6db74>`</span>
</span></span></code></pre></div><p>Woops, 这不能工作, 我们不能从一个 <code>raw pointer</code> <code>move</code> 因为 <code>String</code> 不是 <code>Copy</code>.</p><p>我们能做些什么? 我们能把它 <code>Box</code> 起来么, <code>Box</code> 有一个 <code>from_raw</code> 方法, 这听起来不错:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Drop <span style=color:#66d9ef>for</span> SmartString {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>drop</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self.discriminant {
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>0</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> s: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> String <span style=color:#f92672>=</span> self.data.as_mut_ptr().cast();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { Box::from_raw(s) };
</span></span><span style=display:flex><span>                drop(b);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>1</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// etc.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            }
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> unreachable!(),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:117<span style=color:#f92672>]</span> s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;this is just some text&#34;</span>
</span></span><span style=display:flex><span>free<span style=color:#f92672>()</span>: invalid pointer
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>    <span style=color:#ae81ff>179297</span> abort <span style=color:#f92672>(</span>core dumped<span style=color:#f92672>)</span>  cargo run -q
</span></span></code></pre></div><p>Uh, oh.</p><p>让我们用我们友好的 <code>Valgrind</code> 检查一下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>$</span> cargo build <span style=color:#f92672>--</span>quiet <span style=color:#f92672>--</span>release <span style=color:#f92672>&amp;&amp;</span> valgrind <span style=color:#f92672>--</span>tool<span style=color:#f92672>=</span>memcheck .<span style=color:#f92672>/</span>target<span style=color:#f92672>/</span>release<span style=color:#f92672>/</span>enumpeek
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span> Memcheck, a memory error detector
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span> Copyright (C) <span style=color:#ae81ff>2002</span><span style=color:#f92672>-</span><span style=color:#ae81ff>2017</span>, and GNU GPL<span style=color:#f92672>&#39;</span><span style=color:#a6e22e>d</span>, by Julian Seward et al.
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span> Using Valgrind<span style=color:#f92672>-</span><span style=color:#ae81ff>3.16.1</span> and LibVEX; rerun with <span style=color:#f92672>-</span>h <span style=color:#66d9ef>for</span> copyright info
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span> Command: .<span style=color:#f92672>/</span>target<span style=color:#f92672>/</span>release<span style=color:#f92672>/</span>enumpeek
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span> 
</span></span><span style=display:flex><span>[src<span style=color:#f92672>/</span>main.rs:<span style=color:#ae81ff>117</span>] s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;this is just some text&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span> Invalid free() <span style=color:#f92672>/</span> delete <span style=color:#f92672>/</span> delete[] <span style=color:#f92672>/</span> realloc()
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span>    at <span style=color:#ae81ff>0x483B9AB</span>: <span style=color:#a6e22e>free</span> (vg_replace_malloc.c:<span style=color:#ae81ff>538</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span>    by <span style=color:#ae81ff>0x10D501</span>: <span style=color:#a6e22e>enumpeek</span>::main (<span style=color:#66d9ef>in</span> <span style=color:#f92672>/</span>home<span style=color:#f92672>/</span>amos<span style=color:#f92672>/</span>ftl<span style=color:#f92672>/</span>enumpeek<span style=color:#f92672>/</span>target<span style=color:#f92672>/</span>release<span style=color:#f92672>/</span>enumpeek)
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span>    by <span style=color:#ae81ff>0x10D8E2</span>: <span style=color:#a6e22e>std</span>::rt::lang_start::{{closure}} (<span style=color:#66d9ef>in</span> <span style=color:#f92672>/</span>home<span style=color:#f92672>/</span>amos<span style=color:#f92672>/</span>ftl<span style=color:#f92672>/</span>enumpeek<span style=color:#f92672>/</span>target<span style=color:#f92672>/</span>release<span style=color:#f92672>/</span>enumpeek)
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span>    by <span style=color:#ae81ff>0x1163F7</span>: {{closure}} (rt.rs:<span style=color:#ae81ff>52</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span>    by <span style=color:#ae81ff>0x1163F7</span>: <span style=color:#a6e22e>do_call</span><span style=color:#f92672>&lt;</span>closure<span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>,<span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> (panicking.rs:<span style=color:#ae81ff>297</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span>    by <span style=color:#ae81ff>0x1163F7</span>: <span style=color:#a6e22e>try</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span>,closure<span style=color:#f92672>-</span><span style=color:#ae81ff>0</span><span style=color:#f92672>&gt;</span> (panicking.rs:<span style=color:#ae81ff>274</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span>    by <span style=color:#ae81ff>0x1163F7</span>: <span style=color:#a6e22e>catch_unwind</span><span style=color:#f92672>&lt;</span>closure<span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>,<span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> (panic.rs:<span style=color:#ae81ff>394</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span>    by <span style=color:#ae81ff>0x1163F7</span>: <span style=color:#a6e22e>std</span>::rt::lang_start_internal (rt.rs:<span style=color:#ae81ff>51</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span>    by <span style=color:#ae81ff>0x10D561</span>: <span style=color:#a6e22e>main</span> (<span style=color:#66d9ef>in</span> <span style=color:#f92672>/</span>home<span style=color:#f92672>/</span>amos<span style=color:#f92672>/</span>ftl<span style=color:#f92672>/</span>enumpeek<span style=color:#f92672>/</span>target<span style=color:#f92672>/</span>release<span style=color:#f92672>/</span>enumpeek)
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span>  Address <span style=color:#ae81ff>0x1ffefff561</span> is on thread <span style=color:#ae81ff>1</span><span style=color:#f92672>&#39;</span><span style=color:#a6e22e>s</span> stack
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span>  <span style=color:#66d9ef>in</span> frame #<span style=color:#ae81ff>1</span>, created by enumpeek::main (<span style=color:#f92672>???</span>:)
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span> HEAP SUMMARY:
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span>     <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>use</span> at exit: <span style=color:#ae81ff>0</span> bytes <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span> blocks
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span>   total heap usage: <span style=color:#ae81ff>15</span> allocs, <span style=color:#ae81ff>16</span> frees, <span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>335</span> bytes allocated
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span> All heap blocks were freed <span style=color:#f92672>--</span> no leaks are possible
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span> For lists of detected and suppressed errors, rerun with: <span style=color:#f92672>-</span>s
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#ae81ff>179648</span><span style=color:#f92672>==</span> ERROR SUMMARY: <span style=color:#ae81ff>1</span> errors from <span style=color:#ae81ff>1</span> contexts (suppressed: <span style=color:#ae81ff>0</span> from <span style=color:#ae81ff>0</span>)
</span></span></code></pre></div><p>问题看起来像是它在试图释放 <code>String</code> 就像它分配在堆上一样, 然而并没有! 实际上是 <code>String</code> 中的数据分配在堆上, 而不是 <code>String</code> 本身.</p><p>这里有一个看起来生效的方法:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Drop <span style=color:#66d9ef>for</span> SmartString {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>drop</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self.discriminant {
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>0</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> s: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> String <span style=color:#f92672>=</span> self.data.as_mut_ptr().cast();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> s: String <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { std::ptr::read_unaligned(s) };
</span></span><span style=display:flex><span>                drop(s);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>1</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// etc.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            }
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> unreachable!(),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们可以更进一步:</p><ul><li>使用泛型函数来减少重复代码.</li><li>省略掉 <code>drop</code>, 在 <code>std::ptr::read_unaligned</code> 离开作用域后自动调用.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> SmartString {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>drop_variant</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span>self) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsafe</span> { std::ptr::read_unaligned(self.data.as_ptr().cast::<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>()) };
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Drop <span style=color:#66d9ef>for</span> SmartString {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>drop</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self.discriminant {
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>0</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>unsafe</span> { self.drop_variant::<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>() },
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>1</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>unsafe</span> { self.drop_variant::<span style=color:#f92672>&lt;</span>Inline<span style=color:#f92672>&gt;</span>() },
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> unreachable!(),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo build --quiet --release <span style=color:#f92672>&amp;&amp;</span> valgrind --tool<span style=color:#f92672>=</span>memcheck ./target/release/enumpeek
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>181085<span style=color:#f92672>==</span> Memcheck, a memory error detector
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>181085<span style=color:#f92672>==</span> Copyright <span style=color:#f92672>(</span>C<span style=color:#f92672>)</span> 2002-2017, and GNU GPL<span style=color:#ae81ff>\&#39;</span>d, by Julian Seward et al.
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>181085<span style=color:#f92672>==</span> Using Valgrind-3.16.1 and LibVEX; rerun with -h <span style=color:#66d9ef>for</span> copyright info
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>181085<span style=color:#f92672>==</span> Command: ./target/release/enumpeek
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>181085<span style=color:#f92672>==</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:99<span style=color:#f92672>]</span> s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;this is just some text&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>181085<span style=color:#f92672>==</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>181085<span style=color:#f92672>==</span> HEAP SUMMARY:
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>181085<span style=color:#f92672>==</span>     in use at exit: <span style=color:#ae81ff>0</span> bytes in <span style=color:#ae81ff>0</span> blocks
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>181085<span style=color:#f92672>==</span>   total heap usage: <span style=color:#ae81ff>15</span> allocs, <span style=color:#ae81ff>15</span> frees, 2,335 bytes allocated
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>181085<span style=color:#f92672>==</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>181085<span style=color:#f92672>==</span> All heap blocks were freed -- no leaks are possible
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>181085<span style=color:#f92672>==</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>181085<span style=color:#f92672>==</span> For lists of detected and suppressed errors, rerun with: -s
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>181085<span style=color:#f92672>==</span> ERROR SUMMARY: <span style=color:#ae81ff>0</span> errors from <span style=color:#ae81ff>0</span> contexts <span style=color:#f92672>(</span>suppressed: <span style=color:#ae81ff>0</span> from 0<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>完美, 但是这完全正确了吗? 我不知道, 在让一堆人测试看看之前我是不会把代码用到生产环境中的. 但是至少在我们的 <code>case</code> 中, 它已经没有发生内存泄漏了.</p><p>这总归是好的.</p><p>我们可以在我们的结构体中花上整天时间都在这重新实现 <code>smartstring</code> 里面的功能, 但是有个点需要记住, 我们的版本比 <code>smartstring</code> 大了足足一个字节.</p><p>就像 <code>smallvec::SmallVec</code> 类型比 <code>Vec</code> 大一样.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo add smallvec
</span></span><span style=display:flex><span>      Adding smallvec v1.4.2 to dependencies
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::mem::size_of;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> smallvec::SmallVec;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    dbg!(size_of::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;&gt;</span>(), size_of::<span style=color:#f92672>&lt;</span>SmallVec<span style=color:#f92672>&lt;</span>[<span style=color:#66d9ef>u8</span>; <span style=color:#ae81ff>1</span>]<span style=color:#f92672>&gt;&gt;</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:100<span style=color:#f92672>]</span> size_of::&lt;Vec&lt;u8&gt;&gt;<span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>24</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:100<span style=color:#f92672>]</span> size_of::&lt;SmallVec&lt;<span style=color:#f92672>[</span>u8; 1<span style=color:#f92672>]</span>&gt;&gt;<span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>32</span>
</span></span></code></pre></div><p>因此, 希望到目前为止本文讲述的足足44分钟的时间里你已经 <strong>完全</strong> 明白了为什么这是一个有趣的问题(请回忆下开篇所提到的问题).</p><p>它的神秘不在于 <code>SmallVec&lt;[u8; 1]></code> 比 <code>Vec&lt;u8></code> 大8个字节, 因为 <code>SmallVec</code> 只是一个枚举, 它的判定式只需要考虑两个变体, 但是因为 <code>Rust</code> 需要额外的空间来保证对齐, 所以多用了整整8个字节.</p><p>它的神秘在于, <code>SmartString</code> 是怎么做到只有24个字节的.</p><p>为了回答这个问题, 我们需要更深入的观察指针.</p><h2 id=仔细看看指针>仔细看看指针</h2><p>So, 什么是指针? 只是一串数字? 它告诉了你有些东西在内存的哪个地方.</p><p>举个例子, 如果我们声明了一个本地变量 <code>x</code>, <code>i32</code>, 它可能直立在栈上:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// this is a signed 32-bit integer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>30</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// this is a reference to a signed 32-bit integer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> x_ref <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>x;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// this is a pointer to a signed 32-bit integer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> x_ptr <span style=color:#f92672>=</span> x_ref <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> _;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    dbg!(x_ptr);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:105<span style=color:#f92672>]</span> x_ptr <span style=color:#f92672>=</span> 0x00007fff10be39ec
</span></span></code></pre></div><p>当然, 一个本地变量也可能在寄存器中. 但这在这里无关紧要. 一旦我们获取了某个对象的地址, 它就需要映射到虚拟内存地址空间的某个地方, 而在寄存器中的则不需要, 为了方便解释, 我们现在假装寄存器不存在.</p><p>So, 数字是为了告诉你某些东西在内存中的位置. 这就像是地址, 就跟国家有实际位置的地址一样, 只是多了些间接性.</p><p>一个对齐的指针是一个其值(地址)是数据大小的倍数的指针. 当数据是自然对齐的时候对 CPUs 来说很方便.</p><p>让我们看一些例子.</p><p>我们可以在内存中寻址的的最小单元是字节. 一个指向字节的指针总是对齐的, 因为指针用字节来计数, 换句话说, 一个 <code>u8</code> 的对齐单位就是1.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> arr <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span><span style=color:#66d9ef>u8</span>, <span style=color:#ae81ff>2</span><span style=color:#66d9ef>u8</span>, <span style=color:#ae81ff>3</span><span style=color:#66d9ef>u8</span>, <span style=color:#ae81ff>4</span><span style=color:#66d9ef>u8</span>];
</span></span><span style=display:flex><span>    dbg!(
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>arr[<span style=color:#ae81ff>0</span>] <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> _,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>arr[<span style=color:#ae81ff>1</span>] <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> _,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>arr[<span style=color:#ae81ff>2</span>] <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> _,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>arr[<span style=color:#ae81ff>3</span>] <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> _,
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:106<span style=color:#f92672>]</span> &amp;arr<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> as *const _ <span style=color:#f92672>=</span> 0x00007ffd6474abdc
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:106<span style=color:#f92672>]</span> &amp;arr<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> as *const _ <span style=color:#f92672>=</span> 0x00007ffd6474abdd
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:106<span style=color:#f92672>]</span> &amp;arr<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> as *const _ <span style=color:#f92672>=</span> 0x00007ffd6474abde
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:106<span style=color:#f92672>]</span> &amp;arr<span style=color:#f92672>[</span>3<span style=color:#f92672>]</span> as *const _ <span style=color:#f92672>=</span> 0x00007ffd6474abdf
</span></span></code></pre></div><p>如果讨论的是指向 <code>u16</code> 的指针, 那么它的对齐单位是2.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>fn main<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    let arr <span style=color:#f92672>=</span> <span style=color:#f92672>[</span>1u16, 2u16, 3u16, 4u16<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    fn inspect&lt;T&gt;<span style=color:#f92672>(</span>t: *const T<span style=color:#f92672>)</span> -&gt; <span style=color:#f92672>(</span>*const T, bool<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>(</span>t, t as usize % 2 <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    dbg!<span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>        inspect<span style=color:#f92672>(</span>&amp;arr<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> as *const _<span style=color:#f92672>)</span>,
</span></span><span style=display:flex><span>        inspect<span style=color:#f92672>(</span>&amp;arr<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> as *const _<span style=color:#f92672>)</span>,
</span></span><span style=display:flex><span>        inspect<span style=color:#f92672>(</span>&amp;arr<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> as *const _<span style=color:#f92672>)</span>,
</span></span><span style=display:flex><span>        inspect<span style=color:#f92672>(</span>&amp;arr<span style=color:#f92672>[</span>3<span style=color:#f92672>]</span> as *const _<span style=color:#f92672>)</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:110<span style=color:#f92672>]</span> inspect<span style=color:#f92672>(</span>&amp;arr<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> as *const _<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>    0x00007ffd81bf5918,
</span></span><span style=display:flex><span>    true,
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:110<span style=color:#f92672>]</span> inspect<span style=color:#f92672>(</span>&amp;arr<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> as *const _<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>    0x00007ffd81bf591a,
</span></span><span style=display:flex><span>    true,
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:110<span style=color:#f92672>]</span> inspect<span style=color:#f92672>(</span>&amp;arr<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> as *const _<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>    0x00007ffd81bf591c,
</span></span><span style=display:flex><span>    true,
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:110<span style=color:#f92672>]</span> inspect<span style=color:#f92672>(</span>&amp;arr<span style=color:#f92672>[</span>3<span style=color:#f92672>]</span> as *const _<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>    0x00007ffd81bf591e,
</span></span><span style=display:flex><span>    true,
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span></code></pre></div><p>同理, 对于 <code>u32</code> 是4, <code>u64</code> 是8.</p><p>下面有一个正确对齐的例子:</p><p>底部的小方块表示如果我们想要存该类型, 可以把它放在那里.</p><p>顶部部分表示实际的内存布局, 举个例子, 一个结构体:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdint.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stddef.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> S {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> c;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> d;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;sizeof(S) = %ld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> S));
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;offsetof(struct S, a) = %zu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, offsetof(<span style=color:#66d9ef>struct</span> S, a));
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;offsetof(struct S, b) = %zu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, offsetof(<span style=color:#66d9ef>struct</span> S, b));
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;offsetof(struct S, c) = %zu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, offsetof(<span style=color:#66d9ef>struct</span> S, c));
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;offsetof(struct S, d) = %zu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, offsetof(<span style=color:#66d9ef>struct</span> S, d));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ clang -Wall main.c -o main <span style=color:#f92672>&amp;&amp;</span> ./main
</span></span><span style=display:flex><span>sizeof<span style=color:#f92672>(</span>S<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>offsetof<span style=color:#f92672>(</span>struct S, a<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>offsetof<span style=color:#f92672>(</span>struct S, b<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>offsetof<span style=color:#f92672>(</span>struct S, c<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>offsetof<span style=color:#f92672>(</span>struct S, d<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
</span></span></code></pre></div><p>在这里, 一切顺利.</p><p>我们用另一个布局代替看看:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> S {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> c;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> d;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ clang -Wall main.c -o main <span style=color:#f92672>&amp;&amp;</span> ./main
</span></span><span style=display:flex><span>sizeof<span style=color:#f92672>(</span>S<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span>offsetof<span style=color:#f92672>(</span>struct S, a<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>offsetof<span style=color:#f92672>(</span>struct S, b<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>offsetof<span style=color:#f92672>(</span>struct S, c<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>offsetof<span style=color:#f92672>(</span>struct S, d<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>
</span></span></code></pre></div><p>为了维持对齐, 编译器插入了废料:</p><p>&ldquo;Padding&rdquo; 不绝对是置零 - 它只是没有使用的空间. 即使它初始化置零了, 也不能保证它会在你分配成员的时候维持0.</p><p>经常使用该结构体可能会混淆值和填充的 <code>padding</code>, 因此一个好的 <code>old block memory comparison</code> (memcmp) 不能够测试两个结构体是否完全相等.</p><blockquote><p>原文: Regular usage of the struct might mess with the values in the padding, and so a good old block memory comparison (memcmp) would not be enough to test two structs for equality.</p></blockquote><blockquote><p>译者: 这里没懂作者想说什么, 有人清楚的话可以提个issue给我.</p></blockquote><p>我们在 <code>Rust</code> 中定义一个相同布局的结构体会发生什么?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>S</span> {
</span></span><span style=display:flex><span>        a: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>        b: <span style=color:#66d9ef>u16</span>,
</span></span><span style=display:flex><span>        c: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>        d: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    dbg!(std::mem::size_of::<span style=color:#f92672>&lt;</span>S<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:112<span style=color:#f92672>]</span> std::mem::size_of::&lt;S&gt;<span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>
</span></span></code></pre></div><p>为什么只有8个字节? 发生了什么? 让我们来借助工具看看它的布局:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo add memoffset
</span></span><span style=display:flex><span>      Adding memoffset v0.5.5 to dependencies
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>S</span> {
</span></span><span style=display:flex><span>        a: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>        b: <span style=color:#66d9ef>u16</span>,
</span></span><span style=display:flex><span>        c: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>        d: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> memoffset::offset_of;
</span></span><span style=display:flex><span>    dbg!(
</span></span><span style=display:flex><span>        std::mem::size_of::<span style=color:#f92672>&lt;</span>S<span style=color:#f92672>&gt;</span>(),
</span></span><span style=display:flex><span>        offset_of<span style=color:#f92672>!</span>(S, a),
</span></span><span style=display:flex><span>        offset_of<span style=color:#f92672>!</span>(S, b),
</span></span><span style=display:flex><span>        offset_of<span style=color:#f92672>!</span>(S, c),
</span></span><span style=display:flex><span>        offset_of<span style=color:#f92672>!</span>(S, d)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:113<span style=color:#f92672>]</span> std::mem::size_of::&lt;S&gt;<span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:113<span style=color:#f92672>]</span> offset_of!<span style=color:#f92672>(</span>S, a<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:113<span style=color:#f92672>]</span> offset_of!<span style=color:#f92672>(</span>S, b<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:113<span style=color:#f92672>]</span> offset_of!<span style=color:#f92672>(</span>S, c<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:113<span style=color:#f92672>]</span> offset_of!<span style=color:#f92672>(</span>S, d<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>我们的成员被重新排序了!</p><p>我们可以让 <code>Rust compiler</code> 不要重排序就像 <code>C</code> 一样通过 <code>repr(C)</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[repr(C)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>S</span> {
</span></span><span style=display:flex><span>        a: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>        b: <span style=color:#66d9ef>u16</span>,
</span></span><span style=display:flex><span>        c: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>        d: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> memoffset::offset_of;
</span></span><span style=display:flex><span>    dbg!(
</span></span><span style=display:flex><span>        std::mem::size_of::<span style=color:#f92672>&lt;</span>S<span style=color:#f92672>&gt;</span>(),
</span></span><span style=display:flex><span>        offset_of<span style=color:#f92672>!</span>(S, a),
</span></span><span style=display:flex><span>        offset_of<span style=color:#f92672>!</span>(S, b),
</span></span><span style=display:flex><span>        offset_of<span style=color:#f92672>!</span>(S, c),
</span></span><span style=display:flex><span>        offset_of<span style=color:#f92672>!</span>(S, d)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:11<span style=color:#f92672>]</span> std::mem::size_of::&lt;S&gt;<span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:11<span style=color:#f92672>]</span> offset_of!<span style=color:#f92672>(</span>S, a<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:11<span style=color:#f92672>]</span> offset_of!<span style=color:#f92672>(</span>S, b<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:11<span style=color:#f92672>]</span> offset_of!<span style=color:#f92672>(</span>S, c<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:11<span style=color:#f92672>]</span> offset_of!<span style=color:#f92672>(</span>S, d<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>
</span></span></code></pre></div><p>现在我们有了和 <code>C</code> 一样的布局了, 也有着相同的填充.</p><p>或者也可以让编译器既不要重新排序也不要填充以完全忽略对齐:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[repr(C, packed)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>S</span> {
</span></span><span style=display:flex><span>        a: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>        b: <span style=color:#66d9ef>u16</span>,
</span></span><span style=display:flex><span>        c: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>        d: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> memoffset::offset_of;
</span></span><span style=display:flex><span>    dbg!(
</span></span><span style=display:flex><span>        std::mem::size_of::<span style=color:#f92672>&lt;</span>S<span style=color:#f92672>&gt;</span>(),
</span></span><span style=display:flex><span>        offset_of<span style=color:#f92672>!</span>(S, a),
</span></span><span style=display:flex><span>        offset_of<span style=color:#f92672>!</span>(S, b),
</span></span><span style=display:flex><span>        offset_of<span style=color:#f92672>!</span>(S, c),
</span></span><span style=display:flex><span>        offset_of<span style=color:#f92672>!</span>(S, d)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在, <code>S.b</code> 不再很好地对齐了.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:11<span style=color:#f92672>]</span> std::mem::size_of::&lt;S&gt;<span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:11<span style=color:#f92672>]</span> offset_of!<span style=color:#f92672>(</span>S, a<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:11<span style=color:#f92672>]</span> offset_of!<span style=color:#f92672>(</span>S, b<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:11<span style=color:#f92672>]</span> offset_of!<span style=color:#f92672>(</span>S, c<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:11<span style=color:#f92672>]</span> offset_of!<span style=color:#f92672>(</span>S, d<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
</span></span></code></pre></div><p>假如我们尝试获取一个引用, <code>Rust</code> 会警告我们(当前只是 <code>warn</code>, 以后可能会变成一个 <code>error</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[repr(C, packed)]</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[derive(Default)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>S</span> {
</span></span><span style=display:flex><span>        a: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>        b: <span style=color:#66d9ef>u16</span>,
</span></span><span style=display:flex><span>        c: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>        d: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s: <span style=color:#a6e22e>S</span> <span style=color:#f92672>=</span> Default::default();
</span></span><span style=display:flex><span>    dbg!(<span style=color:#f92672>&amp;</span>s.b);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span>warning: borrow of packed field is unsafe and requires unsafe <span style=color:#66d9ef>function</span> or block <span style=color:#f92672>(</span>error E0133<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  --&gt; src/main.rs:12:10
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span><span style=color:#ae81ff>12</span> |     dbg!<span style=color:#f92672>(</span>&amp;s.b<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>   |          ^^^^
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>   <span style=color:#f92672>=</span> note: <span style=color:#e6db74>`</span><span style=color:#75715e>#[warn(safe_packed_borrows)]` on by default</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>=</span> warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
</span></span><span style=display:flex><span>   <span style=color:#f92672>=</span> note: <span style=color:#66d9ef>for</span> more information, see issue <span style=color:#75715e>#46043 &lt;https://github.com/rust-lang/rust/issues/46043&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>=</span> note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>warning: <span style=color:#ae81ff>1</span> warning emitted
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>src/main.rs:12<span style=color:#f92672>]</span> &amp;s.b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>迄今&mldr; 所有的事情在我 <code>2018 i7</code> 处理器上工作得很好.</p><p>我们可以改变它也没有任何问题:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[repr(C, packed)]</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[derive(Default)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>S</span> {
</span></span><span style=display:flex><span>        a: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>        b: <span style=color:#66d9ef>u16</span>,
</span></span><span style=display:flex><span>        c: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>        d: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> s: <span style=color:#a6e22e>S</span> <span style=color:#f92672>=</span> Default::default();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>        s.b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x123</span>;
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;{:#x}&#34;</span>, s.b);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span>0x123
</span></span></code></pre></div><p>这并不是获得未对齐指针的唯一方法, 使用指针类型转换我们也可以把两个 <code>u8</code> 当作一个单独的未对齐的 <code>u16</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> arr <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span><span style=color:#66d9ef>u8</span>, <span style=color:#ae81ff>2</span><span style=color:#66d9ef>u8</span>, <span style=color:#ae81ff>3</span><span style=color:#66d9ef>u8</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> ptr_u16 <span style=color:#f92672>=</span> (<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> arr[<span style=color:#ae81ff>1</span>]) <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> _ <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>u16</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>ptr_u16 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x123</span>;
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;{:#x}&#34;</span>, <span style=color:#f92672>*</span>ptr_u16);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意, <code>clippy</code> 会捕获到这个, 并且认为这是一个错误.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo clippy
</span></span><span style=display:flex><span>    Checking enumpeek v0.1.0 <span style=color:#f92672>(</span>/home/amos/ftl/enumpeek<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>error: casting from <span style=color:#e6db74>`</span>*mut u8<span style=color:#e6db74>`</span> to a more-strictly-aligned pointer <span style=color:#f92672>(</span><span style=color:#e6db74>`</span>*mut u16<span style=color:#e6db74>`</span><span style=color:#f92672>)</span> <span style=color:#f92672>(</span><span style=color:#ae81ff>1</span> &lt; <span style=color:#ae81ff>2</span> bytes<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> --&gt; src/main.rs:3:19
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span> |     let ptr_u16 <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>&amp;mut arr<span style=color:#f92672>[</span>1<span style=color:#f92672>])</span> as *mut _ as *mut u16;
</span></span><span style=display:flex><span>  |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span>  <span style=color:#f92672>=</span> note: <span style=color:#e6db74>`</span><span style=color:#75715e>#[deny(clippy::cast_ptr_alignment)]` on by default</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>=</span> help: <span style=color:#66d9ef>for</span> further information visit https://rust-lang.github.io/rust-clippy/master/index.html#cast_ptr_alignment
</span></span></code></pre></div><p>不过这在我的电脑上依旧是可以运行的:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cargo run -q
</span></span><span style=display:flex><span>0x123
</span></span></code></pre></div><p>所以为什么我们要再次关注对齐呢?</p><p>好吧, 这是一个很长的故事&mldr;</p><h2 id=我们想要什么-对齐-我们为什么要它-well>我们想要什么? 对齐! 我们为什么要它? Well&mldr;</h2><p>回到 <code>C</code> 发明的年代, 那个时候有些处理器不怎么支持没有对齐过的内存访问.</p><p>对于这些处理器, 没有对齐的内存访问可能会导致<a class=link href=https://www.kernel.org/doc/Documentation/unaligned-memory-access.txt target=_blank rel=noopener>抛出一个处理器错误</a>: 异常处理器或许能够正常访问一个没有对齐的内存, 但是会浪费较多的性能, 或者是干脆没法访问未对齐的内存, 然后程序运行就被 abort 了.</p><p>在另一些处理器架构里, 像是英特尔的 &ldquo;Core 2&rdquo; 系列, 通常会用一些性能损耗来支持未对齐的内存.</p><p>我本来想在这里放上一些 microbenchmarks, 但是它们有时候会互相矛盾 - 基准测试有很多影响因素. 有些基准测试显示有 10% 的性能降低, 有些会降低 50%, 显然有很多会影响到关于访问未对齐内存的性能测试.</p><p>但是请记住, 即使处理器开始对未对齐内存做了一级支持, 但是出于性能原因仍然要避免使用未对齐内存.</p><p>我通常把最好的东西留到最后说 但是:</p><p>一些架构可能不会抛出处理器异常, 而是静默地执行一些不同的读操作.</p><p><img src=/post/translation/rust/peeking_inside_a_rust_enum/armv4t.jpg width=640 height=518 srcset="/post/translation/rust/peeking_inside_a_rust_enum/armv4t_hub50016a2bde62f69b78292ec788779b2_120594_480x0_resize_q75_box.jpg 480w, /post/translation/rust/peeking_inside_a_rust_enum/armv4t_hub50016a2bde62f69b78292ec788779b2_120594_1024x0_resize_q75_box.jpg 1024w" loading=lazy alt="An example ARMv4t chip: the sound processor chip for the SEGA NAOMI arcade system." class=gallery-image data-flex-grow=123 data-flex-basis=296px></p><h2 id=很久很久-在armv5以前>很久很久, 在ARMv5以前&mldr;</h2><p>我们已经在这篇文章里读了一些关于未对齐内存的内容.</p><p>所以展示上面所说的不同的读操作会相对比较容易.</p><p>首先你需要一些数据 - 我们只用了 8 个不同的字节值, 这很容易理解后面将会发生什么.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>	<span style=color:#66d9ef>uint8_t</span> arr[<span style=color:#ae81ff>8</span>] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0xef</span>, <span style=color:#ae81ff>0xcd</span>, <span style=color:#ae81ff>0xab</span>, <span style=color:#ae81ff>0x89</span>, <span style=color:#ae81ff>0x67</span>, <span style=color:#ae81ff>0x45</span>, <span style=color:#ae81ff>0x23</span>, <span style=color:#ae81ff>0x01</span> };
</span></span></code></pre></div><p>然后我们去读一个没有对齐的地址. 举个例子, 我们尝试从数组的第二个元素开始读取一个 <code>uint32_t</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdint.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> arr[<span style=color:#ae81ff>8</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0xef</span>, <span style=color:#ae81ff>0xcd</span>, <span style=color:#ae81ff>0xab</span>, <span style=color:#ae81ff>0x89</span>, <span style=color:#ae81ff>0x67</span>, <span style=color:#ae81ff>0x45</span>, <span style=color:#ae81ff>0x23</span>, <span style=color:#ae81ff>0x01</span>};
</span></span><span style=display:flex><span>    <span style=color:#75715e>// arrays are zero-indexed, so `1` is the second item
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint32_t</span> <span style=color:#f92672>*</span>ptr <span style=color:#f92672>=</span> (<span style=color:#66d9ef>uint32_t</span> <span style=color:#f92672>*</span>)(<span style=color:#f92672>&amp;</span>arr[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;0x%08x</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#f92672>*</span>ptr);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>猜猜会打印什么? 是 <code>0xcdab8967</code>? 错了!</p><p>我2018年的i7处理器是一个小端处理器:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ lscpu | grep -E <span style=color:#e6db74>&#39;(Byte Order|Model name)&#39;</span>
</span></span><span style=display:flex><span>Byte Order:                      Little Endian
</span></span><span style=display:flex><span>Model name:                      Intel<span style=color:#f92672>(</span>R<span style=color:#f92672>)</span> Core<span style=color:#f92672>(</span>TM<span style=color:#f92672>)</span> i7-8750H CPU @ 2.20GHz
</span></span></code></pre></div><p>这意味着字节是从最低有效值存储到最高有效值.</p><p>所以与其说是这样子的:</p><p>其实是这样子的:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ gcc -Wall main.c -o main <span style=color:#f92672>&amp;&amp;</span> ./main
</span></span><span style=display:flex><span>0x6789abcd
</span></span></code></pre></div><p>这就是为什么我为我的数组选了这些好辨识的值的原因.</p><p><img src=/post/translation/rust/peeking_inside_a_rust_enum/gba.jpg width=1280 height=884 srcset="/post/translation/rust/peeking_inside_a_rust_enum/gba_hu302f1c2d37f956d6cc8b3c35003135c9_97592_480x0_resize_q75_box.jpg 480w, /post/translation/rust/peeking_inside_a_rust_enum/gba_hu302f1c2d37f956d6cc8b3c35003135c9_97592_1024x0_resize_q75_box.jpg 1024w" loading=lazy alt="A &lsquo;Glacier&rsquo; Game Boy Advance - one of the colors available at launch in North America" class=gallery-image data-flex-grow=144 data-flex-basis=347px></p><p>| <a class=link href=https://devkitpro.org/wiki/Getting_Started target=_blank rel=noopener>devKitPro</a></p><p>我以前也没读过关于GBA开发的相关文档, 我只是找了个项目<a class=link href=https://vba-m.com/ target=_blank rel=noopener>VisualBoyAdvance</a>:</p><p><img src=/post/translation/rust/peeking_inside_a_rust_enum/gba-hello.png width=480 height=349 srcset="/post/translation/rust/peeking_inside_a_rust_enum/gba-hello_hu374745a0a15a6dd857febbf559df6352_9948_480x0_resize_box_3.png 480w, /post/translation/rust/peeking_inside_a_rust_enum/gba-hello_hu374745a0a15a6dd857febbf559df6352_9948_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=137 data-flex-basis=330px></p><p>这个项目的 <code>C</code> 代码看起来如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    <span style=color:#75715e>// (cut)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// clear screen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    iprintf(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x1b</span><span style=color:#e6db74>[2J&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// print at coordinates 10,10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    iprintf(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x1b</span><span style=color:#e6db74>[10;10H&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    iprintf(<span style=color:#e6db74>&#34;Hello World!&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// (cut)
</span></span></span></code></pre></div><p>So - 足够简单了!他有一些自己的 <code>printf</code> 实现 - 除此之外, 这就只是 <code>C</code>! 然后同样用 <code>GCC</code> 编译.</p><p>所以让我们的代码跑起来并不是<strong>很难</strong>.</p><p>以下是完整的代码 <code>source/console.c</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;gba_console.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;gba_video.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;gba_interrupt.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;gba_systemcalls.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>    irqInit();
</span></span><span style=display:flex><span>    irqEnable(IRQ_VBLANK);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    consoleDemoInit();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// clear screen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    iprintf(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x1b</span><span style=color:#e6db74>[2J&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// print at coordinates 10,10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    iprintf(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x1b</span><span style=color:#e6db74>[10;10H&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> arr[<span style=color:#ae81ff>8</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0xef</span>, <span style=color:#ae81ff>0xcd</span>, <span style=color:#ae81ff>0xab</span>, <span style=color:#ae81ff>0x89</span>, <span style=color:#ae81ff>0x67</span>, <span style=color:#ae81ff>0x45</span>, <span style=color:#ae81ff>0x23</span>, <span style=color:#ae81ff>0x01</span>};
</span></span><span style=display:flex><span>    <span style=color:#75715e>// arrays are zero-indexed, so `1` is the second item
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint32_t</span> <span style=color:#f92672>*</span>ptr <span style=color:#f92672>=</span> (<span style=color:#66d9ef>uint32_t</span> <span style=color:#f92672>*</span>)(<span style=color:#f92672>&amp;</span>arr[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>    iprintf(<span style=color:#e6db74>&#34;0x%08x&#34;</span>, <span style=color:#f92672>*</span>ptr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        VBlankIntrWait();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></section><footer class=article-footer><section class=article-tags><a href=/tags/translation/>Translation</a>
<a href=/tags/rust/>Rust</a>
<a href=/tags/enum/>Enum</a></section><section class=article-lastmod><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>Last updated on Jan 13, 2021 15:00 +0800</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/post/translation/rust/green_threads_explained_in_200_lines_of_rust/><div class=article-image><img src=/post/translation/rust/green_threads_explained_in_200_lines_of_rust/cover.6e5456ddb6c6b4a991a552f76e413144_hud99fec317f0d171bfccb5e21f0f08cf5_179342_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 200行Rust代码解释绿色线程" data-key=green_threads_explained_in_200_lines_of_rust data-hash="md5-blRW3bbGtKmRpVL3bkExRA=="></div><div class=article-details><h2 class=article-title>200行Rust代码解释绿色线程</h2></div></a></article><article class=has-image><a href=/post/rust/elegent_rust/><div class=article-image><img src=/post/rust/elegent_rust/cover.5260949b1ad39a8dea97c4e453c35e3b_hu99bb65b34be40363fd484c863e327c7b_227902_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 优雅的Rust" data-key=elegent_rust data-hash="md5-UmCUmxrTmo3ql8TkU8NeOw=="></div><div class=article-details><h2 class=article-title>优雅的Rust</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2022</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.13.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>